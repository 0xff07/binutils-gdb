# Copyright 2015, 2016 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Generic/oft used support routines for testing GDB's compile feature.

# Return 1 if we should skip tests of the "compile" feature.
# This must be invoked after the inferior has been started.

proc skip_compile_feature_tests {} {
    global gdb_prompt

    set result 0
    gdb_test_multiple "compile code -- ;" "check for working compile command" {
	"Could not load libcc1.*\r\n$gdb_prompt $" {
	    set result 1
	}
	-re "Command not supported on this host\\..*\r\n$gdb_prompt $" {
	    set result 1
	}
	-re "\r\n$gdb_prompt $" {
	}
    }
    return $result
}

# This namespace provides some convenience functions for running
# "compile code" and "compile print" tests.
#
# Exported functions are defined inline below.
#
# General usage:
#
# Start a new session, noting that the variable "var" will be used for
# "compile code" expressions.
# CompileExpression::new "var"
#
# Add the expression "foo;" with result/value 3.
# CompileExpression::add_imp "foo;" 3
#
# Add the expression "a = function (3); var = a;" with the result 21.
# CompileExpression::add_exp "a = function (3); var = a;" 21
#
# Run tests using "compile print".
# CompileExpression::run_tests "print"
# ---> Runs the following tests (name of tests ignored for illustration)
#    gdb_test "compile print foo;" "= 3"
#    # "explicit" expressions are ignored
#
# Run the tests using "compile code".
# CompileExpression::run_tests "code"
# ---> Runs the following tests (name of tests ignored for illustration)
#    gdb_test_no_output "compile code var = foo;"
#    gdb_test "p var" "= 3"
#    gdb_test_no_output "compoile code a = function (3); var = a;"
#    gdb_test "p var" "= 21"
#
# Additional option flags that may be passed to add_mp or add_exp:
# Pass -value, -compile, and/or -print to indicate that the value,
# compile, or print steps will optionally fail. Specify -xfail or
# -kfail to indicate how each particular step will fail.  These may be
# followed by any accepted DejaGNU parameters such as architecture and
# bug#.
#
# -compile and -value are used when "code" tests are run, the former
# specifying that the "compile code" command (to GDB) will fail or pass
# in the prescribed manner.  -value indicates that the "print $VARIABLE"
# command (to GDB) will fail in the prescribed manner.
#
# -print is used to specify that an expression will fail in the presribed
# manner when "print" tests are run.
#
# Pass "-name NAME" to set an optional test name.  If not specified,
# the harness will use test names such as "compile code EXPR" and
# "result of compile code EXPR".
#
# These options must be passed LAST to the add_imp/add_exp.
#
# Examples:
#
# Both "code" and "print" tests are expected to xfail:
# CompileExpression add_imp "foo" 3 -compile {xfail *-*-*} -print {xfail *-*-*}
#
# The "print $VARIABLE" portion of the "code" test is expected to kfail
# (the actual "compile code" GDB command will succeed), but the "print"
# test should pass:
# CompileExpression add_imp "foo" 3 -value {kfail *-*-* gdb/1234}

namespace eval ::CompileExpression {

    # The variable name to check testing results.  This variable
    # must be in scope when tests are run.
    variable varName_ {}

    # A list containing all the expressions to test.
    # The format is EXPR RESULT IS_EXPLICIT TEST_NAME OPT_FAIL_LIST
    variable expr_list_ {}

    # Start a new expression list.  VARNAME is the name of the variable
    # that will be printed to check if the result of the test was
    # successful.
    proc new {varname} {
	variable varName_
	variable expr_list_

	set varName_ $varname
	set expr_list_ {}
    }

    # Add an "implicit" expression to the list of tests to run.
    #
    # Implicit expressions will be sent to GDB in the form
    # "$varName = $EXP".  "p $varName" will be used to decide the pass
    # or fail status of the test.
    #
    # The name of the test may be optionally specified.
    #
    # Unlike explicit expressions, implicit expressions may be tested
    # with both "compile print" and "compile code".

    proc add_imp {exp result {tst ""} args} {
	variable expr_list_

	parse_args {{compile {"" ""}} {value {"" ""}} {print {"" ""}} {name ""}}
	lappend expr_list_ [list $exp $result 0 $name \
				[list $compile $value $print]]
    }

    # Add an "explicit" expression to the list of tests to run.
    #
    # Explicit expressions will be sent to GDB as-is.  The expression
    # should set the value of the variable $varName, which is then printed
    # to determine whether the test passed or failed.
    #
    # The name of the test may be optionally specified.
    #
    # Unlike implicit expressions, explicit expressions cannot be tested
    # with "compile print."  If run_tests is called with "print", any
    # explicit expressions in the expression list will be ignored.

    proc add_exp {exp result args} {
	variable expr_list_

	parse_args {{compile {"" ""}} {value {"" ""}} {print {"" ""}} {name ""}}
	lappend expr_list_ [list $exp $result 1 $name \
				[list $compile $value $print]]
    }

    # Run compile tests for CMD ("print" or "code").

    proc run_tests {cmd} {
	variable varName_
	variable expr_list_

	if {![string match $cmd "code"]
	    && ![string match $cmd "print"]} {
	    error "invalid command, $cmd; should be \"print\" or \"compile\""
	}

	foreach exp_test $expr_list_ {
	    set exp [lindex $exp_test 0]
	    set result [lindex $exp_test 1]
	    set is_explicit [lindex $exp_test 2]
	    set tst [lindex $exp_test 3]
	    set fail_list [lindex $exp_test 4]

	    # Get expected result of test.  Will be "" if test is
	    # expected to PASS.
	    lassign $fail_list fail_compile fail_value fail_print

	    # Set a test name if one hasn't been provided.
	    if {$tst == ""} {
		set tst "compile $cmd $exp"
	    }

	    if {[string match $cmd "print"]} {
		if {!$is_explicit} {
		    eval setup_failures_ $fail_print
		    gdb_test "compile print $exp" $result $tst
		}
	    } else {
		if {$is_explicit} {
		    set command "compile code $exp"
		} else {
		    set command "compile code $varName_ = $exp"
		}
		eval setup_failures_ $fail_compile
		gdb_test_no_output $command $tst
		eval setup_failures_ $fail_value
		gdb_test "p $varName_" "= $result" "result of $tst"
	    }
	}
    }

    # A convenience proc used to set up xfail and kfail tests.
    # HOW is either xfail or kfail (case is ignored).  ARGS is any
    # optional architecture, bug number, or other string to pass to
    # respective DejaGNU setup_$how routines.

    proc setup_failures_ {how args} {
	switch -nocase $how {
	    xfail {
		eval setup_xfail $args
	    }

	    kfail {
		eval setup_kfail $args
	    }

	    default {
		# Do nothing.  Either the test is expected to PASS
		# or we have an unhandled failure mode.
	    }
	}
    }
}
