# Copyright 2020 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# test debuginfod functionality

set test "debuginfod"

standard_testfile main.c

load_lib dwarf.exp

if { [which debuginfod] == 0 } {
    untested "$test (cannot find debuginfod)"
    return -1
}

if { [which curl] == 0 } {
    untested "$test (cannot find curl)"
    return -1
}

# skip testing if gdb was not configured with debuginfod
if { [string first "with-debuginfod" [exec $GDB --configuration]] == -1 } {
    untested "$test (gdb not configured with debuginfod)"
    return -1
}

set cache [file join [standard_output_file {}] ".client_cache"]
set db [file join [standard_output_file {}] ".debuginfod.db"]

# make sure there isn't an old client cache or db lying around
file delete -force $cache
file delete -force $db

# make a copy source file that we can move around
if { [catch {file copy -force ${srcdir}/${subdir}/${srcfile} \
              [standard_output_file tmp-${srcfile}]}] != 0 } {
    error "$test (create temporary file)"
    return -1
}

set sourcetmp [standard_output_file tmp-${srcfile}]
set outputdir [standard_output_file {}]

if { [gdb_compile "$sourcetmp" "$binfile" executable {debug}] != "" } {
    fail "$test (compile)"
    return -1
}

# Find an unused port
set port [exec sh -c "while true; do PORT=`expr '(' \$RANDOM % 1000 ')' + 9000`; ss -atn | fgrep \":\$PORT\" || break; done; echo \$PORT"]

setenv DEBUGINFOD_URLS ""
setenv DEBUGINFOD_TIMEOUT 30
setenv DEBUGINFOD_CACHE_PATH $cache

# test that gdb cannot find source without debuginfod
gdb_start
gdb_load $binfile
gdb_test_no_output "set substitute-path $outputdir /dev/null"
gdb_test "list" ".*No such file or directory.*"
gdb_exit

# strip symbols into separate file and move it so gdb cannot find it without debuginfod
if { [gdb_gnu_strip_debug $binfile ""] != 0 } {
    fail "$test (strip debuginfo)"
    return -1
}

set debugdir [file join [standard_output_file {}] "debug"]
set debuginfo [file join [standard_output_file {}] "fetch_src_and_symbols.debug"]

file mkdir $debugdir
file rename -force $debuginfo $debugdir

# test that gdb cannot find symbols without debuginfod
gdb_start
gdb_load $binfile
gdb_test "file" ".*No symbol file.*"
gdb_exit

# Write some assembly that just has a .gnu_debugaltlink section.
# Copied from testsuite/gdb.dwarf2/dwzbuildid.exp.
proc write_just_debugaltlink {filename dwzname buildid} {
    set asm_file [standard_output_file $filename]

    Dwarf::assemble $asm_file {
        upvar dwzname dwzname
        upvar buildid buildid

        gnu_debugaltlink $dwzname $buildid

        # Only the DWARF reader checks .gnu_debugaltlink, so make sure
        # there is a bit of DWARF in here.
        cu {} {
            compile_unit {{language @DW_LANG_C}} {
            }
        }
    }
}

# Write some DWARF that also sets the buildid.
# Copied from testsuite/gdb.dwarf2/dwzbuildid.exp.
proc write_dwarf_file {filename buildid {value 99}} {
    set asm_file [standard_output_file $filename]

    Dwarf::assemble $asm_file {
        declare_labels int_label int_label2

        upvar buildid buildid
        upvar value value

        build_id $buildid

        cu {} {
            compile_unit {{language @DW_LANG_C}} {
                int_label2: base_type {
                    {name int}
                    {byte_size 4 sdata}
                    {encoding @DW_ATE_signed}
                }

                constant {
                    {name the_int}
                    {type :$int_label2}
                    {const_value $value data1}
                }
            }
        }
    }
}

set buildid "01234567890abcdef0123456"

write_just_debugaltlink ${binfile}_has_altlink.S ${binfile}_dwz.o $buildid
write_dwarf_file ${binfile}_dwz.S $buildid

if {[gdb_compile ${binfile}_has_altlink.S ${binfile}_alt.o object nodebug] != ""} {
    fail "$test (compile main with altlink)"
    return -1
}

if {[gdb_compile ${binfile}_dwz.S ${binfile}_dwz.o object nodebug] != ""} {
    fail "$test (compile altlink)"
    return -1
}

file rename -force ${binfile}_dwz.o $debugdir

# Test that gdb cannot find dwz without debuginfod.
gdb_start
gdb_test "file ${binfile}_alt.o" ".*could not find '.gnu_debugaltlink'.*"
gdb_exit

set debuginfod_pid 0

# Kill the server if we abort early
proc sigint_handler {} {
    global debuginfod_pid

    if { $debuginfod_pid != 0 } {
        catch {exec kill -INT $debuginfod_pid}
    }

    exit
}

trap sigint_handler INT

# Start up debuginfod
set debuginfod_pid [exec debuginfod -d $db -p $port -F $debugdir 2>/dev/null &]

if { !$debuginfod_pid } {
    fail "$test (server init)"
    return -1
}

set metrics [list "ready 1" \
             "thread_work_total{role=\"traverse\"} 1" \
             "thread_work_pending{role=\"scan\"} 0" \
             "thread_busy{role=\"scan\"} 0"]

# Check server metrics to confirm init has completed.
foreach m $metrics {
  set timelim 20
  while { $timelim != 0 } {
    sleep 0.5
    catch {exec curl -s http://127.0.0.1:$port/metrics} got

    if { [regexp $m $got] } {
      break
    }

    incr timelim -1
  }

  if { $timelim == 0 } {
    fail "$test (server init timeout)"
    catch {exec kill -INT $debuginfod_pid}
    return -1
  }
}

# Point the client to the server
setenv DEBUGINFOD_URLS http://127.0.0.1:$port

# gdb should now find the symbol and source files
gdb_start
gdb_load $binfile
gdb_test_no_output "set substitute-path $outputdir /dev/null"
gdb_test "br main" "Breakpoint 1 at.*file.*"
gdb_test "l" ".*This program is distributed in the hope.*"
gdb_exit

# gdb should now find the debugaltlink file
gdb_start
gdb_test "file ${binfile}_alt.o" ".*Reading symbols from ${binfile}_alt.o\.\.\.\[\r\n\]"
gdb_exit

catch {exec kill -INT $debuginfod_pid}
