# Copyright 2013-2015 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# PR 11786 strip can change the in-memory size of the TLS segment.
# Generate a core file from the stripped version of the program,
# and then try to debug the core with a hacked unstripped version.
# The hack is to modify the program header in a way to simulate the
# strip bug.  The actual bug causes a change to the stripped binary,
# but we'd need to get that breakage into the core file, so instead
# we modify the header of the unstripped binary.

# This test only works on local GNU/Linux.
if { ![isnative]
     || [is_remote host]
     || ![istarget *-linux*]
     || ![istarget x86_64-*-* ]
     || ![is_lp64_target]} {
    continue
}

set readelf_program [gdb_find_readelf]

standard_testfile

if {[prepare_for_testing $testfile.exp $testfile $srcfile {debug additional_flags=-fpie "ldflags=-pie -Wl,-z,relro"}]} {
    return -1
}

set stripped_binfile ${binfile}.stripped
set gcorefile ${binfile}.gcore

set strip_program [transform strip]
remote_file host delete ${stripped_binfile}
if [run_on_host "strip" "$strip_program" "-g -o ${stripped_binfile} $binfile"] {
    return -1
}

# Workaround PR binutils/10802:
# Preserve the 'x' bit also for PIEs (Position Independent Executables).
set perm [file attributes ${binfile} -permissions]
file attributes ${stripped_binfile} -permissions $perm

clean_restart ${stripped_binfile}

# The binary is stripped of debug info, but not minsyms.
if ![runto break_here] {
    fail "Can't run to break_here"
    return -1
}

if {![gdb_gcore_cmd $gcorefile "save a corefile"]} {
    return -1
}

proc get_phdr_offset { binfile test } {
    global readelf_program
    set command "exec $readelf_program -h $binfile"
    verbose -log "command is $command"
    set result [catch $command output]
    verbose -log "result is $result"
    verbose -log "output is $output"
    if {$result != 0} {
	fail $test
	return
    }
    if ![regexp -line { *Start of program headers: +([0-9]+) } $output trash phdr_offset] {
	fail "$test (no phdr offset found)"
	return
    }
    verbose -log "phdr_offset is $phdr_offset"
    pass $test
    return $phdr_offset
}

proc get_tls_segment_number { binfile test } {
    global readelf_program
    set command "exec $readelf_program -Wl $binfile"
    verbose -log "command is $command"
    set result [catch $command output]
    verbose -log "result is $result"
    verbose -log "output is $output"
    if {$result != 0} {
	fail $test
	return
    }
    if ![regexp {\nProgram Headers:\n *Type [^\n]+\n(.*?)\n\n} $output trash phdr] {
	fail "$test (no Program Headers)"
	return -1
    }
    set phdr [regsub {\n[^\n]+Requesting program interpreter: [^\n]+\n} $phdr "\n"]
    verbose -log "phdr: $phdr"
    set seg_num 0
    set tls_seg_num -1
    foreach {trash name} [regexp -line -all -inline {^ *([A-Z_]+) .*$} $phdr] {
	verbose -log "line $seg_num: $name"
	if { $name == "TLS" } {
	    set tls_seg_num $seg_num
	}
	set seg_num [expr $seg_num + 1]
    }
    if { $tls_seg_num < 0 } {
	fail "$test (no TLS segment)"
	return -1
    }
    verbose -log "tls segment number is $tls_seg_num"
    pass $test
    return $tls_seg_num
}

# Hack the unstripped binary so that the program header comparison that
# gdb does will fail.
# The TLS segment will have a non-zero memory size, we just have to zero it.
# On amd64-linux, each ELF program header is 56 bytes and the offset of the
# p_memsz field of Elf64_External_Phdr is 40.

set phdr_offset [get_phdr_offset $binfile "get phdr offset"]
set tls_segment_number [get_tls_segment_number $binfile "get tls seg number"]

set f [open $binfile "r+"]
set offset [expr $phdr_offset + $tls_segment_number * 56 + 40]
verbose -log "Setting byte @$offset to zero."
seek $f $offset start
puts -nonewline $f "\0"
close $f

# Now restart gdb with the unstripped binary and load the corefile.

clean_restart ${binfile}

gdb_test "core ${gcorefile}" \
    "Core was generated by .*" "re-load generated corefile"

# Put $pc in gdb.log for debug purposes for comparison with stripped case.
gdb_test "x/i \$pc" "break_here.*"

gdb_test "frame" "#0 \[^\r\n\]* break_here .*" "unstripped + core ok"
