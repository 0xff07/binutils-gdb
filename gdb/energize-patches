# Apply these patches to GDB to produce an Energize GDB.
# To apply these patches, first cd to gdb-XX/gdb, run "patch -p0 <thisfile",
# and then Sanitize.

===================================================================
*** 2.72	1992/09/27 06:48:41
--- .Sanitize	1992/09/28 21:34:08
***************
*** 74,79 ****
--- 74,82 ----
  doc
  dwarfread.c
  elfread.c
+ energize
+ energize.c
+ energize.h
  environ.c
  environ.h
  eval.c
===================================================================
*** 1.187	1992/09/26 08:06:30
--- Makefile.in	1992/09/28 21:34:08
***************
*** 123,128 ****
--- 123,135 ----
  READLINE_DEP = $$(READLINE_DIR)
  RL_LIB = ./../readline${subdir}/libreadline.a
  
+ # Energize libraries.  Works slightly differently than other libraries
+ # because it is a gdb subdir and we try to build the energize library
+ # if it doesn't exist, unlike readline, bfd, mmalloc, etc.  Note
+ # that SDIR and BDIR will be different if we configured with -srcdir.
+ ENERGIZE_DIR = energize
+ ENERGIZE_LIB = ${ENERGIZE_DIR}/libconn.a
+ 
  # All the includes used for CFLAGS and for lint.
  # -I. for config files.
  # -I${srcdir} possibly for regex.h also.
***************
*** 157,166 ****
  # Libraries and corresponding dependencies for compiling gdb.
  # {X,T}M_CLIBS, defined in *config files, have host- and target-dependent libs.
  # TERMCAP comes after readline, since readline depends on it.
! CLIBS = ${BFD_LIB} ${RL_LIB} ${TERMCAP} ${OPCODES} ${MMALLOC_LIB} ${LIBIBERTY} \
! 	${XM_CLIBS} ${TM_CLIBS} ${NAT_CLIBS}
! CDEPS = ${XM_CDEPS} ${TM_CDEPS} ${NAT_CDEPS} \
! 	${BFD_LIB} ${RL_LIB}            ${OPCODES} ${MMALLOC_LIB} ${LIBIBERTY}
  
  ADD_FILES = ${REGEX} ${ALLOCA}  ${XM_ADD_FILES} ${TM_ADD_FILES} ${NAT_ADD_FILES}
  ADD_DEPS = ${REGEX1} ${ALLOCA1} ${XM_ADD_FILES} ${TM_ADD_FILES} ${NAT_ADD_FILES}
--- 164,173 ----
  # Libraries and corresponding dependencies for compiling gdb.
  # {X,T}M_CLIBS, defined in *config files, have host- and target-dependent libs.
  # TERMCAP comes after readline, since readline depends on it.
! CLIBS = ${BFD_LIB} ${RL_LIB} ${TERMCAP} ${OPCODES} ${MMALLOC_LIB} \
! 	${LIBIBERTY} ${XM_CLIBS} ${TM_CLIBS} ${NAT_CLIBS} ${ENERGIZE_LIB}
! CDEPS = ${XM_CDEPS} ${TM_CDEPS} ${NAT_CDEPS} ${BFD_LIB} ${RL_LIB} ${OPCODES} \
! 	${MMALLOC_LIB} ${LIBIBERTY} ${ENERGIZE_LIB}
  
  ADD_FILES = ${REGEX} ${ALLOCA}  ${XM_ADD_FILES} ${TM_ADD_FILES} ${NAT_ADD_FILES}
  ADD_DEPS = ${REGEX1} ${ALLOCA1} ${XM_ADD_FILES} ${TM_ADD_FILES} ${NAT_ADD_FILES}
***************
*** 200,206 ****
  	 mem-break.c target.c \
  	 dbxread.c coffread.c elfread.c dwarfread.c xcoffread.c stabsread.c \
  	 language.c parse.c buildsym.c objfiles.c \
! 	 minsyms.c mipsread.c maint.c
  
  # Source files in subdirectories (which will be handled separately by
  #  'make gdb.tar.Z').
--- 207,213 ----
  	 mem-break.c target.c \
  	 dbxread.c coffread.c elfread.c dwarfread.c xcoffread.c stabsread.c \
  	 language.c parse.c buildsym.c objfiles.c \
! 	 minsyms.c mipsread.c maint.c energize.c
  
  # Source files in subdirectories (which will be handled separately by
  #  'make gdb.tar.Z').
***************
*** 289,295 ****
      command.o utils.o expprint.o environ.o version.o gdbtypes.o \
      copying.o $(DEPFILES) mem-break.o target.o \
      putenv.o parse.o language.o $(YYOBJ) \
!     buildsym.o objfiles.o minsyms.o maint.o demangle.o \
      dbxread.o coffread.o elfread.o dwarfread.o xcoffread.o mipsread.o \
      stabsread.o core.o
  
--- 296,302 ----
      command.o utils.o expprint.o environ.o version.o gdbtypes.o \
      copying.o $(DEPFILES) mem-break.o target.o \
      putenv.o parse.o language.o $(YYOBJ) \
!     buildsym.o objfiles.o minsyms.o maint.o demangle.o energize.o \
      dbxread.o coffread.o elfread.o dwarfread.o xcoffread.o mipsread.o \
      stabsread.o core.o
  
***************
*** 303,309 ****
  
  NTSSTART = kdb-start.o
  
! SUBDIRS = doc
  
  # For now, shortcut the "configure GDB for fewer languages" stuff.
  YYFILES = c-exp.tab.c m2-exp.tab.c
--- 310,316 ----
  
  NTSSTART = kdb-start.o
  
! SUBDIRS = doc ${ENERGIZE_DIR}
  
  # For now, shortcut the "configure GDB for fewer languages" stuff.
  YYFILES = c-exp.tab.c m2-exp.tab.c
***************
*** 365,370 ****
--- 372,391 ----
  	#load `echo " "$(DEPFILES) | sed -e 's/\.o/.c/g' -e 's, , ../,g'`
  	echo "Load .c corresponding to:" $(DEPFILES)
  
+ ${ENERGIZE_LIB} :
+ 	@(cd ${ENERGIZE_DIR}; \
+ 		$(MAKE) \
+ 			"against=$(against)" \
+ 			"AR=$(AR)" \
+ 			"AR_FLAGS=$(AR_FLAGS)" \
+ 			"CC=$(CC)" \
+ 			"CFLAGS=$(CFLAGS)" \
+ 			"RANLIB=$(RANLIB)" \
+ 			"MAKEINFO=$(MAKEINFO)" \
+ 			"INSTALL=$(INSTALL)" \
+ 			"INSTALL_PROGRAM=$(INSTALL_PROGRAM)" \
+ 			"INSTALL_DATA=$(INSTALL_DATA)" \
+ 			"BISON=$(BISON)")
  
  # This is useful when debugging GDB, because some Unix's don't let you run GDB
  # on itself without copying the executable.  So "make gdb1" will make
===================================================================
*** 1.48	1992/09/29 05:07:04
--- breakpoint.c	1992/09/28 21:34:09
***************
*** 273,278 ****
--- 273,279 ----
  	    b->cond_string = NULL;
  	    if (from_tty)
  	      printf_filtered ("Breakpoint %d now unconditional.\n", bnum);
+ 	    energize_condition_breakpoint(b);
  	  }
  	else
  	  {
***************
*** 281,286 ****
--- 282,288 ----
  	       typed in or the decompiled expression.  */
  	    b->cond_string = savestring (arg, strlen (arg));
  	    b->cond = parse_exp_1 (&arg, block_for_pc (b->address), 0);
+ 	    energize_condition_breakpoint(b);
  	    if (*arg)
  	      error ("Junk at end of expression");
  	  }
***************
*** 322,327 ****
--- 324,330 ----
  	l = read_command_lines ();
  	free_command_lines (&b->commands);
  	b->commands = l;
+ 	energize_commands_breakpoint(b);
  	return;
        }
    error ("No breakpoint number %d.", bnum);
***************
*** 445,452 ****
  		b->enable = disabled;
  		if (!disabled_breaks)
  		  {
! 		    fprintf (stderr,
! 			 "Cannot insert breakpoint %d:\n", b->number);
  		    printf_filtered ("Disabling shared library breakpoints:\n");
  		  }
  		disabled_breaks = 1;
--- 448,455 ----
  		b->enable = disabled;
  		if (!disabled_breaks)
  		  {
! 		    fprintf_filtered (stderr, "Cannot insert breakpoint %d:\n",
! 				      b->number);
  		    printf_filtered ("Disabling shared library breakpoints:\n");
  		  }
  		disabled_breaks = 1;
***************
*** 455,464 ****
  	    else
  #endif
  	      {
! 		fprintf (stderr, "Cannot insert breakpoint %d:\n", b->number);
  #ifdef ONE_PROCESS_WRITETEXT
! 		fprintf (stderr,
! 		  "The same program may be running in another process.\n");
  #endif
  		memory_error (val, b->address);	/* which bombs us out */
  	      }
--- 458,468 ----
  	    else
  #endif
  	      {
! 		fprintf_filtered (stderr, "Cannot insert breakpoint %d:\n",
! 				  b->number);
  #ifdef ONE_PROCESS_WRITETEXT
! 		fprintf_filtered (stderr,
! 				  "The same program may be running in another process.\n");
  #endif
  		memory_error (val, b->address);	/* which bombs us out */
  	      }
***************
*** 478,484 ****
    int val;
  
  #ifdef BREAKPOINT_DEBUG
!   printf ("Removing breakpoints.\n");
  #endif /* BREAKPOINT_DEBUG */
  
    ALL_BREAKPOINTS (b)
--- 482,488 ----
    int val;
  
  #ifdef BREAKPOINT_DEBUG
!   printf_filtered ("Removing breakpoints.\n");
  #endif /* BREAKPOINT_DEBUG */
  
    ALL_BREAKPOINTS (b)
***************
*** 489,500 ****
  	  return val;
  	b->inserted = 0;
  #ifdef BREAKPOINT_DEBUG
! 	printf ("Removed breakpoint at %s",
! 		local_hex_string(b->address));
! 	printf (", shadow %s",
! 		local_hex_string(b->shadow_contents[0]));
! 	printf (", %s.\n",
! 		local_hex_string(b->shadow_contents[1]));
  #endif /* BREAKPOINT_DEBUG */
        }
  
--- 493,504 ----
  	  return val;
  	b->inserted = 0;
  #ifdef BREAKPOINT_DEBUG
! 	printf_filtered ("Removed breakpoint at %s",
! 			 local_hex_string(b->address));
! 	printf_filtered (", shadow %s",
! 			 local_hex_string(b->shadow_contents[0]));
! 	printf_filtered (", %s.\n",
! 			 local_hex_string(b->shadow_contents[1]));
  #endif /* BREAKPOINT_DEBUG */
        }
  
***************
*** 922,927 ****
--- 926,932 ----
  	    {
  	      b->ignore_count--;
  	      this_bp_stop = 0;
+ 	      energize_ignore_breakpoint(b);
  	    }
  	  else
  	    {
***************
*** 1141,1157 ****
        others++;
    if (others > 0)
      {
!       printf ("Note: breakpoint%s ", (others > 1) ? "s" : "");
        ALL_BREAKPOINTS (b)
  	if (b->address == pc)
  	  {
  	    others--;
! 	    printf ("%d%s%s ",
! 		    b->number,
! 		    (b->enable == disabled) ? " (disabled)" : "",
! 		    (others > 1) ? "," : ((others == 1) ? " and" : ""));
  	  }
!       printf ("also set at pc %s.\n", local_hex_string(pc));
      }
  }
  
--- 1146,1163 ----
        others++;
    if (others > 0)
      {
!       printf_filtered ("Note: breakpoint%s ", (others > 1) ? "s" : "");
        ALL_BREAKPOINTS (b)
  	if (b->address == pc)
  	  {
  	    others--;
! 	    printf_filtered ("%d%s%s ",
! 			     b->number,
! 			     (b->enable == disabled) ? " (disabled)" : "",
! 			     (others > 1) ? "," :
! 			       ((others == 1) ? " and" : ""));
  	  }
!       printf_filtered ("also set at pc %s.\n", local_hex_string(pc));
      }
  }
  
***************
*** 1373,1378 ****
--- 1379,1386 ----
  mention (b)
       struct breakpoint *b;
  {
+   energize_create_breakpoint(b);
+ 
    switch (b->type)
      {
      case bp_watchpoint:
***************
*** 1550,1557 ****
  
    if (sals.nelts > 1)
      {
!       printf ("Multiple breakpoints were set.\n");
!       printf ("Use the \"delete\" command to delete unwanted breakpoints.\n");
      }
    free ((PTR)sals.sals);
  }
--- 1558,1565 ----
  
    if (sals.nelts > 1)
      {
!       printf_filtered ("Multiple breakpoints were set.\n");
!       printf_filtered ("Use the \"delete\" command to delete unwanted breakpoints.\n");
      }
    free ((PTR)sals.sals);
  }
***************
*** 1769,1775 ****
  	  goto win;
  	}
  #endif
!       printf ("No catch clause for exception %s.\n", p);
  #if 0
      win:
  #endif
--- 1777,1783 ----
  	  goto win;
  	}
  #endif
!       printf_filtered ("No catch clause for exception %s.\n", p);
  #if 0
      win:
  #endif
***************
*** 1970,1985 ****
        b->enable = enabled;
        b->disposition = tempflag ? delete : donttouch;
  
!       printf ("Breakpoint %d at %s", b->number, local_hex_string(b->address));
        if (b->symtab)
! 	printf (": file %s, line %d.", b->symtab->filename, b->line_number);
!       printf ("\n");
      }
  
    if (sals.nelts > 1)
      {
!       printf ("Multiple breakpoints were set.\n");
!       printf ("Use the \"delete\" command to delete unwanted breakpoints.\n");
      }
    free ((PTR)sals.sals);
  }
--- 1978,1995 ----
        b->enable = enabled;
        b->disposition = tempflag ? delete : donttouch;
  
!       printf_filtered ("Breakpoint %d at %s", b->number,
! 		       local_hex_string(b->address));
        if (b->symtab)
! 	printf_filtered (": file %s, line %d.",
! 			 b->symtab->filename, b->line_number);
!       printf_filtered ("\n");
      }
  
    if (sals.nelts > 1)
      {
!       printf_filtered ("Multiple breakpoints were set.\n");
!       printf_filtered ("Use the \"delete\" command to delete unwanted breakpoints.\n");
      }
    free ((PTR)sals.sals);
  }
***************
*** 2086,2095 ****
  	}
  
        if (found->next) from_tty = 1; /* Always report if deleted more than one */
!       if (from_tty) printf ("Deleted breakpoint%s ", found->next ? "s" : "");
        while (found)
  	{
! 	  if (from_tty) printf ("%d ", found->number);
  	  b1 = found->next;
  	  delete_breakpoint (found);
  	  found = b1;
--- 2096,2106 ----
  	}
  
        if (found->next) from_tty = 1; /* Always report if deleted more than one */
!       if (from_tty) printf_filtered ("Deleted breakpoint%s ",
! 				     found->next ? "s" : "");
        while (found)
  	{
! 	  if (from_tty) printf_filtered ("%d ", found->number);
  	  b1 = found->next;
  	  delete_breakpoint (found);
  	  found = b1;
***************
*** 2120,2125 ****
--- 2131,2138 ----
    register struct breakpoint *b;
    register bpstat bs;
  
+   energize_delete_breakpoint(bpt);
+ 
    if (bpt->inserted)
        target_remove_breakpoint(bpt->address, bpt->shadow_contents);
  
***************
*** 2144,2150 ****
      free ((PTR)bpt->addr_string);
  
    if (xgdb_verbose && bpt->type == bp_breakpoint)
!     printf ("breakpoint #%d deleted\n", bpt->number);
  
    /* Be sure no bpstat's are pointing at it after it's been freed.  */
    /* FIXME, how can we find all bpstat's?  We just check stop_bpstat for now. */
--- 2157,2163 ----
      free ((PTR)bpt->addr_string);
  
    if (xgdb_verbose && bpt->type == bp_breakpoint)
!     printf_filtered ("breakpoint #%d deleted\n", bpt->number);
  
    /* Be sure no bpstat's are pointing at it after it's been freed.  */
    /* FIXME, how can we find all bpstat's?  We just check stop_bpstat for now. */
***************
*** 2264,2270 ****
  
    ALL_BREAKPOINTS_SAFE (b, temp)
      {
!       sprintf (message, message1, b->number);	/* Format possible error msg */
        catch_errors (breakpoint_re_set_one, (char *) b, message);
      }
  
--- 2277,2283 ----
  
    ALL_BREAKPOINTS_SAFE (b, temp)
      {
!       printf_filtered (message, message1, b->number);	/* Format possible error msg */
        catch_errors (breakpoint_re_set_one, (char *) b, message);
      }
  
***************
*** 2298,2303 ****
--- 2311,2317 ----
      if (b->number == bptnum)
        {
  	b->ignore_count = count;
+ 	energize_ignore_breakpoint(b);
  	if (!from_tty)
  	  return;
  	else if (count == 0)
***************
*** 2322,2328 ****
    struct breakpoint *b;
  
    ALL_BREAKPOINTS (b)
!     b->ignore_count = 0;
  }
  
  /* Command to set ignore-count of breakpoint N to COUNT.  */
--- 2336,2345 ----
    struct breakpoint *b;
  
    ALL_BREAKPOINTS (b)
!     {
!       b->ignore_count = 0;
!       energize_ignore_breakpoint(b);
!     }
  }
  
  /* Command to set ignore-count of breakpoint N to COUNT.  */
***************
*** 2377,2383 ****
  	    function (b);
  	    goto win;
  	  }
!       printf ("No breakpoint number %d.\n", num);
      win:
        p = p1;
      }
--- 2394,2400 ----
  	    function (b);
  	    goto win;
  	  }
!       printf_filtered ("No breakpoint number %d.\n", num);
      win:
        p = p1;
      }
***************
*** 2389,2396 ****
  {
    bpt->enable = enabled;
  
    if (xgdb_verbose && bpt->type == bp_breakpoint)
!     printf ("breakpoint #%d enabled\n", bpt->number);
  
    check_duplicates (bpt->address);
    if (bpt->type == bp_watchpoint)
--- 2406,2415 ----
  {
    bpt->enable = enabled;
  
+   energize_enable_breakpoint(bpt);
+ 
    if (xgdb_verbose && bpt->type == bp_breakpoint)
!     printf_filtered ("breakpoint #%d enabled\n", bpt->number);
  
    check_duplicates (bpt->address);
    if (bpt->type == bp_watchpoint)
***************
*** 2436,2441 ****
--- 2455,2462 ----
  disable_breakpoint (bpt)
       struct breakpoint *bpt;
  {
+   energize_disable_breakpoint(bpt);
+ 
    bpt->enable = disabled;
  
    if (xgdb_verbose && bpt->type == bp_breakpoint)
===================================================================
*** 1.18	1992/07/10 17:22:30
--- command.c	1992/09/28 21:34:09
***************
*** 1093,1098 ****
--- 1093,1100 ----
    else
      error ("gdb internal error: bad cmd_type in do_setshow_command");
    (*c->function.sfunc) (NULL, from_tty, c);
+   if (energize)
+     print_prompt();
  }
  
  /* Show all the settings in a list of show commands.  */
***************
*** 1148,1154 ****
      }
  
    if (pid != -1)
!     while ((rc = wait (&status)) != pid && rc != -1)
        ;
    else
      error ("Fork failed");
--- 1150,1156 ----
      }
  
    if (pid != -1)
!     while ((rc = energize_shell_wait (&status)) != pid && rc != -1)
        ;
    else
      error ("Fork failed");
===================================================================
*** 1.67	1992/09/21 20:01:00
--- configure.in	1992/09/28 21:34:10
***************
*** 1,4 ****
! configdirs="doc"
  srcname="GDB"
  srctrigger=main.c
  
--- 1,4 ----
! configdirs="energize doc"
  srcname="GDB"
  srctrigger=main.c
  
===================================================================
*** 1.48	1992/09/15 08:55:59
--- defs.h	1992/09/28 21:34:10
***************
*** 811,814 ****
--- 811,816 ----
  #define MAINTENANCE_CMDS 1
  #endif
  
+ #include "energize.h"
+ 
  #endif /* !defined (DEFS_H) */
===================================================================
*** 2.5	1992/09/03 16:26:03
--- demangle.c	1992/09/28 21:34:10
***************
*** 37,43 ****
     the appropriate target configuration file. */
  
  #ifndef DEFAULT_DEMANGLING_STYLE
! # define DEFAULT_DEMANGLING_STYLE AUTO_DEMANGLING_STYLE_STRING
  #endif
  
  /* String name for the current demangling style.  Set by the "set demangling"
--- 37,43 ----
     the appropriate target configuration file. */
  
  #ifndef DEFAULT_DEMANGLING_STYLE
! # define DEFAULT_DEMANGLING_STYLE LUCID_DEMANGLING_STYLE_STRING
  #endif
  
  /* String name for the current demangling style.  Set by the "set demangling"
===================================================================
*** 1.34	1992/09/26 05:20:04
--- infcmd.c	1992/09/28 21:34:11
***************
*** 242,247 ****
--- 242,248 ----
  
    target_create_inferior (exec_file, inferior_args,
  			  environ_vector (inferior_environ));
+   energize_new_process();
  }
  
  static void
===================================================================
*** 1.29	1992/09/25 19:19:00
--- inflow.c	1992/09/28 21:34:11
***************
*** 87,93 ****
  static short pgrp_inferior;
  static short pgrp_ours;
  # else /* not def SHORT_PGRP */
! static int pgrp_inferior;
  static int pgrp_ours;
  # endif /* not def SHORT_PGRP */
  #else /* not def TIOCGPGRP */
--- 87,93 ----
  static short pgrp_inferior;
  static short pgrp_ours;
  # else /* not def SHORT_PGRP */
! int pgrp_inferior;
  static int pgrp_ours;
  # endif /* not def SHORT_PGRP */
  #else /* not def TIOCGPGRP */
===================================================================
*** 1.59	1992/09/26 01:49:01
--- infrun.c	1992/09/28 21:34:12
***************
*** 519,525 ****
        flush_cached_frames ();
        registers_changed ();
  
!       target_wait (&w);
  
  #ifdef SIGTRAP_STOP_AFTER_LOAD
  
--- 519,525 ----
        flush_cached_frames ();
        registers_changed ();
  
!       energize_wait (&w);
  
  #ifdef SIGTRAP_STOP_AFTER_LOAD
  
===================================================================
*** 1.17	1992/09/26 09:06:10
--- inftarg.c	1992/09/28 21:34:12
***************
*** 123,128 ****
--- 123,129 ----
  
    attach (pid);
    inferior_pid = pid;
+   energize_new_process();
    push_target (&child_ops);
  #endif  /* ATTACH_DETACH */
  }
===================================================================
*** 1.57	1992/09/29 05:07:14
--- main.c	1992/09/28 21:34:13
***************
*** 441,446 ****
--- 441,447 ----
    char *corearg = NULL;
    char *cdarg = NULL;
    char *ttyarg = NULL;
+   char *energize_id = NULL;
  
    /* Pointers to all arguments of +command option.  */
    char **cmdarg;
***************
*** 539,544 ****
--- 540,546 ----
  	{"tty", required_argument, 0, 't'},
  	{"baud", required_argument, 0, 'b'},
  	{"b", required_argument, 0, 'b'},
+ 	{"context", required_argument, 0, 12},
  /* Allow machine descriptions to add more options... */
  #ifdef ADDITIONAL_OPTIONS
  	ADDITIONAL_OPTIONS
***************
*** 571,576 ****
--- 573,581 ----
  	  case 11:
  	    cdarg = optarg;
  	    break;
+ 	  case 12:
+ 	    energize_id = optarg;
+ 	    break;
  	  case 's':
  	    symarg = optarg;
  	    break;
***************
*** 611,617 ****
  	  ADDITIONAL_OPTION_CASES
  #endif
  	  case '?':
! 	    fprintf (stderr,
  		     "Use `%s +help' for a complete list of options.\n",
  		     argv[0]);
  	    exit (1);
--- 616,622 ----
  	  ADDITIONAL_OPTION_CASES
  #endif
  	  case '?':
! 	    fprintf_filtered (stderr,
  		     "Use `%s +help' for a complete list of options.\n",
  		     argv[0]);
  	    exit (1);
***************
*** 668,674 ****
  	  corearg = argv[optind];
  	  break;
  	case 3:
! 	  fprintf (stderr,
  		   "Excess command line arguments ignored. (%s%s)\n",
  		   argv[optind], (optind == argc - 1) ? "" : " ...");
  	  break;
--- 673,679 ----
  	  corearg = argv[optind];
  	  break;
  	case 3:
! 	  fprintf_filtered (stderr,
  		   "Excess command line arguments ignored. (%s%s)\n",
  		   argv[optind], (optind == argc - 1) ? "" : " ...");
  	  break;
***************
*** 679,684 ****
--- 684,692 ----
  
    /* Run the init function of each source file */
  
+   /* Must call this first to setup tty */
+   energize_initialize (energize_id, execarg);
+ 
    initialize_cmd_lists ();	/* This needs to be done first */
    initialize_all_files ();
    initialize_main ();		/* But that omits this file!  Do it now */
***************
*** 853,859 ****
        if (!setjmp (to_top_level))
  	{
  	  do_cleanups (ALL_CLEANUPS);		/* Do complete cleanup */
! 	  command_loop ();
            quit_command ((char *)0, instream == stdin);
  	}
      }
--- 861,870 ----
        if (!setjmp (to_top_level))
  	{
  	  do_cleanups (ALL_CLEANUPS);		/* Do complete cleanup */
! 	  if (energize)
! 	    energize_main_loop();
! 	  else
! 	    command_loop ();
            quit_command ((char *)0, instream == stdin);
  	}
      }
***************
*** 915,921 ****
        else if (c->function.cfunc == NO_FUNCTION)
  	error ("That is not a command, just a help topic.");
        else
! 	(*c->function.cfunc) (arg, from_tty & caution);
     }
  
    /* Tell the user if the language has changed (except first time).  */
--- 926,932 ----
        else if (c->function.cfunc == NO_FUNCTION)
  	error ("That is not a command, just a help topic.");
        else
! 	energize_call_command (c, arg, from_tty & caution);
     }
  
    /* Tell the user if the language has changed (except first time).  */
***************
*** 1317,1323 ****
  #else
    signal (STOP_SIGNAL, stop_sig);
  #endif
!   printf ("%s", prompt);
    fflush (stdout);
  
    /* Forget about any previous command -- null line now will do nothing.  */
--- 1328,1334 ----
  #else
    signal (STOP_SIGNAL, stop_sig);
  #endif
!   printf_filtered ("%s", prompt);
    fflush (stdout);
  
    /* Forget about any previous command -- null line now will do nothing.  */
***************
*** 1463,1469 ****
        if (expanded)
  	{
  	  /* Print the changes.  */
! 	  printf ("%s\n", history_value);
  
  	  /* If there was an error, call this function again.  */
  	  if (expanded < 0)
--- 1474,1480 ----
        if (expanded)
  	{
  	  /* Print the changes.  */
! 	  printf_filtered ("%s\n", history_value);
  
  	  /* If there was an error, call this function again.  */
  	  if (expanded < 0)
***************
*** 1570,1576 ****
    while (1)
      {
        dont_repeat ();
!       p = command_line_input ((char *) NULL, instream == stdin);
        if (p == NULL)
  	/* Treat end of file like "end".  */
  	break;
--- 1581,1587 ----
    while (1)
      {
        dont_repeat ();
!       p = energize_command_line_input ((char *) NULL, instream == stdin);
        if (p == NULL)
  	/* Treat end of file like "end".  */
  	break;
***************
*** 1661,1667 ****
       char *arg;
       int from_tty;
  {
!   printf ("\"info\" must be followed by the name of an info command.\n");
    help_list (infolist, "info ", -1, stdout);
  }
  
--- 1672,1678 ----
       char *arg;
       int from_tty;
  {
!   printf_filtered ("\"info\" must be followed by the name of an info command.\n");
    help_list (infolist, "info ", -1, stdout);
  }
  
***************
*** 1777,1783 ****
  
    if (from_tty)
      {
!       printf ("Type commands for definition of \"%s\".\n\
  End with a line saying just \"end\".\n", comname);
        fflush (stdout);
      }
--- 1788,1794 ----
  
    if (from_tty)
      {
!       printf_filtered ("Type commands for definition of \"%s\".\n\
  End with a line saying just \"end\".\n", comname);
        fflush (stdout);
      }
***************
*** 1810,1816 ****
      error ("Command \"%s\" is built-in.", comname);
  
    if (from_tty)
!     printf ("Type documentation for \"%s\".\n\
  End with a line saying just \"end\".\n", comname);
  
    doclines = read_command_lines ();
--- 1821,1827 ----
      error ("Command \"%s\" is built-in.", comname);
  
    if (from_tty)
!     printf_filtered ("Type documentation for \"%s\".\n\
  End with a line saying just \"end\".\n", comname);
  
    doclines = read_command_lines ();
***************
*** 1841,1847 ****
  static void
  print_gnu_advertisement()
  {
!     printf ("\
  GDB is free software and you are welcome to distribute copies of it\n\
   under certain conditions; type \"show copying\" to see the conditions.\n\
  There is absolutely no warranty for GDB; type \"show warranty\" for details.\n\
--- 1852,1858 ----
  static void
  print_gnu_advertisement()
  {
!     printf_filtered ("\
  GDB is free software and you are welcome to distribute copies of it\n\
   under certain conditions; type \"show copying\" to see the conditions.\n\
  There is absolutely no warranty for GDB; type \"show warranty\" for details.\n\
***************
*** 1874,1880 ****
  void
  print_prompt ()
  {
!   printf ("%s", prompt);
    fflush (stdout);
  }
  
--- 1885,1891 ----
  void
  print_prompt ()
  {
!   printf_filtered ("%s", prompt);
    fflush (stdout);
  }
  
***************
*** 1920,1929 ****
    getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
  
    if (strcmp (gdb_dirbuf, current_directory))
!     printf ("Working directory %s\n (canonically %s).\n",
  	    current_directory, gdb_dirbuf);
    else
!     printf ("Working directory %s.\n", current_directory);
  }
  
  static void
--- 1931,1940 ----
    getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
  
    if (strcmp (gdb_dirbuf, current_directory))
!     printf_filtered ("Working directory %s\n (canonically %s).\n",
  	    current_directory, gdb_dirbuf);
    else
!     printf_filtered ("Working directory %s.\n", current_directory);
  }
  
  static void
***************
*** 2160,2166 ****
       char *args;
       int from_tty;
  {
!   printf ("\"set history\" must be followed by the name of a history subcommand.\n");
    help_list (sethistlist, "set history ", -1, stdout);
  }
  
--- 2171,2177 ----
       char *args;
       int from_tty;
  {
!   printf_filtered ("\"set history\" must be followed by the name of a history subcommand.\n");
    help_list (sethistlist, "set history ", -1, stdout);
  }
  
===================================================================
*** 1.33	1992/09/29 05:07:19
--- printcmd.c	1992/09/28 21:34:13
***************
*** 778,792 ****
      {
        int histindex = record_latest_value (val);
  
        if (inspect)
! 	printf ("\031(gdb-makebuffer \"%s\"  %d '(\"", exp, histindex);
        else
  	if (histindex >= 0) printf_filtered ("$%d = ", histindex);
  
        print_formatted (val, format, fmt.size);
        printf_filtered ("\n");
        if (inspect)
! 	printf("\") )\030");
      }
  
    if (cleanup)
--- 778,802 ----
      {
        int histindex = record_latest_value (val);
  
+       if (energize)
+ 	{
+ 	  char buf[20];
+ 
+ 	  sprintf(buf, "$%d", histindex);
+ 	  energize_start_variable_annotation(buf, NULL, VALUE_TYPE(val),
+ 					     VALUE_ADDRESS(val), "");
+ 	}
+ 
        if (inspect)
! 	printf_filtered ("\031(gdb-makebuffer \"%s\"  %d '(\"", exp, histindex);
        else
  	if (histindex >= 0) printf_filtered ("$%d = ", histindex);
  
        print_formatted (val, format, fmt.size);
+       energize_end_variable_annotation();
        printf_filtered ("\n");
        if (inspect)
! 	printf_filtered("\") )\030");
      }
  
    if (cleanup)
***************
*** 890,896 ****
      {
        if (is_a_field_of_this)
  	{
! 	  printf ("Symbol \"%s\" is a field of the local class variable `this'\n", exp);
  	  return;
  	}
  
--- 900,906 ----
      {
        if (is_a_field_of_this)
  	{
! 	  printf_filtered ("Symbol \"%s\" is a field of the local class variable `this'\n", exp);
  	  return;
  	}
  
***************
*** 897,903 ****
        msymbol = lookup_minimal_symbol (exp, (struct objfile *) NULL);
  
        if (msymbol != NULL)
! 	printf ("Symbol \"%s\" is at %s in a file compiled without debugging.\n",
  		exp, local_hex_string(msymbol -> address));
        else
  	error ("No symbol \"%s\" in current context.", exp);
--- 907,913 ----
        msymbol = lookup_minimal_symbol (exp, (struct objfile *) NULL);
  
        if (msymbol != NULL)
! 	printf_filtered ("Symbol \"%s\" is at %s in a file compiled without debugging.\n",
  		exp, local_hex_string(msymbol -> address));
        else
  	error ("No symbol \"%s\" in current context.", exp);
***************
*** 904,910 ****
        return;
      }
  
!   printf ("Symbol \"%s\" is ", SYMBOL_NAME (sym));
    val = SYMBOL_VALUE (sym);
    basereg = SYMBOL_BASEREG (sym);
  
--- 914,920 ----
        return;
      }
  
!   printf_filtered ("Symbol \"%s\" is ", SYMBOL_NAME (sym));
    val = SYMBOL_VALUE (sym);
    basereg = SYMBOL_BASEREG (sym);
  
***************
*** 912,945 ****
      {
      case LOC_CONST:
      case LOC_CONST_BYTES:
!       printf ("constant");
        break;
  
      case LOC_LABEL:
!       printf ("a label at address %s", local_hex_string(SYMBOL_VALUE_ADDRESS (sym)));
        break;
  
      case LOC_REGISTER:
!       printf ("a variable in register %s", reg_names[val]);
        break;
  
      case LOC_STATIC:
!       printf ("static storage at address %s", local_hex_string(SYMBOL_VALUE_ADDRESS (sym)));
        break;
  
      case LOC_REGPARM:
!       printf ("an argument in register %s", reg_names[val]);
        break;
        
      case LOC_ARG:
        if (SYMBOL_BASEREG_VALID (sym))
  	{
! 	  printf ("an argument at offset %ld from register %s",
  		  val, reg_names[basereg]);
  	}
        else
  	{
! 	  printf ("an argument at offset %ld", val);
  	}
        break;
  
--- 922,955 ----
      {
      case LOC_CONST:
      case LOC_CONST_BYTES:
!       printf_filtered ("constant");
        break;
  
      case LOC_LABEL:
!       printf_filtered ("a label at address %s", local_hex_string(SYMBOL_VALUE_ADDRESS (sym)));
        break;
  
      case LOC_REGISTER:
!       printf_filtered ("a variable in register %s", reg_names[val]);
        break;
  
      case LOC_STATIC:
!       printf_filtered ("static storage at address %s", local_hex_string(SYMBOL_VALUE_ADDRESS (sym)));
        break;
  
      case LOC_REGPARM:
!       printf_filtered ("an argument in register %s", reg_names[val]);
        break;
        
      case LOC_ARG:
        if (SYMBOL_BASEREG_VALID (sym))
  	{
! 	  printf_filtered ("an argument at offset %ld from register %s",
  		  val, reg_names[basereg]);
  	}
        else
  	{
! 	  printf_filtered ("an argument at offset %ld", val);
  	}
        break;
  
***************
*** 946,957 ****
      case LOC_LOCAL_ARG:
        if (SYMBOL_BASEREG_VALID (sym))
  	{
! 	  printf ("an argument at offset %ld from register %s",
  		  val, reg_names[basereg]);
  	}
        else
  	{
! 	  printf ("an argument at frame offset %ld", val);
  	}
        break;
  
--- 956,967 ----
      case LOC_LOCAL_ARG:
        if (SYMBOL_BASEREG_VALID (sym))
  	{
! 	  printf_filtered ("an argument at offset %ld from register %s",
  		  val, reg_names[basereg]);
  	}
        else
  	{
! 	  printf_filtered ("an argument at frame offset %ld", val);
  	}
        break;
  
***************
*** 958,990 ****
      case LOC_LOCAL:
        if (SYMBOL_BASEREG_VALID (sym))
  	{
! 	  printf ("a local variable at offset %ld from register %s",
  		  val, reg_names[basereg]);
  	}
        else
  	{
! 	  printf ("a local variable at frame offset %ld", val);
  	}
        break;
  
      case LOC_REF_ARG:
!       printf ("a reference argument at offset %ld", val);
        break;
  
      case LOC_TYPEDEF:
!       printf ("a typedef");
        break;
  
      case LOC_BLOCK:
!       printf ("a function at address %s",
  	      local_hex_string(BLOCK_START (SYMBOL_BLOCK_VALUE (sym))));
        break;
  
      default:
!       printf ("of unknown (botched) type");
        break;
      }
!   printf (".\n");
  }
  
  static void
--- 968,1000 ----
      case LOC_LOCAL:
        if (SYMBOL_BASEREG_VALID (sym))
  	{
! 	  printf_filtered ("a local variable at offset %ld from register %s",
  		  val, reg_names[basereg]);
  	}
        else
  	{
! 	  printf_filtered ("a local variable at frame offset %ld", val);
  	}
        break;
  
      case LOC_REF_ARG:
!       printf_filtered ("a reference argument at offset %ld", val);
        break;
  
      case LOC_TYPEDEF:
!       printf_filtered ("a typedef");
        break;
  
      case LOC_BLOCK:
!       printf_filtered ("a function at address %s",
  	      local_hex_string(BLOCK_START (SYMBOL_BLOCK_VALUE (sym))));
        break;
  
      default:
!       printf_filtered ("of unknown (botched) type");
        break;
      }
!   printf_filtered (".\n");
  }
  
  static void
***************
*** 1419,1425 ****
  	d->status = disabled;
  	return;
        }
!   printf ("No display number %d.\n", num);
  }
    
  void
--- 1429,1435 ----
  	d->status = disabled;
  	return;
        }
!   printf_filtered ("No display number %d.\n", num);
  }
    
  void
***************
*** 1428,1434 ****
    if (current_display_number >= 0)
      {
        disable_display (current_display_number);
!       fprintf (stderr, "Disabling display %d to avoid infinite recursion.\n",
  	       current_display_number);
      }
    current_display_number = -1;
--- 1438,1444 ----
    if (current_display_number >= 0)
      {
        disable_display (current_display_number);
!       fprintf_filtered (stderr, "Disabling display %d to avoid infinite recursion.\n",
  	       current_display_number);
      }
    current_display_number = -1;
***************
*** 1442,1448 ****
    register struct display *d;
  
    if (!display_chain)
!     printf ("There are no auto-display expressions now.\n");
    else
        printf_filtered ("Auto-display expressions now in effect:\n\
  Num Enb Expression\n");
--- 1452,1458 ----
    register struct display *d;
  
    if (!display_chain)
!     printf_filtered ("There are no auto-display expressions now.\n");
    else
        printf_filtered ("Auto-display expressions now in effect:\n\
  Num Enb Expression\n");
***************
*** 1495,1501 ****
  	      d->status = enabled;
  	      goto win;
  	    }
! 	printf ("No display number %d.\n", num);
        win:
  	p = p1;
  	while (*p == ' ' || *p == '\t')
--- 1505,1511 ----
  	      d->status = enabled;
  	      goto win;
  	    }
! 	printf_filtered ("No display number %d.\n", num);
        win:
  	p = p1;
  	while (*p == ' ' || *p == '\t')
***************
*** 1652,1662 ****
--- 1662,1680 ----
  	 standard indentation here is 4 spaces, and val_print indents
  	 2 for each recurse.  */
        val = read_var_value (sym, FRAME_INFO_ID (fi));
+ 
+       energize_start_variable_annotation(SYMBOL_NAME(sym), sym,
+ 					 VALUE_TYPE(val),
+ 					 VALUE_ADDRESS(val), "");
+ 
        if (val)
          val_print (VALUE_TYPE (val), VALUE_CONTENTS (val), VALUE_ADDRESS (val),
  		   stream, 0, 0, 2, Val_no_prettyprint);
        else
  	fputs_filtered ("???", stream);
+ 
+       energize_end_variable_annotation();
+ 
        first = 0;
      }
  
===================================================================
*** 1.35	1992/09/18 09:20:00
--- stack.c	1992/09/28 21:34:14
***************
*** 159,165 ****
        if (addressprint)
          printf_filtered ("%s in ", local_hex_string(fi->pc));
  
!       fputs_demangled (fname, stdout, 0);
        fputs_filtered (" (...)\n", stdout);
        
        return;
--- 159,168 ----
        if (addressprint)
          printf_filtered ("%s in ", local_hex_string(fi->pc));
  
!       if (energize)
! 	energize_annotate_function(fname, 0, level);
!       else
! 	fputs_demangled (fname, stdout, 0);
        fputs_filtered (" (...)\n", stdout);
        
        return;
***************
*** 218,224 ****
        if (addressprint)
  	if (fi->pc != sal.pc || !sal.symtab)
  	  printf_filtered ("%s in ", local_hex_string(fi->pc));
!       fputs_demangled (funname ? funname : "??", stdout, 0);
        wrap_here ("   ");
        fputs_filtered (" (", stdout);
        if (args)
--- 221,230 ----
        if (addressprint)
  	if (fi->pc != sal.pc || !sal.symtab)
  	  printf_filtered ("%s in ", local_hex_string(fi->pc));
!       if (energize)
! 	energize_annotate_function(funname ? funname : "??", 0, level);
!       else
! 	fputs_demangled (funname ? funname : "??", stdout, 0);
        wrap_here ("   ");
        fputs_filtered (" (", stdout);
        if (args)
***************
*** 255,261 ****
  	{
  	  if (addressprint && mid_statement)
  	    printf_filtered ("%s\t", local_hex_string(fi->pc));
! 	  print_source_lines (sal.symtab, sal.line, sal.line + 1, 0);
  	}
        current_source_line = max (sal.line - lines_to_list/2, 1);
      }
--- 261,268 ----
  	{
  	  if (addressprint && mid_statement)
  	    printf_filtered ("%s\t", local_hex_string(fi->pc));
! 	  if (!energize)
! 	    print_source_lines (sal.symtab, sal.line, sal.line + 1, 0);
  	}
        current_source_line = max (sal.line - lines_to_list/2, 1);
      }
***************
*** 429,435 ****
    if (funname)
      {
        printf_filtered (" in ");
!       fputs_demangled (funname, stdout, DMGL_ANSI | DMGL_PARAMS);
      }
    wrap_here ("   ");
    if (sal.symtab)
--- 436,446 ----
    if (funname)
      {
        printf_filtered (" in ");
!       if (energize)
! 	energize_annotate_function(funname, DMGL_ANSI | DMGL_PARAMS,
! 				   selected_frame_level);
!       else
! 	fputs_demangled (funname, stdout, DMGL_ANSI | DMGL_PARAMS);
      }
    wrap_here ("   ");
    if (sal.symtab)
===================================================================
*** 1.59	1992/09/29 05:07:26
--- symfile.c	1992/09/28 21:34:14
***************
*** 614,619 ****
--- 614,621 ----
        fflush (stdout);
      }
  
+   energize_symbol_file(objfile);
+ 
    return (objfile);
  }
  
***************
*** 646,652 ****
        current_source_line = 0;
        if (from_tty)
  	{
! 	  printf ("No symbol file now.\n");
  	}
      }
    else
--- 648,654 ----
        current_source_line = 0;
        if (from_tty)
  	{
! 	  printf_filtered ("No symbol file now.\n");
  	}
      }
    else
***************
*** 1164,1170 ****
      return;
    clear_symtab_users_done = clear_symtab_users_queued;
  
!   printf ("Resetting debugger state after updating old symbol tables\n");
  
    /* Someday, we should do better than this, by only blowing away
       the things that really need to be blown.  */
--- 1166,1172 ----
      return;
    clear_symtab_users_done = clear_symtab_users_queued;
  
!   printf_filtered ("Resetting debugger state after updating old symbol tables\n");
  
    /* Someday, we should do better than this, by only blowing away
       the things that really need to be blown.  */
===================================================================
*** 1.63	1992/09/26 05:34:06
--- utils.c	1992/09/28 21:34:15
***************
*** 700,720 ****
        fflush (stdout);
        va_start (args);
        ctlstr = va_arg (args, char *);
        vfprintf_filtered (stdout, ctlstr, args);
-       va_end (args);
        printf_filtered ("(y or n) ");
!       fflush (stdout);
!       answer = fgetc (stdin);
!       clearerr (stdin);		/* in case of C-d */
!       if (answer == EOF)	/* C-d */
!         return 1;
!       if (answer != '\n')	/* Eat rest of input line, to EOF or newline */
! 	do 
! 	  {
! 	    ans2 = fgetc (stdin);
! 	    clearerr (stdin);
! 	  }
!         while (ans2 != EOF && ans2 != '\n');
        if (answer >= 'a')
  	answer -= 040;
        if (answer == 'Y')
--- 700,731 ----
        fflush (stdout);
        va_start (args);
        ctlstr = va_arg (args, char *);
+       energize_query (ctlstr, args);
        vfprintf_filtered (stdout, ctlstr, args);
        printf_filtered ("(y or n) ");
!       if (energize)
! 	{
! 	  char *buf;
! 
! 	  buf = energize_command_line_input(0, 0);
! 	  answer = buf ? *buf : 'Y';
! 	  energize_acknowledge_query(buf);
! 	}
!       else
! 	{
! 	  fflush (stdout);
! 	  answer = fgetc (stdin);
! 	  clearerr (stdin);		/* in case of C-d */
! 	  if (answer == EOF)	/* C-d */
! 	    return 1;
! 	  if (answer != '\n')	/* Eat rest of input line, to EOF or newline */
! 	    do 
! 	      {
! 		ans2 = fgetc (stdin);
! 		clearerr (stdin);
! 	      }
! 	  while (ans2 != EOF && ans2 != '\n');
! 	}
        if (answer >= 'a')
  	answer -= 040;
        if (answer == 'Y')
***************
*** 722,727 ****
--- 733,739 ----
        if (answer == 'N')
  	return 0;
        printf_filtered ("Please answer y or n.\n");
+       va_end (args);
      }
  }
  
***************
*** 1000,1005 ****
--- 1012,1023 ----
    if (linebuffer == 0)
      return;
    
+   if (energize)
+     {
+       energize_fputs(linebuffer);
+       return;
+     }
+ 
    /* Don't do any filtering if it is disabled.  */
    if (stream != stdout
     || (lines_per_page == UINT_MAX && chars_per_line == UINT_MAX))
===================================================================
*** 1.55	1992/09/29 05:07:34
--- valprint.c	1992/09/28 21:34:15
***************
*** 384,390 ****
  			     VALUE_CONTENTS (val) + typelen * i,
  			     VALUE_ADDRESS (val) + typelen * i,
  			     stream, format, 1, 0, pretty);
! 		  fprintf (stream, " <repeats %u times>", reps);
  		  i = rep1 - 1;
  		  things_printed += REPEAT_COUNT_THRESHOLD;
  		}
--- 384,390 ----
  			     VALUE_CONTENTS (val) + typelen * i,
  			     VALUE_ADDRESS (val) + typelen * i,
  			     stream, format, 1, 0, pretty);
! 		  fprintf_filtered (stream, " <repeats %u times>", reps);
  		  i = rep1 - 1;
  		  things_printed += REPEAT_COUNT_THRESHOLD;
  		}
***************
*** 488,493 ****
--- 488,494 ----
       struct type **dont_print;
  {
    int i, len, n_baseclasses;
+   char expr_tag[100];		/* Energize */
  
    check_stub_type (type);
  
***************
*** 552,557 ****
--- 553,565 ----
  	      fprint_symbol (stream, TYPE_FIELD_NAME (type, i));
  	      fputs_filtered (" = ", stream);
  	    }
+ 
+ 	  sprintf(expr_tag, ".%s", TYPE_FIELD_NAME(type, i));
+ 
+ 	  energize_start_variable_annotation(expr_tag, NULL,
+ 					     TYPE_FIELD_TYPE(type, i),
+ 					     (CORE_ADDR) (valaddr + TYPE_FIELD_BITPOS(type, i) / 8),
+ 					     "");
  	  if (TYPE_FIELD_PACKED (type, i))
  	    {
  	      value v;
***************
*** 570,575 ****
--- 578,584 ----
  			 valaddr + TYPE_FIELD_BITPOS (type, i) / 8,
  			 0, stream, format, 0, recurse + 1, pretty);
  	    }
+ 	  energize_end_variable_annotation();
  	}
        if (pretty)
  	{
***************
*** 804,809 ****
--- 813,819 ----
  		  unsigned int rep1;
  		  /* Number of repetitions we have detected so far.  */
  		  unsigned int reps;
+ 		  char expr_tag[100]; /* Energize */
  		  
  		  if (i != 0)
  		    if (arrayprint)
***************
*** 825,830 ****
--- 835,845 ----
  		      ++rep1;
  		    }
  
+ 		  sprintf(expr_tag, "[%d]", i);
+ 		  energize_start_variable_annotation(expr_tag, NULL,
+ 						     elttype,
+ 						     (CORE_ADDR) (valaddr + i * eltlen),
+ 						     "");
  		  if (reps > REPEAT_COUNT_THRESHOLD)
  		    {
  		      val_print (elttype, valaddr + i * eltlen,
***************
Sun Oct 24 23:48:55 1993*** 841,846 ****
--- 856,862 ----
  				 recurse + 1, pretty);
  		      things_printed++;
  		    }
+ 		  energize_end_variable_annotation();
  		}
  	      if (i < len)
  		fprintf_filtered (stream, "...");
***************
*** 910,916 ****
  	    {
  	      fprintf_filtered (stream, "&");
  	      type_print_varspec_prefix (TYPE_FN_FIELD_TYPE (f, j), stream, 0, 0);
! 	      fprintf (stream, kind);
  	      if (TYPE_FN_FIELD_PHYSNAME (f, j)[0] == '_'
  		  && TYPE_FN_FIELD_PHYSNAME (f, j)[1] == CPLUS_MARKER)
  		type_print_method_args
--- 926,932 ----
  	    {
  	      fprintf_filtered (stream, "&");
  	      type_print_varspec_prefix (TYPE_FN_FIELD_TYPE (f, j), stream, 0, 0);
! 	      fprintf_filtered (stream, kind);
  	      if (TYPE_FN_FIELD_PHYSNAME (f, j)[0] == '_'
  		  && TYPE_FN_FIELD_PHYSNAME (f, j)[1] == CPLUS_MARKER)
  		type_print_method_args
***************
*** 1528,1534 ****
  
      case TYPE_CODE_METHOD:
        if (passed_a_ptr)
! 	fprintf (stream, "(");
        type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0,
  				 0);
        if (passed_a_ptr)
--- 1544,1550 ----
  
      case TYPE_CODE_METHOD:
        if (passed_a_ptr)
! 	fprintf_filtered (stream, "(");
        type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0,
  				 0);
        if (passed_a_ptr)
***************
*** 1907,1913 ****
  		  if (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)) == 0)
  		    {
  		      /* Keep GDB from crashing here.  */
! 		      fprintf (stream, "<undefined type> %s;\n",
  			       TYPE_FN_FIELD_PHYSNAME (f, j));
  		      break;
  		    }
--- 1923,1929 ----
  		  if (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)) == 0)
  		    {
  		      /* Keep GDB from crashing here.  */
! 		      fprintf_filtered (stream, "<undefined type> %s;\n",
  			       TYPE_FN_FIELD_PHYSNAME (f, j));
  		      break;
  		    }
***************
*** 2098,2104 ****
       char *arg;
       int from_tty;
  {
!   printf (
  "\"set print\" must be followed by the name of a print subcommand.\n");
    help_list (setprintlist, "set print ", -1, stdout);
  }
--- 2114,2120 ----
       char *arg;
       int from_tty;
  {
!   printf_filtered (
  "\"set print\" must be followed by the name of a print subcommand.\n");
    help_list (setprintlist, "set print ", -1, stdout);
  }
===================================================================
*** 1.5	1992/09/26 08:07:45
--- amix.mh	1992/09/28 21:34:15
***************
*** 22,24 ****
--- 22,38 ----
  
  # SVR4 puts the BSD compatible install in /usr/ucb.
  INSTALL = /usr/ucb/install -c
+ 
+ # These are the libs that are needed for the Energize version of gdb on
+ # SVR4.  Note that we MUST include the standard C library before libucb.a,
+ # otherwise we get lots of broken stuff we don't want.
+ ENERGIZE_LIB = energize/libconn.a
+ ENERGIZE_LIBS = ${ENERGIZE_LIB} -L/usr/lib -lm -lnet -lresolv -lform \
+ 	-lsocket -lc /usr/ucblib/libucb.a -lnsl
+ 
+ # These are the libs that are needed for the Energize version of gdb on
+ # SVR4.  Note that we MUST include the standard C library before libucb.a,
+ # otherwise we get lots of broken stuff we don't want.
+ ENERGIZE_LIB = energize/libconn.a
+ ENERGIZE_LIBS = ${ENERGIZE_LIB} -L/usr/lib -lm -lnet -lresolv -lform \
+ 	-lsocket -lc /usr/ucblib/libucb.a -lnsl
===================================================================
*** 1.5	1992/09/26 08:08:14
--- ncr3000.mh	1992/09/28 21:34:16
***************
*** 38,40 ****
--- 38,59 ----
  # The /usr/ucb/install program is incompatible (complains about unknown
  # group staff).  Use good old cp...
  INSTALL = cp
+ 
+ # These are the libs that are needed for the Energize version of gdb on
+ # SVR4.  Note that we MUST include the standard C library before libucb.a,
+ # otherwise we get lots of broken stuff we don't want.
+ XM_CLIBS = -L/usr/lib -lm -lnet -lresolv -lform -lsocket -lnsl -lc
+ 
+ # These are the libs that are needed for the Energize version of gdb on
+ # SVR4.  Note that we MUST include the standard C library before libucb.a,
+ # otherwise we get lots of broken stuff we don't want.
+ ENERGIZE_LIB = energize/libconn.a
+ ENERGIZE_LIBS = ${ENERGIZE_LIB} -L/usr/lib -lm -lnet -lresolv -lform \
+ 	-lsocket -lc /usr/ucblib/libucb.a -lnsl
+ 
+ # These are the libs that are needed for the Energize version of gdb on
+ # SVR4.  Note that we MUST include the standard C library before libucb.a,
+ # otherwise we get lots of broken stuff we don't want.
+ ENERGIZE_LIB = energize/libconn.a
+ ENERGIZE_LIBS = ${ENERGIZE_LIB} -L/usr/lib -lm -lnet -lresolv -lform \
+ 	-lsocket -lc /usr/ucblib/libucb.a -lnsl
