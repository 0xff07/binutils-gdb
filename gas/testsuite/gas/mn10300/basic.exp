# Copyright (C) 1996 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# DejaGnu@cygnus.com

# Written by Cygnus Support.

proc do_add {} {
    set testname "add.s: Add operations"
    set x 0

    gas_start "add.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0003\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0007\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0009\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000d\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0013\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0015\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0019\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001f\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0026\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==14] then { pass $testname } else { fail $testname }
}

proc do_bcc {} {
    set testname "bcc.s: Bcc tests"
    set x 0

    gas_start "bcc.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0017\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001d\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==15] then { pass $testname } else { fail $testname }
}

proc do_bit {} {
    set testname "bit.s: bit tests"
    set x 0

    gas_start "bit.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0003\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0007\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000d\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0011\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0025\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0027\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002b\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==11] then { pass $testname } else { fail $testname }
}

proc do_cmp {} {
    set testname "cmp.s: cmp tests"
    set x 0

    gas_start "cmp.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0003\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==10] then { pass $testname } else { fail $testname }
}

proc do_ext {} {
    set testname "ext.s: ext tests"
    set x 0

    gas_start "ext.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0003\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==5] then { pass $testname } else { fail $testname }
}

proc do_extend {} {
    set testname "extend.s: extended instruction tests"
    set x 0

    gas_start "extend.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0009\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000d\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0013\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0015\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0026\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==13] then { pass $testname } else { fail $testname }
}

proc do_logical {} {
    set testname "logical.s: logical tests"
    set x 0

    gas_start "logical.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0009\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000f\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0013\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0015\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0026\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0028\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0032\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==14] then { pass $testname } else { fail $testname }
}

proc do_loop {} {
    set testname "loop.s: loop tests"
    set x 0

    gas_start "loop.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0003\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0007\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0009\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000b\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==12] then { pass $testname } else { fail $testname }
}

proc do_mov1 {} {
    set testname "mov1.s: mov1 tests"
    set x 0

    gas_start "mov1.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0003\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0007\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0009\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000b\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000d\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000f\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0013\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0017\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001d\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001f\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==15] then { pass $testname } else { fail $testname }
}

proc do_mov2 {} {
    set testname "mov2.s: mov2 tests"
    set x 0

    gas_start "mov2.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000b\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0011\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0013\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0026\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0032\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0038\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==15] then { pass $testname } else { fail $testname }
}

proc do_mov3 {} {
    set testname "mov3.s: mov3 tests"
    set x 0

    gas_start "mov3.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001f\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0025\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0027\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0034\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==15] then { pass $testname } else { fail $testname }
}

proc do_mov4 {} {
    set testname "mov4.s: mov4 tests"
    set x 0

    gas_start "mov4.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0019\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001b\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0026\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0029\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==12] then { pass $testname } else { fail $testname }
}

proc do_movbu {} {
    set testname "movbu.s: movbu tests"
    set x 0

    gas_start "movbu.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0009\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000f\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0021\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0027\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0029\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0036\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0039\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 003d\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0043\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0045\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0048\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==20] then { pass $testname } else { fail $testname }
}

proc do_movbu {} {
    set testname "movbu.s: movbu tests"
    set x 0

    gas_start "movbu.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0009\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000f\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0021\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0027\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0029\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0036\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0039\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 003d\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0043\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0045\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0048\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==20] then { pass $testname } else { fail $testname }
}

proc do_movhu {} {
    set testname "movhu.s: movhu tests"
    set x 0

    gas_start "movhu.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0009\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000f\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0021\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0027\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0029\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0036\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0039\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 003d\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0043\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0045\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0048\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==20] then { pass $testname } else { fail $testname }
}

proc do_movm {} {
    set testname "movm.s: movm tests"
    set x 0

    gas_start "movm.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==4] then { pass $testname } else { fail $testname }
}

proc do_muldiv {} {
    set testname "muldiv.s: muldiv tests"
    set x 0

    gas_start "muldiv.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==4] then { pass $testname } else { fail $testname }
}

proc do_other {} {
    set testname "other.s: other tests"
    set x 0

    gas_start "other.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0003\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0009\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0013\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0026\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0029\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0032\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0033\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==19] then { pass $testname } else { fail $testname }
}

proc do_shift {} {
    set testname "shift.s: shift tests"
    set x 0

    gas_start "shift.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0007\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000f\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==9] then { pass $testname } else { fail $testname }
}

proc do_sub {} {
    set testname "sub.s: sub tests"
    set x 0

    gas_start "sub.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==7] then { pass $testname } else { fail $testname }
}

if [istarget mn10300*-*-*] then {
    # Test the basic instruction parser.
    do_add
    do_bcc
    do_bit
    do_cmp
    do_ext
    do_extend
    do_logical
    do_loop
    do_mov1
    do_mov2
    do_mov3
    do_mov4
    do_movbu
    do_movhu
    do_movm
    do_muldiv
    do_other
    do_shift
    do_sub
}
