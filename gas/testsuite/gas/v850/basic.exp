# Copyright (C) 1996 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# DejaGnu@cygnus.com

# Written by Cygnus Support.

proc do_arith {} {
    set testname "arith.s: Arithmetic operations"
    set x 0

    gas_start "arith.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    # -re "^ +\[0-9\]+ 0000 489A0000\[^\n\]*\n"	{ set x [expr $x+1] }
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0028\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0032\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==20] then { pass $testname } else { fail $testname }
}

proc do_bit {} {
    set testname "bit.s: bit operations"
    set x 0

    gas_start "bit.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==4] then { pass $testname } else { fail $testname }
}

proc do_branch {} {
    set testname "branch.s: branch operations"
    set x 0

    gas_start "branch.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0026\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==20] then { pass $testname } else { fail $testname }
}

proc do_compare {} {
    set testname "compare.s: compare operations"
    set x 0

    gas_start "compare.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0028\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0034\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0038\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 003c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0040\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0044\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0048\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 004c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0050\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0054\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==23] then { pass $testname } else { fail $testname }
}

proc do_jumps {} {
    set testname "jumps.s: jumps operations"
    set x 0

    gas_start "jumps.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==3] then { pass $testname } else { fail $testname }
}

proc do_logical {} {
    set testname "logical.s: logical operations"
    set x 0

    gas_start "logical.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==7] then { pass $testname } else { fail $testname }
}

proc do_mem {} {
    set testname "mem.s: memory operations"
    set x 0

    gas_start "mem.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==12] then { pass $testname } else { fail $testname }
}

proc do_misc {} {
    set testname "misc.s: misc operations"
    set x 0

    gas_start "misc.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==9] then { pass $testname } else { fail $testname }
}

proc do_move {} {
    set testname "move.s: move operations"
    set x 0

    gas_start "move.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==4] then { pass $testname } else { setup_xfail "*-*-*" ; fail $testname }
}

if [istarget v850*-*-*] then {
    # Test the basic instruction parser.
    do_arith
    do_bit
    do_branch
    do_compare
    do_jumps
    do_logical
    do_mem
    do_misc
    do_move
}
