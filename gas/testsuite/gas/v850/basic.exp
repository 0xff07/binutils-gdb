# Copyright (C) 1996 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# DejaGnu@cygnus.com

# Written by Cygnus Support.

proc do_arith {} {
    set testname "arith.s: Arithmetic operations"
    set x 0

    gas_start "arith.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    # -re "^ +\[0-9\]+ 0000 489A0000\[^\n\]*\n"	{ set x [expr $x+1] }
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 C531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002 4532\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 05360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 4530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a E530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c E532\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e E5360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012 E537A000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016 BF32\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018 C530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a 2532\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c A530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e 65360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022 8530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024 E537C000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0028 DF32\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002a E5378000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002e 9F32\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030 A531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0032 8531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==20] then { pass $testname } else { fail $testname }
}

proc do_bit {} {
    set testname "bit.s: bit operations"
    set x 0

    gas_start "bit.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 C6AF1000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 C66F1000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 C62F1000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c C6EF1000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==4] then { pass $testname } else { fail $testname }
}

proc do_branch {} {
    set testname "branch.s: branch operations"
    set x 0

    gas_start "branch.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 8F05\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002 8E05\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 8605\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006 8705\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 8B05\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a 8905\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c 8105\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e 8305\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010 8205\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012 8A05\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014 8005\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016 8805\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018 8405\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a 8C05\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c 8105\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e 8905\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020 8205\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022 8A05\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024 8505\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0026 8D05\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==20] then { pass $testname } else { fail $testname }
}

proc do_compare {} {
    set testname "compare.s: compare operations"
    set x 0

    gas_start "compare.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 E531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002 6532\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 E02F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 E82F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c E12F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010 E12F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014 E92F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018 E92F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c E22F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020 EA2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024 E32F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0028 EB2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c E42F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030 E42F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0034 EC2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0038 EC2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 003c E52F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0040 ED2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0044 E62F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0048 EE2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 004c E72F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0050 EF2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0054 6531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==23] then { pass $testname } else { fail $testname }
}

proc do_jumps {} {
    set testname "jumps.s: jumps operations"
    set x 0

    gas_start "jumps.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==3] then { pass $testname } else { fail $testname }
}

proc do_logical {} {
    set testname "logical.s: logical operations"
    set x 0

    gas_start "logical.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==7] then { pass $testname } else { fail $testname }
}

proc do_mem {} {
    set testname "mem.s: memory operations"
    set x 0

    gas_start "mem.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==12] then { pass $testname } else { fail $testname }
}

proc do_misc {} {
    set testname "misc.s: misc operations"
    set x 0

    gas_start "misc.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==9] then { pass $testname } else { fail $testname }
}

proc do_move {} {
    set testname "move.s: move operations"
    set x 0

    gas_start "move.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==4] then { pass $testname } else { setup_xfail "*-*-*" ; fail $testname }
}

if [istarget v850*-*-*] then {
    # Test the basic instruction parser.
    do_arith
    do_bit
    do_branch
    do_compare
    do_jumps
    do_logical
    do_mem
    do_misc
    do_move
}
