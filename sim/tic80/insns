// The following is called when ever an illegal instruction is
// encountered
::internal::illegal
	engine_error (SD, CPU, cia, "illegal instruction at 0x%lx", cia.ip);

// Signed Integer Add - add source1, source2, dest
void::function::do_add:signed32 *rDest, signed32 Source1, signed32 Source2
	ALU_BEGIN (Source1);
	ALU_ADD (Source2);
	ALU_END (*rDest);
	/* FIXME - a signed add may cause an exception */
31.Dest,26.Source2,21.0b101100,15.0,14.SignedImmediate::::add i
	do_add (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b11101100,13.0,12.0,11./,4.Source1::::add r
	do_add (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b11101100,13.0,12.1,11./::::add l
	long_immediate (LongSignedImmediate);
	do_add (_SD, rDest, LongSignedImmediate, rSource2);


// Unsigned Integer Add - addu source1, source2, dest
void::function::do_addu:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
	*rDest = Source1 + Source2;
31.Dest,26.Source2,21.0b101100,15.1,14.SignedImmediate::::addu i
	do_addu (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b11101100,13.1,12.0,11./,4.Source1::::addu r
	do_addu (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b11101100,13.1,12.1,11./::::addu l
	long_immediate (LongSignedImmediate);
	do_addu (_SD, rDest, LongSignedImmediate, rSource2);


void::function::do_and:signed32 *rDest, signed32 Source1, signed32 Source2
	*rDest = Source1 & Source2;


// and, and.tt
31.Dest,26.Source2,21.0b0010001,14.SignedImmediate::::and.tt i
	do_and (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b110010001,12.0,11./,4.Source1::::and.tt r
	do_and (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b110010001,12.1,11./::::and.tt l
	long_immediate (LongSignedImmediate);
	do_and (_SD, rDest, LongSignedImmediate, rSource2);


// and.ff
31.Dest,26.Source2,21.0b0011000,14.SignedImmediate::::and.ff i
	do_and (_SD, rDest, ~vSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011000,12.0,11./,4.Source1::::and.ff r
	do_and (_SD, rDest, ~rSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011000,12.1,11./::::and.ff l
	long_immediate (LongSignedImmediate);
	do_and (_SD, rDest, ~LongSignedImmediate, ~rSource2);


// and.ft
31.Dest,26.Source2,21.0b0010100,14.SignedImmediate::::and.ft i
	do_and (_SD, rDest, ~vSource1, rSource2);
31.Dest,26.Source2,21.0b110010100,12.0,11./,4.Source1::::and.ft r
	do_and (_SD, rDest, ~rSource1, rSource2);
31.Dest,26.Source2,21.0b110010100,12.1,11./::::and.ft l
	long_immediate (LongSignedImmediate);
	do_and (_SD, rDest, ~LongSignedImmediate, rSource2);


// and.tf
31.Dest,26.Source2,21.0b0010010,14.SignedImmediate::::and.tf i
	do_and (_SD, rDest, vSource1, ~rSource2);
31.Dest,26.Source2,21.0b110010010,12.0,11./,4.Source1::::and.tf r
	do_and (_SD, rDest, rSource1, ~rSource2);
31.Dest,26.Source2,21.0b110010010,12.1,11./::::and.tf l
	long_immediate (LongSignedImmediate);
	do_and (_SD, rDest, LongSignedImmediate, ~rSource2);


// bbo.[a]
instruction_address::function::do_bbo:instruction_address nia, int bitnum, unsigned32 source, int annul, unsigned32 offset
	if (MASKED32 (source, bitnum, bitnum))
	  {
	    if (annul)
	      nia.ip = -1;
	    nia.dp = cia.ip + 4 * offset;
	  }
	return nia;
31.BITNUM,26.Source,21.0b100101,15.A,14.SignedOffset::::bbo i
	nia = do_bbo (_SD, nia, BITNUM, rSource, A, vSignedOffset);
31.BITNUM,26.Source,21.0b11100101,13.A,12.0,11./,4.IndOff::::bbo r
	nia = do_bbo (_SD, nia, BITNUM, rSource, A, rIndOff);
31.BITNUM,26.Source,21.0b11100101,13.A,12.1,11./::::bbo l
	long_immediate (LongSignedImmediate);
	nia = do_bbo (_SD, nia, BITNUM, rSource, A, LongSignedImmediate);


// bbz[.a]
instruction_address::function::do_bbz:instruction_address nia, int bitnum, unsigned32 source, int annul, unsigned32 offset
	if (!MASKED32 (source, bitnum, bitnum))
	  {
	    if (annul)
	      nia.ip = -1;
	    nia.dp = cia.ip + 4 * offset;
	  }
	return nia;
31.BITNUM,26.Source,21.0b100100,15.A,14.SignedOffset::::bbz i
	nia = do_bbz (_SD, nia, BITNUM, rSource, A, vSignedOffset);
31.BITNUM,26.Source,21.0b11100100,13.A,12.0,11./,4.IndOff::::bbz r
	nia = do_bbz (_SD, nia, BITNUM, rSource, A, rIndOff);
31.BITNUM,26.Source,21.0b11100100,13.A,12.1,11./::::bbz l
	long_immediate (LongSignedImmediate);
	nia = do_bbz (_SD, nia, BITNUM, rSource, A, LongSignedImmediate);


// bcnd[.a]
instruction_address::function::do_bcnd:instruction_address nia, int Cond, unsigned32 source, int annul, unsigned32 offset
	int condition;
	int size = EXTRACTED32 (Cond, 31 - 27, 30 - 27);
	int code = EXTRACTED32 (Cond, 29 - 27, 27 - 27);
	signed32 val = 0;
	switch (size)
	  {
	  case 0: val = SEXT32 (source, 7); break;
	  case 1: val = SEXT32 (source, 15); break;
	  case 2: val = source; break;
	  default: engine_error (SD, CPU, cia, "bcnd - reserved size");
	  }
	switch (code)
	  {
	  case 0: condition = 0; break;
	  case 1: condition = val > 0; break;
	  case 2: condition = val == 0; break;
	  case 3: condition = val >= 0; break;
	  case 4: condition = val < 0; break;
	  case 5: condition = val != 0; break;
	  case 6: condition = val <= 0; break;
	  default: condition = 1; break;
	  }
	if (condition)
	  {
	    if (annul)
	      nia.ip = -1;
	    nia.dp = cia.ip + 4 * offset;
	  }
	return nia;
31.Code,26.Source,21.0b100110,15.A,14.SignedOffset::::bcnd i
	nia = do_bcnd (_SD, nia, Code, rSource, A, vSignedOffset);
31.Code,26.Source,21.0b11100110,13.A,12.0,11./,4.IndOff::::bcnd r
	nia = do_bcnd (_SD, nia, Code, rSource, A, rIndOff);
31.Code,26.Source,21.0b11100110,13.A,12.1,11./::::bcnd l
	long_immediate (LongSignedImmediate);
	nia = do_bcnd (_SD, nia, Code, rSource, A, LongSignedImmediate);


// br[.a] - see bbz[.a]


// brcr
#void::function::do_brcr:unsigned32 offset
#	sim_io_error ("brcr");
31.//,27.0,26.//,21.0b0000110,14.CRN::::brcr i
#	nia = do_brcr (_SD, rCRN_val);
31.//,27.0,26.//,21.0b110000110,12.0,11./,4.Source1::::brcr r
#	nia = do_brcr (_SD, CRN[rSource1]);
31.//,27.0,26.//,21.0b110000110,12.1,11./::::brcr l
#	nia = do_brcr (_SD, CRN[SL]);


// bsr[.a]
instruction_address::function::do_bsr:instruction_address nia, signed32 *rLink, int annul, unsigned32 offset
	if (annul)
	  {
	    *rLink = nia.ip;
	    nia.ip = -1;
	  }
	else
	  *rLink = cia.dp + sizeof (instruction_word);
	nia.dp = cia.ip + 4 * offset;
	return nia;
31.Link,26./,21.0b100000,15.A,14.SignedOffset::::bsr i
	nia = do_bsr (_SD, nia, rLink, A, vSignedOffset);
31.Link,26./,21.0b11100000,13.A,12.0,11./,4.IndOff::::bsr r
	nia = do_bsr (_SD, nia, rLink, A, rIndOff);
31.Link,26./,21.0b11100000,13.A,12.1,11./::::bsr l
	long_immediate (LongSignedImmediate);
	nia = do_bsr (_SD, nia, rLink, A, LongSignedImmediate);


// cmnd
31./,21.0b0000010,14.UI::::cmnd i
31./,21.0b110000010,12.0,11./,4.Source1::::cmnd r
31./,21.0b110000010,12.1,11./::::cmnd l


// cmp
unsigned32::function::cmp_vals:signed32 s1, unsigned32 u1, signed32 s2, unsigned32 u2
	unsigned32 field = 0;
	if (s1 == s2) field |= BIT32 (0);
	if (s1 != s2) field |= BIT32 (1);
	if (s1 >  s2) field |= BIT32 (2);
	if (s1 <= s2) field |= BIT32 (3);
	if (s1 <  s2) field |= BIT32 (4);
	if (s1 >= s2) field |= BIT32 (5);
	if (u1 >  u2) field |= BIT32 (6);
	if (u1 <= u2) field |= BIT32 (7);
	if (u1 <  u2) field |= BIT32 (8);
	if (u1 >= u2) field |= BIT32 (9);
	return field;
void::function::do_cmp:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
	unsigned32 field = 0;
	field |= INSERTED32 (cmp_vals (_SD, Source2, Source1, Source2, Source2),
	                     29, 20);
	field |= INSERTED32 (cmp_vals (_SD, (signed16)Source1, (unsigned16)Source1,
	                               (signed16)Source2, (unsigned16)Source2),
	                     19, 10);
	field |= INSERTED32 (cmp_vals (_SD, (signed8)Source1, (unsigned8)Source1,
	                               (signed8)Source2, (unsigned8)Source2),
	                     9, 0);
	*rDest = field;
31.Dest,26.Source2,21.0b1010000,14.SignedImmediate::::cmp i
	do_cmp (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b111010000,12.0,11./,4.Source1::::cmp r
	do_cmp (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111010000,12.1,11./::::cmp l
	long_immediate (LongSignedImmediate);
	do_cmp (_SD, rDest, LongSignedImmediate, rSource2);


// dcache
31./,27.F,26.Source2,21.0b0111,17.M,16.0b00,14.SignedOffset::::dcache i
	/* NOP */
31./,27.F,26.Source2,21.0b110111,15.M,14.0b00,12.0,11./,4.Source1::::dcache r
	/* NOP */
31./,27.F,26.Source2,21.0b110111,15.M,14.0b00,12.1,11./::::dcache l
	long_immediate (LongSignedImmediate);
	LongSignedImmediate++;
	/* NOP */


// dld[{.b|.h|.d}]
void::function::do_dld:int Dest, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	do_ld (_SD, Dest, Base, rBase, m, sz, S, Offset);
31.Dest,26.Base,21.0b110100,15.m,14.sz,12.0,11.S,10.1,9./,4.IndOff::::dld r
	do_dld (_SD, Dest, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Dest,26.Base,21.0b110100,15.m,14.sz,12.1,11.S,10.1,9./::::dld l
	long_immediate (LongSignedImmediateOffset);
	do_dld (_SD, Dest, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// dld.u[{.b|.h|.d}]
void::function::do_dld_u:unsigned32 *rDest, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	do_ld_u (_SD, rDest, Base, rBase, m, sz, S, Offset);
31.Dest,26.Base,21.0b110101,15.m,14.sz,12.0,11.S,10.1,9./,4.IndOff::::dld.u r
	do_dld_u (_SD, rDest, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Dest,26.Base,21.0b110101,15.m,14.sz,12.1,11.S,10.1,9./::::dld.u l
	long_immediate (LongSignedImmediateOffset);
	do_dld_u (_SD, rDest, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// dst[{.b|.h|.d}]
void::function::do_dst:int Source, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	do_st (_SD, Source, Base, rBase, m, sz, S, Offset);
31.Source,26.Base,21.0b110110,15.m,14.sz,12.0,11.S,10.1,9./,4.IndOff::::dst r
	do_dst (_SD, Source, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Source,26.Base,21.0b110110,15.m,14.sz,12.1,11.S,10.1,9./::::dst l
	long_immediate (LongSignedImmediateOffset);
	do_dst (_SD, Source, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// estop
31./,21.0b1111111,14.1,13.0,12.0,11./::::estop


// etrap
31./,27.1,26./,21.0b0000001,14.UTN::::etrap i
31./,27.1,26./,21.0b110000001,12.0,11./,4.iUTN::::etrap r
31./,27.1,26./,21.0b110000001,12.1,11./::::etrap l


// exts - see shift.ds


// extu - see shift.dz


// fadd.{s|d}{s|d}{s|d}
#void::function::do_fadd:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("fadd");
31.Dest,26.Source2,21.0b111110000,12.0,11.r,10.PD,8.P2,6.P1,4.Source1::::fadd r
#	do_fadd (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110000,12.1,11.r,10.PD,8.P2,6.P1,4./::::fadd l
#	do_fadd (_SD, rDest, LongSignedImmediate, rSource2);


// fcmp.{s|d}{s|d}{s|d}
#void::function::do_fcmp:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("fcmp");
31.Dest,26.Source2,21.0b111110101,12.0,11./,10.0,8.P2,6.P1,4.Source1::::fcmp r
#	do_fcmp (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110101,12.1,11./,10.0,8.P2,6.P1,4./::::fcmp l
#	do_fcmp (_SD, rDest, LongSignedImmediate, rSource2);


// fdiv.{s|d}{s|d}{s|d}
#void::function::do_fdiv:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("fdiv");
31.Dest,26.Source2,21.0b111110011,12.0,11./,10.PD,8.P2,6.P1,4.Source1::::fdiv r
#	do_fdiv (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110011,12.1,11./,10.PD,8.P2,6.P1,4./::::fdiv l
#	do_fdiv (_SD, rDest, LongSignedImmediate, rSource2);


// fmpy.{s|d|i|u}{s|d|i|u}{s|d|i|u}
#void::function::do_fmpy:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("fmpy");
31.Dest,26.Source2,21.0b111110010,12.0,11./,10.PD,8.P2,6.P1,4.Source1::::fmpy r
#	do_fmpy (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110010,12.1,11./,10.PD,8.P2,6.P1,4./::::fmpy l
#	do_fmpy (_SD, rDest, LongSignedImmediate, rSource2);


// frndm.{s|d|i|u}{s|d|i|u}{s|d|i|u}
#void::function::do_frndm:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("frndm");
31.Dest,26.Source2,21.0b111110100,12.0,11.r,10.PD,8.0b11,6.P1,4.Source1::::frndm r
#	do_frndm (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110100,12.1,11.r,10.PD,8.0b11,6.P1,4./::::frndm l
#	do_frndm (_SD, rDest, LongSignedImmediate, rSource2);


// frndn.{s|d|i|u}{s|d|i|u}{s|d|i|u}
#void::function::do_frndn:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("frndn");
31.Dest,26.Source2,21.0b111110100,12.0,11.r,10.PD,8.0b00,6.P1,4.Source1::::frndn r
#	do_frndn (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110100,12.1,11.r,10.PD,8.0b00,6.P1,4./::::frndn l
#	do_frndn (_SD, rDest, LongSignedImmediate, rSource2);


// frndp.{s|d|i|u}{s|d|i|u}{s|d|i|u}
#void::function::do_frndp:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("frndp");
#31.Dest,26.Source2,21.0b111110100,12.0,11.r,10.PD,8.0b10,6.P1,4.Source1::::frndp r
#	do_frndp (_SD, rDest, rSource1, rSource2);
#31.Dest,26.Source2,21.0b111110100,12.1,11.r,10.PD,8.0b10,6.P1,4./::::frndp l
#	do_frndp (_SD, rDest, LongSignedImmediate, rSource2);


// frndz.{s|d|i|u}{s|d|i|u}{s|d|i|u}
#void::function::do_frndz:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("frndz");
31.Dest,26.Source2,21.0b111110100,12.0,11.r,10.PD,8.0b01,6.P1,4.Source1::::frndz r
#	do_frndz (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110100,12.1,11.r,10.PD,8.0b01,6.P1,4./::::frndz l
#	do_frndz (_SD, rDest, LongSignedImmediate, rSource2);


// fsqrt.{s|d}{s|d}{s|d}
#void::function::do_fsqrt:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("fsqrt");
31.Dest,26.Source2,21.0b111110111,12.0,11./,10.PD,8.//,6.P1,4.Source1::::fsqrt r
#	do_fsqrt (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110111,12.1,11./,10.PD,8.//,6.P1,4./::::fsqrt l
#	do_fsqrt (_SD, rDest, LongSignedImmediate, rSource2);


// fsub.{s|d}{s|d}{s|d}
#void::function::do_fsub:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("fsub");
31.Dest,26.Source2,21.0b111110001,12.0,11.r,10.PD,8.P2,6.P1,4.Source1::::fsub r
#	do_fsub (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110001,12.1,11.r,10.PD,8.P2,6.P1,4./::::fsub l
#	do_fsub (_SD, rDest, LongSignedImmediate, rSource2);


// illop
31./,21.0b0000000,14./::::illop
31./,21.0b111111111,12./::::illop l


// ins - see sl.im


// jsr[.a]
instruction_address::function::do_jsr:instruction_address nia, signed32 *rLink, int annul, unsigned32 offset, unsigned32 base
	if (annul)
	  {
	    *rLink = nia.ip;
	    nia.ip = -1;
	  }
	else
	  *rLink = cia.dp + sizeof (instruction_word);
	nia.dp = offset + base;
	if (nia.dp & 0x3)
	  engine_error (SD, CPU, cia, "destination address 0x%lx misaligned",
	                (unsigned long) nia.dp);
	return nia;
31.Link,26.Base,21.0b100010,15.A,14.SignedOffset::::jsr i
	nia = do_jsr (_SD, nia, rLink, A, vSignedOffset, rBase);
31.Link,26.Base,21.0b11100010,13.A,12.0,11./,4.Source1::::jsr r
	nia = do_jsr (_SD, nia, rLink, A, rSource1, rBase);
31.Link,26.Base,21.0b11100010,13.A,12.1,11./::::jsr l
	long_immediate (LongSignedImmediate);
	nia = do_jsr (_SD, nia, rLink, A, LongSignedImmediate, rBase);


// ld[{.b.h.d}]
void::function::do_ld:int Dest, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	unsigned32 addr;
	switch (sz)
	  {
	  case 0:
	    addr = Base + (S ? (Offset << 0) : Offset);
	    if (m)
	      *rBase = addr;
	    GPR(Dest) = MEM (signed, addr, 1);
	    break;
	  case 1:
	    addr = Base + (S ? (Offset << 1) : Offset);
	    if (m)
	      *rBase = addr;
	    GPR(Dest) = MEM (signed, addr, 2);
	    break;
	  case 2:
	    addr = Base + (S ? (Offset << 2) : Offset);
	    if (m)
	      *rBase = addr;
	    GPR(Dest) = MEM (signed, addr, 4);
	    break;
	  case 3:
	    if (Dest & 0x1)
	      engine_error (SD, CPU, cia, "0x%lx: ld.d to odd register %d",
	                    cia.ip, Dest);
	    addr = Base + (S ? (Offset << 3) : Offset);
	    if (m)
	      *rBase = addr;
	    *(unsigned64*)(&GPR(Dest)) = MEM (signed, addr, 8);
	    break;
	  default:
	    addr = -1;
	    engine_error (SD, CPU, cia, "ld - invalid sz %d", sz);
	  }
31.Dest,26.Base,21.0b0100,17.m,16.sz,14.SignedOffset::::ld i
	do_ld (_SD, Dest, rBase, &GPR(Base), m, sz, 0, vSignedOffset);
31.Dest,26.Base,21.0b110100,15.m,14.sz,12.0,11.S,10.0,9./,4.IndOff::::ld r
	do_ld (_SD, Dest, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Dest,26.Base,21.0b110100,15.m,14.sz,12.1,11.S,10.0,9./::::ld l
	long_immediate (LongSignedImmediateOffset);
	do_ld (_SD, Dest, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// ld.u[{.b.h.d}]
void::function::do_ld_u:unsigned32 *rDest, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	unsigned32 addr;
	switch (sz)
	  {
	  case 0:
	    addr = Base + (S ? (Offset << 0) : Offset);
	    *rDest = MEM (unsigned, addr, 1);
	    break;
	  case 1:
	    addr = Base + (S ? (Offset << 1) : Offset);
	    *rDest = MEM (unsigned, addr, 2);
	    break;
	  default:
	    addr = -1;
	    engine_error (SD, CPU, cia, "ld.u - invalid sz %d", sz);
	  }
	if (m)
	  *rBase = addr;
31.Dest,26.Base,21.0b0101,17.m,16.sz,14.SignedOffset::::ld.u i
	do_ld_u (_SD, rDest, rBase, &GPR(Base), m, sz, 0, vSignedOffset);
31.Dest,26.Base,21.0b110101,15.m,14.sz,12.0,11.S,10.0,9./,4.IndOff::::ld.u r
	do_ld_u (_SD, rDest, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Dest,26.Base,21.0b110101,15.m,14.sz,12.1,11.S,10.0,9./::::ld.u l
	long_immediate (LongSignedImmediateOffset);
	do_ld_u (_SD, rDest, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// lmo
31.Dest,26.Source,21.111111000,12.0,11./::::lmo


// nop - see rdcr 0, r0


void::function::do_or:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
	*rDest = Source1 | Source2;


// or, or.tt
31.Dest,26.Source2,21.0b0010111,14.UnsignedImmediate::::or.tt i
	do_or (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b110010111,12.0,11./,4.Source1::::or.tt r
	do_or (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b110010111,12.1,11./::::or.tt l
	long_immediate (LongUnsignedImmediate);
	do_or (_SD, rDest, LongUnsignedImmediate, rSource2);


// or.ff
31.Dest,26.Source2,21.0b0011110,14.UnsignedImmediate::::or.ff i
	do_or (_SD, rDest, ~vSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011110,12.0,11./,4.Source1::::or.ff r
	do_or (_SD, rDest, ~rSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011110,12.1,11./::::or.ff l
	long_immediate (LongUnsignedImmediate);
	do_or (_SD, rDest, ~LongUnsignedImmediate, ~rSource2);


// or.ft
31.Dest,26.Source2,21.0b0011101,14.UnsignedImmediate::::or.ft i
	do_or (_SD, rDest, ~vSource1, rSource2);
31.Dest,26.Source2,21.0b110011101,12.0,11./,4.Source1::::or.ft r
	do_or (_SD, rDest, ~rSource1, rSource2);
31.Dest,26.Source2,21.0b110011101,12.1,11./::::or.ft l
	long_immediate (LongUnsignedImmediate);
	do_or (_SD, rDest, ~LongUnsignedImmediate, rSource2);


// or.tf
31.Dest,26.Source2,21.0b0011011,14.UnsignedImmediate::::or.tf i
	do_or (_SD, rDest, vSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011011,12.0,11./,4.Source1::::or.tf r
	do_or (_SD, rDest, rSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011011,12.1,11./::::or.tf l
	long_immediate (LongUnsignedImmediate);
	do_or (_SD, rDest, LongUnsignedImmediate, ~rSource2);


// rdcr
void::function::do_rdcr:unsigned32 Dest, int cr
	if (Dest != 0)
	  engine_error (SD, CPU, cia, "rdcr unimplement");
31.Dest,26.0,21.0b0000100,14.UCRN::::rdcr i
	do_rdcr (_SD, Dest, UCRN);
31.Dest,26.0,21.0b110000100,12.0,11./,4.INDCR::::rdcr r
	do_rdcr (_SD, Dest, UCRN);
31.Dest,26.0,21.0b110000100,12.1,11./::::rdcr l
	long_immediate (UnsignedControlRegisterNumber);
	do_rdcr (_SD, Dest, UnsignedControlRegisterNumber);


// rmo
31.Dest,26.Source,21.0b111111001,12.0,11./::::rmo


// rotl - see sl.dz


//rotr - see sl.dz


// shl - see sl.iz


// sl.{d|e|i}{m|s|z}
void::function::do_shift:int Dest, int Source, int Merge, int i, int n, int EndMask, int Rotate
	/* see 10-30 for a reasonable description */
	unsigned32 rotated;
	unsigned32 endmask;
	unsigned32 shiftmask;
	unsigned32 cm;
	int nRotate;
	/* rotate the source */
	if (n)
	  {
	    rotated = ROTR32 (GPR (Source), Rotate);
	    nRotate = (- Rotate) & 31;
	  }
	else
	  {
	    rotated = ROTL32 (GPR (Source), Rotate);
	    nRotate = Rotate;
	  }
	/* form the end mask */
	if (EndMask == 0)
	  endmask = -1;
	else
	  endmask = (1 << EndMask) - 1;
	if (i)
	  endmask = ~endmask;
	/* form the shiftmask */
	switch (Merge)
	  {
	  case 0: case 1: case 2:
	    shiftmask = -1; /* disabled */
	    break;
	  case 3: case 4: case 5:
	    shiftmask = ((1 << nRotate) - 1); /* enabled */
	    break;
	  case 6: case 7:
	    shiftmask = ~((1 << nRotate) - 1); /* inverted */
	    break;
	  default:
	    engine_error (SD, CPU, cia,
	                  "0x%lx: Invalid merge (%d) for shift",
	                  cia.ip, Source);
	    shiftmask = 0;
	  }
	/* and the composite mask */
	cm = shiftmask & endmask;
	/* and merge */
	switch (Merge)
	  {
	  case 0: case 3: case 6: /* zero */
	    GPR (Dest) = rotated & cm;
	    break;
	  case 1: case 4: case 7: /* merge */
	    GPR (Dest) = (rotated & cm) | (GPR (Dest) & ~cm);
	    break;
	  case 2: case 5: /* sign */
	    {
	      int b;
	      GPR (Dest) = rotated & cm;
	      for (b = 1; b <= 31; b++)
	        if (!MASKED32 (cm, b, b))
	          GPR (Dest) |= INSERTED32 (EXTRACTED32 (GPR (Dest), b - 1, b - 1),
	                                    b, b);
	    }
	    break;
	  default:
	    engine_error (SD, CPU, cia,
	                  "0x%lx: Invalid merge (%d)",
	                  cia.ip, Source);

	  }
31.Dest,26.Source,21.0b0001,17.Merge,14./,11.i,10.n,9.EndMask,4.Rotate::::sl i
	do_shift (_SD, Dest, Source, Merge, i, n, EndMask, Rotate);
31.Dest,26.Source,21.0b110001,15.Merge,12.0,11.i,10.n,9.EndMask,4.RotReg::::sl r
	int endmask;
	if (EndMask == 0)
	  endmask = EndMask;
	else
	  {
	    if (Source & 1)
	      engine_error (SD, CPU, cia,
	                    "0x%lx: Invalid source (%d) for shift",
	                    cia.ip, Source);
	    endmask = GPR (Source + 1) & 31;
	  }
	do_shift (_SD, Dest, Source, Merge, i, n, endmask, GPR (RotReg) & 31);


// sli.{d|e|i}{m|s|z}
#31.Dest,26.Source,21.0b0001,17.Merge,14./,11.1,10.0,9.EndMask,4.Rotate::::sli i
#31.Dest,26.Source,21.0b110001,15.Merge,12.0,11.1,10.0,9.EndMask,4.RotReg::::sli r


// sr.{d|e|i}{m|s|z}
#31.Dest,26.Source,21.0b0001,17.Merge,14./,11.0,10.1,9.EndMask,4.Rotate::::sr i
#31.Dest,26.Source,21.0b110001,15.Merge,12.0,11.0,10.1,9.EndMask,4.RotReg::::sr r


// sra - see sr.es


// sri.{d|e|i}{m|s|z}
#31.Dest,26.Source,21.0b0001,17.Merge,14./,11.1,10.1,9.EndMask,4.Rotate::::sri i
#31.Dest,26.Source,21.0b110001,15.Merge,12.0,11.1,10.1,9.EndMask,4.RotReg::::sri r


// srl - see sr.ez


// st[{.b|.h|.d}]
void::function::do_st:int Source, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	unsigned32 addr;
	switch (sz)
	  {
	  case 0:
	    addr = Base + (S ? (Offset << 0) : Offset);
	    STORE (addr, 1, GPR(Source));
	    break;
	  case 1:
	    addr = Base + (S ? (Offset << 1) : Offset);
	    STORE (addr, 2, GPR(Source));
	    break;
	  case 2:
	    addr = Base + (S ? (Offset << 2) : Offset);
	    STORE (addr, 4, GPR(Source));
	    break;
	  case 3:
	    if (Source & 0x1)
	      engine_error (SD, CPU, cia, "0x%lx: st.d with odd source register %d",
	                    cia.ip, Source);
	    addr = Base + (S ? (Offset << 3) : Offset);
	    STORE (addr, 8, *(unsigned64*)&GPR(Source));
	    break;
	  default:
	    addr = -1;
	    engine_error (SD, CPU, cia, "st - invalid sz %d", sz);
	  }
	if (m)
	  *rBase = addr;
31.Source,26.Base,21.0b0110,17.m,16.sz,14.SignedOffset::::st i
	do_st (_SD, Source, rBase, &GPR(Base), m, sz, 0, vSignedOffset);
31.Source,26.Base,21.0b110110,15.m,14.sz,12.0,11.S,10.0,9./,4.IndOff::::st r
	do_st (_SD, Source, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Source,26.Base,21.0b110110,15.m,14.sz,12.1,11.S,10.0,9./::::st l
	long_immediate (LongSignedImmediateOffset);
	do_st (_SD, Source, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// sub
void::function::do_sub:signed32 *rDest, signed32 Source1, signed32 Source2
	ALU_BEGIN (Source1);
	ALU_SUB (Source2);
	ALU_END (*rDest);	
31.Dest,26.Source2,21.0b101101,15.0,14.SignedImmediate::::sub i
	do_sub (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b11101101,13.0,12.0,11./,4.Source1::::sub r
	do_sub (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b11101101,13.0,12.1,11./::::sub l
	long_immediate (LongSignedImmediate);
	do_sub (_SD, rDest, LongSignedImmediate, rSource2);


// subu
void::function::do_subu:signed32 *rDest, signed32 Source1, signed32 Source2
	*rDest = Source1 - Source2;
// NOTE - the book has 15.1 which conflicts with subu.
31.Dest,26.Source2,21.0b101101,15.1,14.SignedImmediate::::subu i
	do_subu (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b11101101,13.1,12.0,11./,4.Source1::::subu r
	do_subu (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b11101101,13.1,12.1,11./::::subu l
	long_immediate (LongSignedImmediate);
	do_subu (_SD, rDest, LongSignedImmediate, rSource2);


// swcr
#void::function::do_swcr:signed32 *rDest, signed32 Source1, signed32 Source2
31.Dest,26.Source,21.0b000010,15.1,14.SignedImmediate::::swcr i
#	do_swcr (_SD, rDest, SI, rSource2);
31.Dest,26.Source,21.0b11000010,13.1,12.0,11./,4.INDCR::::swcr r
#	do_swcr (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source,21.0b11000010,13.1,12.1,11./::::swcr l
#	do_swcr (_SD, rDest, LongSignedImmediate, rSource2);


// trap
void::function::do_trap:unsigned32 trap_number
	switch (trap_number)
	  {
	  case 72:
	    switch (GPR(15))
	      {
	      case 1: /* EXIT */
	        {
	          engine_halt (SD, CPU, cia, sim_exited, GPR(2));
	          break;
	        }
	      case 4: /* WRITE */
	        {
	          int i;
	          if (GPR(2) != 1)
	            engine_error (SD, CPU, cia,
	                          "0x%lx: write to invalid fid %d",
	                          (unsigned long) cia.ip, GPR(2));
		  for (i = 0; i < GPR(6); i++)
	            {
		      char c;
		      c = MEM (unsigned, GPR(4) + i, 1);
	              sim_io_write_stdout (SD, &c, 1);
	            }
	          GPR(2) = GPR(6);
	          break;
	        }
	      default:
	        engine_error (SD, CPU, cia,
	                      "0x%lx: unknown syscall %d",
	                      (unsigned long) cia.ip, GPR(15));
	      }
	    break;
	  case 73:
	    engine_halt (SD, CPU, cia, sim_stopped, SIGTRAP);
	  default:
	    engine_error (SD, CPU, cia,
	                  "0x%lx: unsupported trap %d",
	                  (unsigned long) cia.ip, trap_number);
	  }
31./,27.0,26./,21.0b0000001,14.UTN::::trap i
	do_trap (_SD, UTN);
31./,27.0,26./,21.0b110000001,12.0,11./,4.INDTR::::trap r
	do_trap (_SD, UTN);
31./,27.0,26./,21.0b110000001,12.1,11./::::trap l
	long_immediate (UTN);
	do_trap (_SD, UTN);


// vadd.{s|d}{s|d}
31.*,26.Dest,21.0b11110,16./,15.0b000,12.0,11./,10.*,9.*,7.PD,6.*,5.P1,4.Source::::vadd r
31.*,26.Dest,21.0b11110,16./,15.0b000,12.1,11./,10.*,9.*,7.PD,6.*,5.P1,4.Source::::vadd l


// vld{0|1}.{s|d} - see above - same instruction
#31.Dest,26.*,21.0b11110,16.*,10.1,9.S,8.*,6.p,7.******::::vld


// vmac.ss{s|d}
#31.*,   26.Source2,21.0b11110,16.a0,15.0b110,12.0,11.a1,10.*,9.*, 8.Z,7./,6.*,5./,4.Source1::::vmac.ss ra
31.Dest,26.Source2,21.0b11110,16.a0,15.0b110,12.0,11.a1,10.0,9.PD,8.Z,7./,6.0,5./,4.Source1::::vmac.ss rr
#31.*,   26.Source2,21.0b11110,16.a0,15.0b110,12.1,11.a1,10.*,9.*, 8.Z,7./,6.*,5./,4./::::vmac.ss ia
31.Dest,26.Source2,21.0b11110,16.a0,15.0b110,12.1,11.a1,10.0,9.PD,8.Z,7./,6.0,5./,4./::::vmac.ss ir


// vmpy.{s|d}{s|d}
31.*,26.Dest,21.0b11110,16./,15.0b010,12.0,11./,10.*,8.*,7.PD,6.*,5.P1,4.Source::::vmpy r
31.*,26.Dest,21.0b11110,16./,15.0b010,12.1,11./,10.*,8.*,7.PD,6.*,5.P1,4./::::vmpy l


// vmsc.ss{s|d}
#31.*,   26.Source2,21.0b11110,16.a0,15.0b111,12.0,11.a1,10.*,9.*, 8.Z,7./,6.*,5./,4.Source1::::vmsc.ss ra
31.Dest,26.Source2,21.0b11110,16.a0,15.0b111,12.0,11.a1,10.0,9.PD,8.Z,7./,6.0,5./,4.Source1::::vmsc.ss rr
#31.*,   26.Source2,21.0b11110,16.a0,15.0b111,12.1,11.a1,10.*,9.*, 8.Z,7./,6.*,5./,4./::::vmsc.ss ia
31.Dest,26.Source2,21.0b11110,16.a0,15.0b111,12.1,11.a1,10.0,9.PD,8.Z,7./,6.0,5./,4./::::vmsc.ss ir


// vmsub.{s|d}{s|d}
31.*,26.Dest,21.0b11110,16.a0,15.0b011,12.0,11.a1,10.*,8.Z,7.PD,6.*,5./,4.Source::::vmsub r
31.*,26.Dest,21.0b11110,16.a0,15.0b011,12.1,11.a1,10.*,8.Z,7.PD,6.*,5./,4./::::vmsub l


// vrnd.{s|d}{s|d}
31.*,26.Dest,21.0b11110,16.a0,15.0b100,12.0,11.a1,10.*,8.PD,6.*,5.P1,4.Source::::vrnd f r
31.*,26.Dest,21.0b11110,16.a0,15.0b100,12.1,11.a1,10.*,8.PD,6.*,5.P1,4./::::vrnd f l


// vrnd.{i|u}{s|d}
31.*,26.Dest,21.0b11110,16./,15.0b101,12.0,11./,10.*,8./,7.PD,6.*,5.P1,4.Source::::vrnd i r
31.*,26.Dest,21.0b11110,16./,15.0b101,12.1,11./,10.*,8./,7.PD,6.*,5.P1,4./::::vrnd i l


// vst.{s|d} - see above - same instruction
#31.Source,26.*,21.0b11110,16.*,10.0,9.S,8.*,6.1,5.*::::vst


// vsub.{i|u}{s|d}
31.*,26.Dest,21.0b11110,16./,15.0b001,12.0,11./,10.*,8./,7.PD,6.*,5.P1,4.Source::::vsub r
31.*,26.Dest,21.0b11110,16./,15.0b001,12.1,11./,10.*,8./,7.PD,6.*,5.P1,4./::::vsub l


// wrcr - see swcr, creg, source, r0


// xnor
void::function::do_xnor:signed32 *rDest, signed32 Source1, signed32 Source2
	*rDest = ~ (Source1 ^ Source2);
31.Dest,26.Source2,21.0b0011001,14.UnsignedImmediate::::xnor i
	do_xnor (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b110011001,12.0,11./,4.Source1::::xnor r
	do_xnor (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b110011001,12.1,11./::::xnor l
	long_immediate (LongUnsignedImmediate);
	do_xnor (_SD, rDest, LongUnsignedImmediate, rSource2);


// xor
void::function::do_xor:signed32 *rDest, signed32 Source1, signed32 Source2
	*rDest = Source1 ^ Source2;
31.Dest,26.Source2,21.0b0010110,14.UnsignedImmediate::::xor i
	do_xor (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b110010110,13.0,12.0,11./,4.Source1::::xor r
	do_xor (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b110010110,13.0,12.1,11./::::xor l
	long_immediate (LongUnsignedImmediate);
	do_xor (_SD, rDest, LongUnsignedImmediate, rSource2);
