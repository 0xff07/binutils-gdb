// Texas Instruments TMS320C80 (MVP) Simulator.
// Copyright (C) 1997 Free Software Foundation, Inc.
// Contributed by Cygnus Support.
// 
// This file is part of GDB, the GNU debugger.
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */


// The following is called when ever an illegal instruction is encountered.
::internal::illegal
	engine_error (SD, CPU, cia, "illegal instruction at 0x%lx", cia.ip);
// The following is called when ever an FP op is attempted with FPU disabled.
::internal::fp_unavailable
	engine_error (SD, CPU, cia, "floating-point unavailable at 0x%lx", cia.ip);

// Signed Integer Add - add source1, source2, dest
void::function::do_add:signed32 *rDest, signed32 Source1, signed32 Source2
	ALU_BEGIN (Source1);
	ALU_ADD (Source2);
	ALU_END (*rDest);
	TRACE_ALU3 (MY_INDEX, *rDest, Source1, Source2);
	/* FIXME - a signed add may cause an exception */
31.Dest,26.Source2,21.0b101100,15.0,14.SignedImmediate::::add i
	do_add (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b11101100,13.0,12.0,11./,4.Source1::::add r
	do_add (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b11101100,13.0,12.1,11./::::add l
	long_immediate (LongSignedImmediate);
	do_add (_SD, rDest, LongSignedImmediate, rSource2);


// Unsigned Integer Add - addu source1, source2, dest
void::function::do_addu:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
	unsigned32 result = Source1 + Source2;
	TRACE_ALU3 (MY_INDEX, result, Source1, Source2);
	*rDest = result;

31.Dest,26.Source2,21.0b101100,15.1,14.SignedImmediate::::addu i
	do_addu (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b11101100,13.1,12.0,11./,4.Source1::::addu r
	do_addu (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b11101100,13.1,12.1,11./::::addu l
	long_immediate (LongSignedImmediate);
	do_addu (_SD, rDest, LongSignedImmediate, rSource2);


void::function::do_and:signed32 *rDest, signed32 Source1, signed32 Source2
	unsigned32 result = Source1 & Source2;
	TRACE_ALU3 (MY_INDEX, result, Source1, Source2);
	*rDest = result;


// and, and.tt
31.Dest,26.Source2,21.0b0010001,14.UnsignedImmediate::::and.tt i
	do_and (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b110010001,12.0,11./,4.Source1::::and.tt r
	do_and (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b110010001,12.1,11./::::and.tt l
	long_immediate (LongSignedImmediate);
	do_and (_SD, rDest, LongSignedImmediate, rSource2);


// and.ff
31.Dest,26.Source2,21.0b0011000,14.UnsignedImmediate::::and.ff i
	do_and (_SD, rDest, ~vSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011000,12.0,11./,4.Source1::::and.ff r
	do_and (_SD, rDest, ~rSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011000,12.1,11./::::and.ff l
	long_immediate (LongSignedImmediate);
	do_and (_SD, rDest, ~LongSignedImmediate, ~rSource2);


// and.ft
31.Dest,26.Source2,21.0b0010100,14.UnsignedImmediate::::and.ft i
	do_and (_SD, rDest, ~vSource1, rSource2);
31.Dest,26.Source2,21.0b110010100,12.0,11./,4.Source1::::and.ft r
	do_and (_SD, rDest, ~rSource1, rSource2);
31.Dest,26.Source2,21.0b110010100,12.1,11./::::and.ft l
	long_immediate (LongSignedImmediate);
	do_and (_SD, rDest, ~LongSignedImmediate, rSource2);


// and.tf
31.Dest,26.Source2,21.0b0010010,14.UnsignedImmediate::::and.tf i
	do_and (_SD, rDest, vSource1, ~rSource2);
31.Dest,26.Source2,21.0b110010010,12.0,11./,4.Source1::::and.tf r
	do_and (_SD, rDest, rSource1, ~rSource2);
31.Dest,26.Source2,21.0b110010010,12.1,11./::::and.tf l
	long_immediate (LongSignedImmediate);
	do_and (_SD, rDest, LongSignedImmediate, ~rSource2);


// bbo.[a]
instruction_address::function::do_bbo:instruction_address nia, int bitnum, unsigned32 source, int annul, unsigned32 offset
	int jump_p;
	unsigned32 target = cia.ip + 4 * offset;
	bitnum = (~ bitnum) & 0x1f;
	if (MASKED32 (source, bitnum, bitnum))
	  {
	    if (annul)
	      nia.ip = -1;
	    nia.dp = target;
	    jump_p = 1;
	  }
	else
	  jump_p = 0;
	TRACE_COND_BR(MY_INDEX, jump_p, bitnum, target);
	return nia;
31.BITNUM,26.Source,21.0b100101,15.A,14.SignedOffset::::bbo i
	nia = do_bbo (_SD, nia, BITNUM, rSource, A, vSignedOffset);
31.BITNUM,26.Source,21.0b11100101,13.A,12.0,11./,4.IndOff::::bbo r
	nia = do_bbo (_SD, nia, BITNUM, rSource, A, rIndOff);
31.BITNUM,26.Source,21.0b11100101,13.A,12.1,11./::::bbo l
	long_immediate (LongSignedImmediate);
	nia = do_bbo (_SD, nia, BITNUM, rSource, A, LongSignedImmediate);


// bbz[.a]
instruction_address::function::do_bbz:instruction_address nia, int bitnum, unsigned32 source, int annul, unsigned32 offset
	int jump_p;
	unsigned32 target = cia.ip + 4 * offset;
	bitnum = (~ bitnum) & 0x1f;
	if (!MASKED32 (source, bitnum, bitnum))
	  {
	    if (annul)
	      nia.ip = -1;
	    nia.dp = target;
	    jump_p = 1;
	  }
	else
	  jump_p = 0;
	TRACE_COND_BR(MY_INDEX, jump_p, bitnum, target);
	return nia;
31.BITNUM,26.Source,21.0b100100,15.A,14.SignedOffset::::bbz i
	nia = do_bbz (_SD, nia, BITNUM, rSource, A, vSignedOffset);
31.BITNUM,26.Source,21.0b11100100,13.A,12.0,11./,4.IndOff::::bbz r
	nia = do_bbz (_SD, nia, BITNUM, rSource, A, rIndOff);
31.BITNUM,26.Source,21.0b11100100,13.A,12.1,11./::::bbz l
	long_immediate (LongSignedImmediate);
	nia = do_bbz (_SD, nia, BITNUM, rSource, A, LongSignedImmediate);


// bcnd[.a]
instruction_address::function::do_bcnd:instruction_address nia, int Cond, unsigned32 source, int annul, unsigned32 offset
	int condition;
	int size = EXTRACTED32 (Cond, 31 - 27, 30 - 27);
	int code = EXTRACTED32 (Cond, 29 - 27, 27 - 27);
	signed32 val = 0;
	unsigned32 target = cia.ip + 4 * offset;
	switch (size)
	  {
	  case 0: val = SEXT32 (source, 7); break;
	  case 1: val = SEXT32 (source, 15); break;
	  case 2: val = source; break;
	  default: engine_error (SD, CPU, cia, "bcnd - reserved size");
	  }
	switch (code)
	  {
	  case 0: condition = 0; break;
	  case 1: condition = val > 0; break;
	  case 2: condition = val == 0; break;
	  case 3: condition = val >= 0; break;
	  case 4: condition = val < 0; break;
	  case 5: condition = val != 0; break;
	  case 6: condition = val <= 0; break;
	  default: condition = 1; break;
	  }
	if (condition)
	  {
	    if (annul)
	      nia.ip = -1;
	    nia.dp = target;
	  }
	TRACE_COND_BR(MY_INDEX, condition, source, target);
	return nia;
31.Code,26.Source,21.0b100110,15.A,14.SignedOffset::::bcnd i
	nia = do_bcnd (_SD, nia, Code, rSource, A, vSignedOffset);
31.Code,26.Source,21.0b11100110,13.A,12.0,11./,4.IndOff::::bcnd r
	nia = do_bcnd (_SD, nia, Code, rSource, A, rIndOff);
31.Code,26.Source,21.0b11100110,13.A,12.1,11./::::bcnd l
	long_immediate (LongSignedImmediate);
	nia = do_bcnd (_SD, nia, Code, rSource, A, LongSignedImmediate);


// br[.a] - see bbz[.a]


// brcr
sim_cia::function::do_brcr:instruction_address nia, int cr
	if (cr >= 0x4000 || !(CPU)->is_user_mode)
	  {
	    unsigned32 control = CR (cr);
	    unsigned32 ie = control & 0x00000001;
	    unsigned32 pc = control & 0xfffffffc;
	    unsigned32 is_user_mode = control & 0x00000002;
	    (CPU)->is_user_mode = is_user_mode;
	    nia.dp = pc;
	    if (ie)
	      (CPU)->cr[IE_CR] |= IE_CR_IE;
	    else
	      (CPU)->cr[IE_CR] &= ~IE_CR_IE;
	  }
	TRACE_UCOND_BR (MY_INDEX, nia.dp);
	return nia;
31.//,27.0,26.//,21.0b0000110,14.UCRN::::brcr i
	nia = do_brcr (_SD, nia, UCRN);
31.//,27.0,26.//,21.0b110000110,12.0,11./,4.INDCR::::brcr r
	nia = do_brcr (_SD, nia, UCRN);
31.//,27.0,26.//,21.0b110000110,12.1,11./::::brcr l
	long_immediate (UnsignedControlRegisterNumber)
	nia = do_brcr (_SD, nia, UnsignedControlRegisterNumber);


// bsr[.a]
instruction_address::function::do_bsr:instruction_address nia, signed32 *rLink, int annul, unsigned32 offset
	if (annul)
	  {
	    *rLink = nia.ip;
	    nia.ip = -1;
	  }
	else
	  *rLink = nia.ip + sizeof (instruction_word);
	nia.dp = cia.ip + 4 * offset;
	TRACE_UCOND_BR (MY_INDEX, nia.dp);
	return nia;
31.Link,26./,21.0b100000,15.A,14.SignedOffset::::bsr i
	nia = do_bsr (_SD, nia, rLink, A, vSignedOffset);
31.Link,26./,21.0b11100000,13.A,12.0,11./,4.IndOff::::bsr r
	nia = do_bsr (_SD, nia, rLink, A, rIndOff);
31.Link,26./,21.0b11100000,13.A,12.1,11./::::bsr l
	long_immediate (LongSignedImmediate);
	nia = do_bsr (_SD, nia, rLink, A, LongSignedImmediate);


// cmnd
void::function::do_cmnd:signed32 source
	int Reset = EXTRACTED32 (source, 31, 31);
	int Halt = EXTRACTED32 (source, 30, 30);
	int Unhalt = EXTRACTED32 (source, 29, 29);
	/* int ICR = EXTRACTED32 (source, 28, 28); */
	/* int DCR = EXTRACTED32 (source, 27, 27); */
	int Task = EXTRACTED32 (source, 14, 14);
	int Msg = EXTRACTED32 (source, 13, 13);
	int VC = EXTRACTED32 (source, 10, 10);
	int TC = EXTRACTED32 (source, 9, 9);
	int MP = EXTRACTED32 (source, 8, 8);
	int PP = EXTRACTED32 (source, 3, 0);
	/* what is implemented? */
	if (PP != 0)
	  engine_error (SD, CPU, cia, "0x%lx: cmnd - PPs not supported",
	                (unsigned long) cia.ip);
	if (VC != 0)
	  engine_error (SD, CPU, cia, "0x%lx: cmnd - VC not supported",
	                (unsigned long) cia.ip);
	if (TC != 0)
	  engine_error (SD, CPU, cia, "0x%lx: cmnd - TC not supported",
	                (unsigned long) cia.ip);
	if (MP)
	  {
	    if (Reset || Halt)
	      engine_halt (SD, CPU, cia, sim_exited, 0);
	    if (Unhalt)
	      engine_error (SD, CPU, cia, "0x%lx: cmnd - Can not unhalt the MP",
	                    (unsigned long) cia.ip);
	    /* if (ICR || DCR); */
	    if (Task)
	      engine_error (SD, CPU, cia, "0x%lx: cmnd - Can not Task the MP",
	                    (unsigned long) cia.ip);
	    if (Msg)
	      engine_error (SD, CPU, cia, "0x%lx: cmnd - Msg to MP not suported",
	                    (unsigned long) cia.ip);
	  }
	TRACE_SINK1 (MY_INDEX, source);
31./,21.0b0000010,14.UI::::cmnd i
	do_cmnd (_SD, UI);
31./,21.0b110000010,12.0,11./,4.Source::::cmnd r
	do_cmnd (_SD, rSource);
31./,21.0b110000010,12.1,11./::::cmnd l
	long_immediate (LongUnsignedImmediate);
	do_cmnd (_SD, LongUnsignedImmediate);

// cmp
unsigned32::function::cmp_vals:signed32 s1, unsigned32 u1, signed32 s2, unsigned32 u2
	unsigned32 field = 0;
	if (s1 == s2) field |= 0x001;
	if (s1 != s2) field |= 0x002;
	if (s1 >  s2) field |= 0x004;
	if (s1 <= s2) field |= 0x008;
	if (s1 <  s2) field |= 0x010;
	if (s1 >= s2) field |= 0x020;
	if (u1 >  u2) field |= 0x040;
	if (u1 <= u2) field |= 0x080;
	if (u1 <  u2) field |= 0x100;
	if (u1 >= u2) field |= 0x200;
	return field;
void::function::do_cmp:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
	unsigned32 field = 0;
	field |= cmp_vals (_SD, Source1, Source1, Source2, Source2) << 20;
	field |= cmp_vals (_SD, (signed16)Source1, (unsigned16)Source1,
			   (signed16)Source2, (unsigned16)Source2) << 10;
	field |= cmp_vals (_SD, (signed8)Source1, (unsigned8)Source1,
			    (signed8)Source2, (unsigned8)Source2);
	TRACE_ALU3 (MY_INDEX, field, Source1, Source2);
	*rDest = field;
31.Dest,26.Source2,21.0b1010000,14.SignedImmediate::::cmp i
	do_cmp (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b111010000,12.0,11./,4.Source1::::cmp r
	do_cmp (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111010000,12.1,11./::::cmp l
	long_immediate (LongSignedImmediate);
	do_cmp (_SD, rDest, LongSignedImmediate, rSource2);


// dcache
31./,27.F,26.Source2,21.0b0111,17.M,16.0b00,14.SignedOffset::::dcache i
	TRACE_NOP (MY_INDEX);
	/* NOP */
31./,27.F,26.Source2,21.0b110111,15.M,14.0b00,12.0,11./,4.Source1::::dcache r
	TRACE_NOP (MY_INDEX);
	/* NOP */
31./,27.F,26.Source2,21.0b110111,15.M,14.0b00,12.1,11./::::dcache l
	long_immediate (LongSignedImmediate);
	LongSignedImmediate++;
	TRACE_NOP (MY_INDEX);
	/* NOP */


// dld[{.b|.h|.d}]
void::function::do_dld:int Dest, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	do_ld (_SD, Dest, Base, rBase, m, sz, S, Offset);
31.Dest,26.Base,21.0b110100,15.m,14.sz,12.0,11.S,10.1,9./,4.IndOff::::dld r
	do_dld (_SD, Dest, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Dest,26.Base,21.0b110100,15.m,14.sz,12.1,11.S,10.1,9./::::dld l
	long_immediate (LongSignedImmediateOffset);
	do_dld (_SD, Dest, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// dld.u[{.b|.h|.d}]
void::function::do_dld_u:unsigned32 *rDest, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	do_ld_u (_SD, rDest, Base, rBase, m, sz, S, Offset);
31.Dest,26.Base,21.0b110101,15.m,14.sz,12.0,11.S,10.1,9./,4.IndOff::::dld.u r
	do_dld_u (_SD, rDest, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Dest,26.Base,21.0b110101,15.m,14.sz,12.1,11.S,10.1,9./::::dld.u l
	long_immediate (LongSignedImmediateOffset);
	do_dld_u (_SD, rDest, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// dst[{.b|.h|.d}]
void::function::do_dst:int Source, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	do_st (_SD, Source, Base, rBase, m, sz, S, Offset);
31.Source,26.Base,21.0b110110,15.m,14.sz,12.0,11.S,10.1,9./,4.IndOff::::dst r
	do_dst (_SD, Source, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Source,26.Base,21.0b110110,15.m,14.sz,12.1,11.S,10.1,9./::::dst l
	long_immediate (LongSignedImmediateOffset);
	do_dst (_SD, Source, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// estop
31./,21.0b1111111,14.1,13.0,12.0,11./::::estop

// etrap
31./,27.1,26./,21.0b0000001,14.UTN::::etrap i
31./,27.1,26./,21.0b110000001,12.0,11./,4.iUTN::::etrap r
31./,27.1,26./,21.0b110000001,12.1,11./::::etrap l


// exts - see shift.ds


// extu - see shift.dz


sim_fpu::function::get_fp_reg:int reg, unsigned32 val, int precision
	switch (precision)
	  {
	  case 0: /* single */
	    if (reg == 0)
	      return sim_fpu_32to (0);
	    else
	      return sim_fpu_32to (val);
	  case 1: /* double */
	    if (reg < 0)
	      return sim_fpu_32to (val);
	    if (reg & 1)
	      engine_error (SD, CPU, cia, "DP FP register must be even");
	    if (reg <= 1)
	      engine_error (SD, CPU, cia, "DP FP register must be >= 2");
	    return sim_fpu_64to (INSERTED64 (GPR(reg + 1), 63, 32)
	                         | INSERTED64 (GPR(reg), 31, 0));
	  case 2: /* 32 bit signed integer */
	    if (reg == 0)
	      return sim_fpu_32to (0);
	    else	    
	      return sim_fpu_d2 ((signed32) val);
	  case 3: /* 32 bit unsigned integer */
	    if (reg == 0)
	      return sim_fpu_32to (0);
	    else	    
	      return sim_fpu_d2 ((unsigned32) val);
	  default:
	    engine_error (SD, CPU, cia, "Unsupported FP precision");
	  }
	return sim_fpu_32to (0);
void::function::set_fp_reg:int Dest, sim_fpu val, int PD
	switch (PD)
	  {
	  case 0: /* single */
	    {
	      GPR (Dest) = sim_fpu_to32 (val);
	      break;
	    }
	  case 1: /* double */
	    {
	      unsigned64 v = *(unsigned64*) &val;
	      if (Dest & 1)
	        engine_error (SD, CPU, cia, "DP FP Dest register must be even");
	      if (Dest <= 1)
	        engine_error (SD, CPU, cia, "DP FP Dest register must be >= 2");
	      GPR (Dest) = EXTRACTED64 (v, 21, 0);
	      GPR (Dest + 1) = EXTRACTED64 (v, 63, 32);
	      break;
	    }
	  case 2: /* signed */
	    /* FIXME - rounding */
	    GPR (Dest) = sim_fpu_2d (val);
	    break;
	  case 3: /* unsigned */
	    /* FIXME - rounding */
	    GPR (Dest) = sim_fpu_2d (val);
	    break;
	  default:
	    engine_error (SD, CPU, cia, "Unsupported FP precision");
	  }

// fadd.{s|d}{s|d}{s|d}
void::function::do_fadd:int Dest, int PD, sim_fpu s1, sim_fpu s2
	sim_fpu ans = sim_fpu_add (s1, s2);
	TRACE_FPU3 (MY_INDEX, ans, s1, s2);
	set_fp_reg (_SD, Dest, ans, PD);
31.Dest,26.Source2,21.0b111110000,12.0,11.r,10.PD,8.P2,6.P1,4.Source1::f::fadd r
	do_fadd (_SD, Dest, PD,
	         get_fp_reg (_SD, Source1, rSource1, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));
31.Dest,26.Source2,21.0b111110000,12.1,11.r,10.PD,8.P2,6.P1,4./::f::fadd l
	long_immediate (SinglePrecisionFloatingPoint);
	do_fadd (_SD, Dest, PD,
	         get_fp_reg (_SD, -1, SinglePrecisionFloatingPoint, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));


// fcmp.{s|d}{s|d}{s|d}
void::function::do_fcmp:unsigned32 *rDest, sim_fpu s1, sim_fpu s2
	*rDest = 0;
	if (sim_fpu_is_nan (s1) || sim_fpu_is_nan (s2))
	  *rDest |= BIT32 (30);
	else
	  {
	    *rDest |= BIT32 (31);
	    if (sim_fpu_cmp (s1, s2) == 0) *rDest |= BIT32(20);
	    if (sim_fpu_cmp (s1, s2) != 0) *rDest |= BIT32(21);
	    if (sim_fpu_cmp (s1, s2) >  0) *rDest |= BIT32(22);
	    if (sim_fpu_cmp (s1, s2) <= 0) *rDest |= BIT32(23);
	    if (sim_fpu_cmp (s1, s2) <  0) *rDest |= BIT32(24);
	    if (sim_fpu_cmp (s1, s2) >= 0) *rDest |= BIT32(25);
	    if (sim_fpu_cmp (s1, sim_fpu_32to (0)) < 0
	        || sim_fpu_cmp (s1, s2) > 0) *rDest |= BIT32(26);
	    if (sim_fpu_cmp (sim_fpu_32to (0), s1) < 0
	        && sim_fpu_cmp (s1, s2) < 0) *rDest |= BIT32(27);
	    if (sim_fpu_cmp (sim_fpu_32to (0), s1) <= 0
	        && sim_fpu_cmp (s1, s2) <= 0) *rDest |= BIT32(28);
	    if (sim_fpu_cmp (s1, sim_fpu_32to (0)) <= 0
	        || sim_fpu_cmp (s1, s2) >= 0) *rDest |= BIT32(29);
	  }
	TRACE_FPU2I (MY_INDEX, *rDest, s1, s2);
31.Dest,26.Source2,21.0b111110101,12.0,11./,10.0,8.P2,6.P1,4.Source1::f::fcmp r
	do_fcmp (_SD, rDest,
	         get_fp_reg (_SD, Source1, rSource1, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));
31.Dest,26.Source2,21.0b111110101,12.1,11./,10.0,8.P2,6.P1,4./::f::fcmp l
	long_immediate (SinglePrecisionFloatingPoint);
	do_fcmp (_SD, rDest,
	         get_fp_reg (_SD, -1, SinglePrecisionFloatingPoint, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));



// fdiv.{s|d}{s|d}{s|d}
void::function::do_fdiv:int Dest, int PD, sim_fpu s1, sim_fpu s2
	sim_fpu ans = sim_fpu_div (s1, s2);
	TRACE_FPU3 (MY_INDEX, ans, s1, s2);
	set_fp_reg (_SD, Dest, ans, PD);
31.Dest,26.Source2,21.0b111110011,12.0,11./,10.PD,8.P2,6.P1,4.Source1::f::fdiv r
	do_fdiv (_SD, Dest, PD,
	         get_fp_reg (_SD, Source1, rSource1, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));
31.Dest,26.Source2,21.0b111110011,12.1,11./,10.PD,8.P2,6.P1,4./::f::fdiv l
	long_immediate (SinglePrecisionFloatingPoint);
	do_fdiv (_SD, Dest, PD,
	         get_fp_reg (_SD, -1, SinglePrecisionFloatingPoint, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));


// fmpy.{s|d|i|u}{s|d|i|u}{s|d|i|u}
void::function::do_fmpy:int Dest, int PD, sim_fpu s1, sim_fpu s2
	sim_fpu ans = sim_fpu_mul (s1, s2);
	TRACE_FPU3 (MY_INDEX, ans, s1, s2);
	set_fp_reg (_SD, Dest, ans, PD);
31.Dest,26.Source2,21.0b111110010,12.0,11./,10.PD,8.P2,6.P1,4.Source1::f::fmpy r
	do_fmpy (_SD, Dest, PD,
	         get_fp_reg (_SD, Source1, rSource1, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));
31.Dest,26.Source2,21.0b111110010,12.1,11./,10.PD,8.P2,6.P1,4./::f::fmpy l
	long_immediate (SinglePrecisionFloatingPoint);
	do_fmpy (_SD, Dest, PD,
	         get_fp_reg (_SD, -1, SinglePrecisionFloatingPoint, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));


// frndm.{s|d|i|u}{s|d|i|u}{s|d|i|u}
void::function::do_frnd:int Dest, int PD, sim_fpu s1
	set_fp_reg (_SD, Dest, s1, PD);
31.Dest,26.Source2,21.0b111110100,12.0,11.r,10.PD,8.0b11,6.P1,4.Source::f::frndm r
	do_frnd (_SD, Dest, PD,
	         get_fp_reg (_SD, Source, rSource, P1));
31.Dest,26.Source2,21.0b111110100,12.1,11.r,10.PD,8.0b11,6.P1,4./::f::frndm l
	long_immediate (SinglePrecisionFloatingPoint);
	do_frnd (_SD, Dest, PD,
	         get_fp_reg (_SD, -1, SinglePrecisionFloatingPoint, P1));


// frndn.{s|d|i|u}{s|d|i|u}{s|d|i|u}
31.Dest,26.Source2,21.0b111110100,12.0,11.r,10.PD,8.0b00,6.P1,4.Source::f::frndn r
	do_frnd (_SD, Dest, PD,
	         get_fp_reg (_SD, Source, rSource, P1));
31.Dest,26.Source2,21.0b111110100,12.1,11.r,10.PD,8.0b00,6.P1,4./::f::frndn l
	long_immediate (SinglePrecisionFloatingPoint);
	do_frnd (_SD, Dest, PD,
	         get_fp_reg (_SD, -1, SinglePrecisionFloatingPoint, P1));


// frndp.{s|d|i|u}{s|d|i|u}{s|d|i|u}
31.Dest,26.Source2,21.0b111110100,12.0,11.r,10.PD,8.0b10,6.P1,4.Source::f::frndp r
	do_frnd (_SD, Dest, PD,
	         get_fp_reg (_SD, Source, rSource, P1));
31.Dest,26.Source2,21.0b111110100,12.1,11.r,10.PD,8.0b10,6.P1,4./::f::frndp l
	long_immediate (SinglePrecisionFloatingPoint);
	do_frnd (_SD, Dest, PD,
	         get_fp_reg (_SD, -1, SinglePrecisionFloatingPoint, P1));


// frndz.{s|d|i|u}{s|d|i|u}{s|d|i|u}
31.Dest,26.Source2,21.0b111110100,12.0,11.r,10.PD,8.0b01,6.P1,4.Source::f::frndz r
	do_frnd (_SD, Dest, PD,
	         get_fp_reg (_SD, Source, rSource, P1));
31.Dest,26.Source2,21.0b111110100,12.1,11.r,10.PD,8.0b01,6.P1,4./::f::frndz l
	long_immediate (SinglePrecisionFloatingPoint);
	do_frnd (_SD, Dest, PD,
	         get_fp_reg (_SD, -1, SinglePrecisionFloatingPoint, P1));


// fsqrt.{s|d}{s|d}{s|d}
#void::function::do_fsqrt:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
#	sim_io_error ("fsqrt");
31.Dest,26.Source2,21.0b111110111,12.0,11./,10.PD,8.//,6.P1,4.Source1::f::fsqrt r
#	do_fsqrt (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b111110111,12.1,11./,10.PD,8.//,6.P1,4./::f::fsqrt l
#	do_fsqrt (_SD, rDest, LongSignedImmediate, rSource2);


// fsub.{s|d}{s|d}{s|d}
void::function::do_fsub:int Dest, int PD, sim_fpu s1, sim_fpu s2
	sim_fpu ans = sim_fpu_sub (s1, s2);
	TRACE_FPU3 (MY_INDEX, ans, s1, s2);
	set_fp_reg (_SD, Dest, ans, PD);
31.Dest,26.Source2,21.0b111110001,12.0,11.r,10.PD,8.P2,6.P1,4.Source1::f::fsub r
	do_fsub (_SD, Dest, PD,
	         get_fp_reg (_SD, Source1, rSource1, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));
31.Dest,26.Source2,21.0b111110001,12.1,11.r,10.PD,8.P2,6.P1,4./::f::fsub l
	long_immediate (SinglePrecisionFloatingPoint);
	do_fsub (_SD, Dest, PD,
	         get_fp_reg (_SD, -1, SinglePrecisionFloatingPoint, P1),
	         get_fp_reg (_SD, Source2, rSource2, P2));


// illop
31./,21.0b0000000,14./::::illop
31./,21.0b111111111,12./::::illop l


// ins - see sl.im


// jsr[.a]
instruction_address::function::do_jsr:instruction_address nia, signed32 *rLink, int annul, unsigned32 offset, unsigned32 base
	TRACE_UCOND_BR (MY_INDEX, nia.ip);
	if (annul)
	  {
	    *rLink = nia.ip;
	    nia.ip = -1;
	  }
	else
	  *rLink = nia.ip + sizeof (instruction_word);
	nia.dp = offset + base;
	if (nia.dp & 0x3)
	  engine_error (SD, CPU, cia,
	                "0x%lx: destination address 0x%lx misaligned",
	                (unsigned long) cia.ip,
	                (unsigned long) nia.dp);
	return nia;
31.Link,26.Base,21.0b100010,15.A,14.SignedOffset::::jsr i
	nia = do_jsr (_SD, nia, rLink, A, vSignedOffset, rBase);
31.Link,26.Base,21.0b11100010,13.A,12.0,11./,4.Source1::::jsr r
	nia = do_jsr (_SD, nia, rLink, A, rSource1, rBase);
31.Link,26.Base,21.0b11100010,13.A,12.1,11./::::jsr l
	long_immediate (LongSignedImmediate);
	nia = do_jsr (_SD, nia, rLink, A, LongSignedImmediate, rBase);


// ld[{.b.h.d}]
void::function::do_ld:int Dest, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	unsigned32 addr;
	switch (sz)
	  {
	  case 0:
	    addr = Base + (S ? (Offset << 0) : Offset);
	    if (m)
	      *rBase = addr;
	    GPR(Dest) = MEM (signed, addr, 1);
	    break;
	  case 1:
	    addr = Base + (S ? (Offset << 1) : Offset);
	    if (m)
	      *rBase = addr;
	    GPR(Dest) = MEM (signed, addr, 2);
	    break;
	  case 2:
	    addr = Base + (S ? (Offset << 2) : Offset);
	    if (m)
	      *rBase = addr;
	    GPR(Dest) = MEM (signed, addr, 4);
	    break;
	  case 3:
	    if (Dest & 0x1)
	      engine_error (SD, CPU, cia, "0x%lx: ld.d to odd register %d",
	                    cia.ip, Dest);
	    addr = Base + (S ? (Offset << 3) : Offset);
	    if (m)
	      *rBase = addr;
	    *(unsigned64*)(&GPR(Dest)) = MEM (signed, addr, 8);
	    break;
	  default:
	    addr = -1;
	    engine_error (SD, CPU, cia, "ld - invalid sz %d", sz);
	  }
	TRACE_LD (MY_INDEX, m, S, GPR(Dest), Base, Offset);
31.Dest,26.Base,21.0b0100,17.m,16.sz,14.SignedOffset::::ld i
	do_ld (_SD, Dest, rBase, &GPR(Base), m, sz, 0, vSignedOffset);
31.Dest,26.Base,21.0b110100,15.m,14.sz,12.0,11.S,10.0,9./,4.IndOff::::ld r
	do_ld (_SD, Dest, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Dest,26.Base,21.0b110100,15.m,14.sz,12.1,11.S,10.0,9./::::ld l
	long_immediate (LongSignedImmediateOffset);
	do_ld (_SD, Dest, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// ld.u[{.b.h.d}]
void::function::do_ld_u:unsigned32 *rDest, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	unsigned32 addr;
	switch (sz)
	  {
	  case 0:
	    addr = Base + (S ? (Offset << 0) : Offset);
	    *rDest = MEM (unsigned, addr, 1);
	    break;
	  case 1:
	    addr = Base + (S ? (Offset << 1) : Offset);
	    *rDest = MEM (unsigned, addr, 2);
	    break;
	  default:
	    addr = -1;
	    engine_error (SD, CPU, cia, "ld.u - invalid sz %d", sz);
	  }
	if (m)
	  *rBase = addr;
	TRACE_LD (MY_INDEX, m, S, *rDest, Base, Offset);
31.Dest,26.Base,21.0b0101,17.m,16.sz,14.SignedOffset::::ld.u i
	do_ld_u (_SD, rDest, rBase, &GPR(Base), m, sz, 0, vSignedOffset);
31.Dest,26.Base,21.0b110101,15.m,14.sz,12.0,11.S,10.0,9./,4.IndOff::::ld.u r
	do_ld_u (_SD, rDest, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Dest,26.Base,21.0b110101,15.m,14.sz,12.1,11.S,10.0,9./::::ld.u l
	long_immediate (LongSignedImmediateOffset);
	do_ld_u (_SD, rDest, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// lmo
31.Dest,26.Source,21.111111000,12.0,11./::::lmo
	int b;
	for (b = 0; b < 32; b++)
	  if (rSource & BIT32 (31 - b))
	    break;
	TRACE_ALU2 (MY_INDEX, b, rSource);
	*rDest = b;
	

// nop - see rdcr 0, r0


void::function::do_or:unsigned32 *rDest, unsigned32 Source1, unsigned32 Source2
	unsigned32 result = Source1 | Source2;
	TRACE_ALU3 (MY_INDEX, result, Source1, Source2);
	*rDest = result;


// or, or.tt
31.Dest,26.Source2,21.0b0010111,14.UnsignedImmediate::::or.tt i
	do_or (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b110010111,12.0,11./,4.Source1::::or.tt r
	do_or (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b110010111,12.1,11./::::or.tt l
	long_immediate (LongUnsignedImmediate);
	do_or (_SD, rDest, LongUnsignedImmediate, rSource2);


// or.ff
31.Dest,26.Source2,21.0b0011110,14.UnsignedImmediate::::or.ff i
	do_or (_SD, rDest, ~vSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011110,12.0,11./,4.Source1::::or.ff r
	do_or (_SD, rDest, ~rSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011110,12.1,11./::::or.ff l
	long_immediate (LongUnsignedImmediate);
	do_or (_SD, rDest, ~LongUnsignedImmediate, ~rSource2);


// or.ft
31.Dest,26.Source2,21.0b0011101,14.UnsignedImmediate::::or.ft i
	do_or (_SD, rDest, ~vSource1, rSource2);
31.Dest,26.Source2,21.0b110011101,12.0,11./,4.Source1::::or.ft r
	do_or (_SD, rDest, ~rSource1, rSource2);
31.Dest,26.Source2,21.0b110011101,12.1,11./::::or.ft l
	long_immediate (LongUnsignedImmediate);
	do_or (_SD, rDest, ~LongUnsignedImmediate, rSource2);


// or.tf
31.Dest,26.Source2,21.0b0011011,14.UnsignedImmediate::::or.tf i
	do_or (_SD, rDest, vSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011011,12.0,11./,4.Source1::::or.tf r
	do_or (_SD, rDest, rSource1, ~rSource2);
31.Dest,26.Source2,21.0b110011011,12.1,11./::::or.tf l
	long_immediate (LongUnsignedImmediate);
	do_or (_SD, rDest, LongUnsignedImmediate, ~rSource2);


// rdcr
void::function::do_rdcr:unsigned32 Dest, int cr
	TRACE_SINK2 (MY_INDEX, Dest, cr);
	GPR (Dest) = CR (cr);
31.Dest,26.0,21.0b0000100,14.UCRN::::rdcr i
	do_rdcr (_SD, Dest, UCRN);
31.Dest,26.0,21.0b110000100,12.0,11./,4.INDCR::::rdcr r
	do_rdcr (_SD, Dest, UCRN);
31.Dest,26.0,21.0b110000100,12.1,11./::::rdcr l
	long_immediate (UnsignedControlRegisterNumber);
	do_rdcr (_SD, Dest, UnsignedControlRegisterNumber);


// rmo
31.Dest,26.Source,21.0b111111001,12.0,11./::::rmo
	int b;
	for (b = 0; b < 32; b++)
	  if (rSource & BIT32 (b))
	    break;
	if (b < 32)
	  b = 31 - b;
	TRACE_ALU2 (MY_INDEX, b, rSource);
	*rDest = b;


// rotl - see sl.dz


// rotr - see sl.dz


// shl - see sl.iz


// sl.{d|e|i}{m|s|z}
void::function::do_shift:int Dest, int Source, int Merge, int i, int n, int EndMask, int Rotate
	/* see 10-30 for a reasonable description */
	unsigned32 input = GPR (Source);
	unsigned32 rotated;
	unsigned32 endmask;
	unsigned32 shiftmask;
	unsigned32 cm;
	int nRotate;
	/* rotate the source */
	if (n)
	  {
	    rotated = ROTR32 (GPR (Source), Rotate);
	    nRotate = (- Rotate) & 31;
	  }
	else
	  {
	    rotated = ROTL32 (GPR (Source), Rotate);
	    nRotate = Rotate;
	  }
	/* form the end mask */
	if (EndMask == 0)
	  endmask = -1;
	else
	  endmask = (1 << EndMask) - 1;
	if (i)
	  endmask = ~endmask;
	/* form the shiftmask */
	switch (Merge)
	  {
	  case 0: case 1: case 2:
	    shiftmask = -1; /* disabled */
	    break;
	  case 3: case 4: case 5:
	    shiftmask = ((1 << nRotate) - 1); /* enabled */
	    break;
	  case 6: case 7:
	    shiftmask = ~((1 << nRotate) - 1); /* inverted */
	    break;
	  default:
	    engine_error (SD, CPU, cia,
	                  "0x%lx: Invalid merge (%d) for shift",
	                  cia.ip, Source);
	    shiftmask = 0;
	  }
	/* and the composite mask */
	cm = shiftmask & endmask;
	/* and merge */
	switch (Merge)
	  {
	  case 0: case 3: case 6: /* zero */
	    GPR (Dest) = rotated & cm;
	    break;
	  case 1: case 4: case 7: /* merge */
	    GPR (Dest) = (rotated & cm) | (GPR (Dest) & ~cm);
	    break;
	  case 2: case 5: /* sign */
	    {
	      int b;
	      GPR (Dest) = rotated & cm;
	      for (b = 1; b <= 31; b++)
	        if (!MASKED32 (cm, b, b))
	          GPR (Dest) |= INSERTED32 (EXTRACTED32 (GPR (Dest), b - 1, b - 1),
	                                    b, b);
	    }
	    break;
	  default:
	    engine_error (SD, CPU, cia,
	                  "0x%lx: Invalid merge (%d)",
	                  cia.ip, Source);

	  }
	TRACE_ALU2 (MY_INDEX, GPR (Dest), input);
31.Dest,26.Source,21.0b0001,17.Merge,14./,11.i,10.n,9.EndMask,4.Rotate::::sl i
	do_shift (_SD, Dest, Source, Merge, i, n, EndMask, Rotate);
31.Dest,26.Source,21.0b110001,15.Merge,12.0,11.i,10.n,9.EndMask,4.RotReg::::sl r
	int endmask;
	if (EndMask == 0)
	  endmask = EndMask;
	else
	  {
	    if (Source & 1)
	      engine_error (SD, CPU, cia,
	                    "0x%lx: Invalid source (%d) for shift",
	                    cia.ip, Source);
	    endmask = GPR (Source + 1) & 31;
	  }
	do_shift (_SD, Dest, Source, Merge, i, n, endmask, GPR (RotReg) & 31);


// sli.{d|e|i}{m|s|z} - see shift


// sr.{d|e|i}{m|s|z} - see shift


// sra - see sr.es - see shift


// sri.{d|e|i}{m|s|z} - see shift


// srl - see sr.ez


// st[{.b|.h|.d}]
void::function::do_st:int Source, unsigned32 Base, unsigned32 *rBase, int m , int sz, int S, unsigned32 Offset
	unsigned32 addr;
	switch (sz)
	  {
	  case 0:
	    addr = Base + (S ? (Offset << 0) : Offset);
	    STORE (addr, 1, GPR(Source));
	    break;
	  case 1:
	    addr = Base + (S ? (Offset << 1) : Offset);
	    STORE (addr, 2, GPR(Source));
	    break;
	  case 2:
	    addr = Base + (S ? (Offset << 2) : Offset);
	    STORE (addr, 4, GPR(Source));
	    break;
	  case 3:
	    if (Source & 0x1)
	      engine_error (SD, CPU, cia, "0x%lx: st.d with odd source register %d",
	                    cia.ip, Source);
	    addr = Base + (S ? (Offset << 3) : Offset);
	    STORE (addr, 8, *(unsigned64*)&GPR(Source));
	    break;
	  default:
	    addr = -1;
	    engine_error (SD, CPU, cia, "st - invalid sz %d", sz);
	  }
	if (m)
	  *rBase = addr;
	TRACE_ST (MY_INDEX, m, S, Source, Base, Offset);
31.Source,26.Base,21.0b0110,17.m,16.sz,14.SignedOffset::::st i
	do_st (_SD, Source, rBase, &GPR(Base), m, sz, 0, vSignedOffset);
31.Source,26.Base,21.0b110110,15.m,14.sz,12.0,11.S,10.0,9./,4.IndOff::::st r
	do_st (_SD, Source, rBase, &GPR(Base), m, sz, S, rIndOff);
31.Source,26.Base,21.0b110110,15.m,14.sz,12.1,11.S,10.0,9./::::st l
	long_immediate (LongSignedImmediateOffset);
	do_st (_SD, Source, rBase, &GPR(Base), m, sz, S, LongSignedImmediateOffset);


// sub
void::function::do_sub:signed32 *rDest, signed32 Source1, signed32 Source2
	ALU_BEGIN (Source1);
	ALU_SUB (Source2);
	ALU_END (*rDest);
	TRACE_ALU3 (MY_INDEX, *rDest, Source1, Source2);
31.Dest,26.Source2,21.0b101101,15.0,14.SignedImmediate::::sub i
	do_sub (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b11101101,13.0,12.0,11./,4.Source1::::sub r
	do_sub (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b11101101,13.0,12.1,11./::::sub l
	long_immediate (LongSignedImmediate);
	do_sub (_SD, rDest, LongSignedImmediate, rSource2);


// subu
void::function::do_subu:signed32 *rDest, signed32 Source1, signed32 Source2
	unsigned32 result = Source1 - Source2;
	TRACE_ALU3 (MY_INDEX, result, Source1, Source2);
	*rDest = result;
// NOTE - the book has 15.1 which conflicts with subu.
31.Dest,26.Source2,21.0b101101,15.1,14.SignedImmediate::::subu i
	do_subu (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b11101101,13.1,12.0,11./,4.Source1::::subu r
	do_subu (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b11101101,13.1,12.1,11./::::subu l
	long_immediate (LongSignedImmediate);
	do_subu (_SD, rDest, LongSignedImmediate, rSource2);


// swcr
void::function::do_swcr:int Dest, signed32 rSource, signed32 cr
	tic80_control_regs reg = tic80_index2cr (cr);
	/* cache the old CR value */
	unsigned32 old_cr = CR (cr);
	/* Handle the write if allowed */
	if (cr >= 0x4000 || !(CPU)->is_user_mode)
	  switch (reg)
	    {
	    case INTPEN_CR:
	      CR (cr) &= ~rSource;
	      break;
	    default:
	      CR (cr) = rSource;
	      break;
	    }
	/* Finish off the read */
	GPR (Dest) = old_cr;
	TRACE_SINK3 (MY_INDEX, rSource, cr, Dest);
31.Dest,26.Source,21.0b000010,15.1,14.UCRN::::swcr i
	do_swcr (_SD, Dest, rSource, UCRN);
31.Dest,26.Source,21.0b11000010,13.1,12.0,11./,4.INDCR::::swcr r
	do_swcr (_SD, Dest, rSource, UCRN);
31.Dest,26.Source,21.0b11000010,13.1,12.1,11./::::swcr l
	long_immediate (LongUnsignedControlRegister);
	do_swcr (_SD, Dest, rSource, LongUnsignedControlRegister);


// trap
void::function::do_trap:unsigned32 trap_number
	TRACE_SINK1 (MY_INDEX, trap_number);
	switch (trap_number)
	  {
	  case 72:
	    switch (GPR(15))
	      {
	      case 1: /* EXIT */
	        {
	          engine_halt (SD, CPU, cia, sim_exited, GPR(2));
	          break;
	        }
	      case 4: /* WRITE */
	        {
	          int i;
	          if (GPR(2) == 1)
		    for (i = 0; i < GPR(6); i++)
	              {
		        char c;
		        c = MEM (unsigned, GPR(4) + i, 1);
	                sim_io_write_stdout (SD, &c, 1);
	              }
	          else if (GPR(2) == 2)
		    for (i = 0; i < GPR(6); i++)
	              {
		        char c;
		        c = MEM (unsigned, GPR(4) + i, 1);
	                sim_io_write_stderr (SD, &c, 1);
	              }
	          else
	            engine_error (SD, CPU, cia,
	                          "0x%lx: write to invalid fid %d",
	                          (unsigned long) cia.ip, GPR(2));
	          GPR(2) = GPR(6);
	          break;
	        }
	      default:
	        engine_error (SD, CPU, cia,
	                      "0x%lx: unknown syscall %d",
	                      (unsigned long) cia.ip, GPR(15));
	      }
	    break;
	  case 73:
	    engine_halt (SD, CPU, cia, sim_stopped, SIGTRAP);
	  default:
	    engine_error (SD, CPU, cia,
	                  "0x%lx: unsupported trap %d",
	                  (unsigned long) cia.ip, trap_number);
	  }
31./,27.0,26./,21.0b0000001,14.UTN::::trap i
	do_trap (_SD, UTN);
31./,27.0,26./,21.0b110000001,12.0,11./,4.INDTR::::trap r
	do_trap (_SD, UTN);
31./,27.0,26./,21.0b110000001,12.1,11./::::trap l
	long_immediate (UTN);
	do_trap (_SD, UTN);


// vadd.{s|d}{s|d}
31.*,26.Dest,21.0b11110,16./,15.0b000,12.0,11./,10.*,9.*,7.PD,6.*,5.P1,4.Source::f::vadd r
31.*,26.Dest,21.0b11110,16./,15.0b000,12.1,11./,10.*,9.*,7.PD,6.*,5.P1,4.Source::f::vadd l


// vld{0|1}.{s|d} - see above - same instruction
#31.Dest,26.*,21.0b11110,16.*,10.1,9.S,8.*,6.p,7.******::f::vld


// vmac.ss{s|d}
#31.*,   26.Source2,21.0b11110,16.a0,15.0b110,12.0,11.a1,10.*,9.*, 8.Z,7./,6.*,5./,4.Source1::f::vmac.ss ra
31.Dest,26.Source2,21.0b11110,16.a0,15.0b110,12.0,11.a1,10.0,9.PD,8.Z,7./,6.0,5./,4.Source1::f::vmac.ss rr
#31.*,   26.Source2,21.0b11110,16.a0,15.0b110,12.1,11.a1,10.*,9.*, 8.Z,7./,6.*,5./,4./::f::vmac.ss ia
31.Dest,26.Source2,21.0b11110,16.a0,15.0b110,12.1,11.a1,10.0,9.PD,8.Z,7./,6.0,5./,4./::f::vmac.ss ir


// vmpy.{s|d}{s|d}
31.*,26.Dest,21.0b11110,16./,15.0b010,12.0,11./,10.*,8.*,7.PD,6.*,5.P1,4.Source::f::vmpy r
31.*,26.Dest,21.0b11110,16./,15.0b010,12.1,11./,10.*,8.*,7.PD,6.*,5.P1,4./::f::vmpy l


// vmsc.ss{s|d}
#31.*,   26.Source2,21.0b11110,16.a0,15.0b111,12.0,11.a1,10.*,9.*, 8.Z,7./,6.*,5./,4.Source1::f::vmsc.ss ra
31.Dest,26.Source2,21.0b11110,16.a0,15.0b111,12.0,11.a1,10.0,9.PD,8.Z,7./,6.0,5./,4.Source1::f::vmsc.ss rr
#31.*,   26.Source2,21.0b11110,16.a0,15.0b111,12.1,11.a1,10.*,9.*, 8.Z,7./,6.*,5./,4./::f::vmsc.ss ia
31.Dest,26.Source2,21.0b11110,16.a0,15.0b111,12.1,11.a1,10.0,9.PD,8.Z,7./,6.0,5./,4./::f::vmsc.ss ir


// vmsub.{s|d}{s|d}
31.*,26.Dest,21.0b11110,16.a0,15.0b011,12.0,11.a1,10.*,8.Z,7.PD,6.*,5./,4.Source::f::vmsub r
31.*,26.Dest,21.0b11110,16.a0,15.0b011,12.1,11.a1,10.*,8.Z,7.PD,6.*,5./,4./::f::vmsub l


// vrnd.{s|d}{s|d}
31.*,26.Dest,21.0b11110,16.a0,15.0b100,12.0,11.a1,10.*,8.PD,6.*,5.P1,4.Source::f::vrnd f r
31.*,26.Dest,21.0b11110,16.a0,15.0b100,12.1,11.a1,10.*,8.PD,6.*,5.P1,4./::f::vrnd f l


// vrnd.{i|u}{s|d}
31.*,26.Dest,21.0b11110,16./,15.0b101,12.0,11./,10.*,8./,7.PD,6.*,5.P1,4.Source::f::vrnd i r
31.*,26.Dest,21.0b11110,16./,15.0b101,12.1,11./,10.*,8./,7.PD,6.*,5.P1,4./::f::vrnd i l


// vst.{s|d} - see above - same instruction
#31.Source,26.*,21.0b11110,16.*,10.0,9.S,8.*,6.1,5.*::f::vst


// vsub.{i|u}{s|d}
31.*,26.Dest,21.0b11110,16./,15.0b001,12.0,11./,10.*,8./,7.PD,6.*,5.P1,4.Source::f::vsub r
31.*,26.Dest,21.0b11110,16./,15.0b001,12.1,11./,10.*,8./,7.PD,6.*,5.P1,4./::f::vsub l


// wrcr - see swcr, creg, source, r0


// xnor
void::function::do_xnor:signed32 *rDest, signed32 Source1, signed32 Source2
	unsigned32 result = ~ (Source1 ^ Source2);
	TRACE_ALU3 (MY_INDEX, result, Source1, Source2);
	*rDest = result;
31.Dest,26.Source2,21.0b0011001,14.UnsignedImmediate::::xnor i
	do_xnor (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b110011001,12.0,11./,4.Source1::::xnor r
	do_xnor (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b110011001,12.1,11./::::xnor l
	long_immediate (LongUnsignedImmediate);
	do_xnor (_SD, rDest, LongUnsignedImmediate, rSource2);


// xor
void::function::do_xor:signed32 *rDest, signed32 Source1, signed32 Source2
	unsigned32 result = Source1 ^ Source2;
	TRACE_ALU3 (MY_INDEX, result, Source1, Source2);
	*rDest = result;
31.Dest,26.Source2,21.0b0010110,14.UnsignedImmediate::::xor i
	do_xor (_SD, rDest, vSource1, rSource2);
31.Dest,26.Source2,21.0b110010110,12.0,11./,4.Source1::::xor r
	do_xor (_SD, rDest, rSource1, rSource2);
31.Dest,26.Source2,21.0b110010110,12.1,11./::::xor l
	long_immediate (LongUnsignedImmediate);
	do_xor (_SD, rDest, LongUnsignedImmediate, rSource2);
