

// Integer Instructions
// --------------------
//
// MulAcc is the Multiply Accumulator.
//     This register is mapped on the the HI and LO registers.
//     Upper 32 bits of MulAcc is mapped on to lower 32 bits of HI register.
//     Lower 32 bits of MulAcc is mapped on to lower 32 bits of LO register.


:function:::unsigned64:MulAcc:
{
  unsigned64 result = U8_4 (HI, LO);
  return result;
}

:function:::void:SET_MulAcc:unsigned64 value
{
  *AL4_8 (&HI) = VH4_8 (value);
  *AL4_8 (&LO) = VL4_8 (value);
}

:function:::signed64:SignedMultiply:signed32 l, signed32 r
{
  signed64 result = (signed64) l * (signed64) r;
  return result;
}

:function:::unsigned64:UnsignedMultiply:unsigned32 l, unsigned32 r
{
  unsigned64 result = (unsigned64) l * (unsigned64) r;
  return result;
}

:function:::unsigned64:Low32Bits:unsigned64 value
{
  unsigned64 result = (signed64) (signed32) VL4_8 (value);
  return result;
}

:function:::unsigned64:High32Bits:unsigned64 value
{
  unsigned64 result = (signed64) (signed32) VH4_8 (value);
  return result;
}



// Multiply, Accumulate
000000,5.RS,5.RT,00000,00000,101000::::MAC
"mac r<RS>, r<RT>"
*vr4320:
{
  SET_MulAcc (SD_, MulAcc (SD_) + SignedMultiply (SD_, GPR[RS], GPR[RT]));
}

// D-Multiply, Accumulate
000000,5.RS,5.RT,00000,00000,101001::::DMAC
"dmac r<RS>, r<RT>"
*vr4320:
{
  LO = LO + SignedMultiply (SD_, GPR[RS], GPR[RT]);
}

// Count Leading Zeros
000000,5.RS,00000,5.RD,00000,110101::::CLZ
"clz r<RD>, r<RS>"
*vr4320:
{
  unsigned32 t = Low32Bits (SD_, GPR[RS]);
  signed64 c = 0;

  while (! (t & ( 1 << 31))
	&& c < 32)
    {
    c++;
    t <<= 1;
    }

  GPR[RD] = c;
}

// D-Count Leading Zeros
000000,5.RS,00000,5.RD,00000,111101::::DCLZ
"dclz r<RD>, r<RS>"
*vr4320:
{
  unsigned64 t = GPR[RS];
  signed64 c = 0;

  while (! (t & ( (unsigned64)1 << 63))
	&& c < 64)
    {
    c++;
    t <<= 1;
    }

  printf("lo %d\n", (int) c);
  GPR[RD] = c;
}







// Multiply and Move LO.
000000,5.RS,5.RT,5.RD,00100,101000::::MUL
"mul r<RD>, r<RS>, r<RT>"
*vr4320:
{
  SET_MulAcc (SD_, 0 + SignedMultiply (SD_, GPR[RS], GPR[RT]));
  GPR[RD] = Low32Bits (SD_, MulAcc (SD_));
}

// Unsigned Multiply and Move LO.
000000,5.RS,5.RT,5.RD,00101,101000::::MULU
"mulu r<RD>, r<RS>, r<RT>"
*vr4320:
{
  SET_MulAcc (SD_, 0 + UnsignedMultiply (SD_, GPR[RS], GPR[RT]));
  GPR[RD] = Low32Bits  (SD_, MulAcc (SD_));
}

// Multiply and Move HI.
000000,5.RS,5.RT,5.RD,01100,101000::::MULHI
"mulhi r<RD>, r<RS>, r<RT>"
*vr4320:
{
  SET_MulAcc (SD_, 0 + SignedMultiply (SD_, GPR[RS], GPR[RT]));
  GPR[RD] = High32Bits (SD_, MulAcc (SD_));
}

// Unsigned Multiply and Move HI.
000000,5.RS,5.RT,5.RD,01101,101000::::MULHIU
"mulhiu r<RD>, r<RS>, r<RT>"
*vr4320:
{
  SET_MulAcc (SD_, 0 + UnsignedMultiply (SD_, GPR[RS], GPR[RT]));
  GPR[RD] = High32Bits (SD_, MulAcc (SD_));
}






// Multiply, Accumulate and Move LO.
000000,5.RS,5.RT,5.RD,00010,101000::::MACC
"macc r<RD>, r<RS>, r<RT>"
*vr4320:
{
  SET_MulAcc (SD_, MulAcc (SD_) + SignedMultiply (SD_, GPR[RS], GPR[RT]));
  GPR[RD] = Low32Bits  (SD_, MulAcc (SD_));
}

// Unsigned Multiply, Accumulate and Move LO.
000000,5.RS,5.RT,5.RD,00011,101000::::MACCU
"maccu r<RD>, r<RS>, r<RT>"
*vr4320:
{
  SET_MulAcc (SD_, MulAcc (SD_) + UnsignedMultiply (SD_, GPR[RS], GPR[RT]));
  GPR[RD] = Low32Bits  (SD_, MulAcc (SD_));
}

// Multiply, Accumulate and Move HI.
000000,5.RS,5.RT,5.RD,01010,101000::::MACCHI
"macchi r<RD>, r<RS>, r<RT>"
*vr4320:
{
  SET_MulAcc (SD_, MulAcc (SD_) + SignedMultiply (SD_, GPR[RS], GPR[RT]));
  GPR[RD] = High32Bits (SD_, MulAcc (SD_));
}

// Unsigned Multiply, Accumulate and Move HI.
000000,5.RS,5.RT,5.RD,01011,101000::::MACCHIU
"macchiu r<RD>, r<RS>, r<RT>"
*vr4320:
{
  SET_MulAcc (SD_, MulAcc (SD_) + UnsignedMultiply (SD_, GPR[RS], GPR[RT]));
  GPR[RD] = High32Bits (SD_, MulAcc (SD_));

}

