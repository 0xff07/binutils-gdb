# Simulator main loop for m32rx. -*- C -*-
# Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
#
# This file is part of the GNU Simulators.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Syntax:
# /bin/sh mainloop.in init|support|{full,fast}-{extract,exec}-{scache,noscache}

# ??? After a few more ports are done, revisit.
# Will eventually need to machine generate a lot of this.

case "x$1" in

xsupport)

cat <<EOF

EOF

;;

xinit)

cat <<EOF
  DECODE *d1,*d2;
  ARGBUF abufs[MAX_PARALLEL_INSNS];
  PAREXEC pbufs[MAX_PARALLEL_INSNS];
EOF

;;

xfull-extract-* | xfast-extract-*)

cat <<EOF
{
  PCADDR pc = CPU (h_pc);

  /* ??? This code isn't very fast.  Let's get it working first.  */

  if ((pc & 3) != 0)
    {
      USI insn = GETIMEMUHI (current_cpu, pc);
      insn &= 0x7fff;
      d1 = m32rx_decode (current_cpu, pc, insn);
      abufs[0].insn = insn;
      icount = 1;
    }
  else
    {
      USI insn = GETIMEMUSI (current_cpu, pc);
      if ((SI) insn < 0)
	{
	  d1 = m32rx_decode (current_cpu, pc, insn >> 16);
	  abufs[0].insn = insn;
	  icount = 1;
	}
      else
	{
	  if (insn & 0x8000)
	    {
	      d1 = m32rx_decode (current_cpu, pc, insn >> 16);
	      abufs[0].insn = insn >> 16;
	      d2 = m32rx_decode (current_cpu, pc, insn & 0x7fff);
	      abufs[1].insn = insn & 0x7fff;
	      icount = 2;
	    }
	  else
	    {
	      d1 = m32rx_decode (current_cpu, pc, insn >> 16);
	      abufs[0].insn = insn >> 16;
	      icount = 1;
	    }
	}
    }

  {
    int icount2 = icount;
    USI insn = abufs[0].insn;
    DECODE *decode = d1;
    /* decode, par_exec, and insn are refered to by readx.c.  */
    PAREXEC *par_exec = &pbufs[0];
    do
      {
#define DEFINE_SWITCH
#include "readx.c"

	decode = d2;
	insn = abufs[1].insn;
	++par_exec;
      }
    while (--icount2 != 0);
  }
}
EOF

;;

xfull-exec-* | xfast-exec-*)

cat <<EOF
{
  SEM_ARG sem_arg = &abufs[0];
  PAREXEC *par_exec = &pbufs[0];
  PCADDR new_pc;

  /* If doing parallel execution, verify insns are in the right pipeline.  */
  if (icount == 2)
    {
      ; /*wip*/
    }

  TRACE_INSN_INIT (current_cpu);
  TRACE_INSN (current_cpu, d1->opcode, sem_arg, CPU (h_pc));
  new_pc = (*d1->semantic) (current_cpu, sem_arg, par_exec);
  TRACE_INSN_FINI (current_cpu);
  PROFILE_COUNT_INSN (current_cpu, CPU (h_pc), CGEN_INSN_INDEX (d1->opcode));

  /* The result of the semantic fn is one of:
     - next address, branch only
     - NEW_PC_SKIP, sc/snc insn
     - NEW_PC_2, 2 byte non-branch non-sc/snc insn
     - NEW_PC_4, 4 byte non-branch insn
     */

  if (new_pc == NEW_PC_4)
    CPU (h_pc) += 4;
  else if (NEW_PC_BRANCH_P (new_pc))
    CPU (h_pc) = new_pc;
  else
    {
      PCADDR pc = CPU (h_pc);

      CPU (h_pc) = pc + 2;
      if (icount == 2)
	{
	  /* Note that we only get here if doing parallel execution.  */
	  if (new_pc == NEW_PC_SKIP)
	    {
	      /* ??? Need generic notion of bypassing an insn for the name of
		 this macro.  Annulled?  On the otherhand such tracing can go
		 in the sc/snc semantic fn.  */
	      ; /*TRACE_INSN_SKIPPED (current_cpu);*/
	    }
	  else
	    {
	      ++sem_arg;
	      ++par_exec;
	      TRACE_INSN_INIT (current_cpu);
	      TRACE_INSN (current_cpu, d2->opcode, sem_arg, CPU (h_pc));
	      /* new_pc isn't used.  It's assigned a value for debugging.  */
	      new_pc = (*d2->semantic) (current_cpu, sem_arg, par_exec);
	      TRACE_INSN_FINI (current_cpu);
	      PROFILE_COUNT_INSN (current_cpu, pc, CGEN_INSN_INDEX (d2->opcode));
	    }
	  CPU (h_pc) = pc + 4;
	}
    }
}
EOF

;;

*)
  echo "Invalid argument to mainloop.in: $1" >&2
  exit 1
  ;;

esac
