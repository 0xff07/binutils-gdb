#! /bin/sh
# Generate nltvals.def, a file that describes various target values
# used by the host/target interface.
#
# Syntax: /bin/sh gennltvals.sh shell srcroot cpp

shell=$1
srcroot=$2
cpp=$3

srccom=$srcroot/sim/common

echo '/* Newlib/libgloss macro values needed by remote target support.  */'
echo '/* This file is machine generated by gennltvals.sh.  */'

$shell ${srccom}/gentvals.sh "" errno ${srcroot}/newlib/libc/include \
	"errno.h sys/errno.h" 'E[A-Z0-9]*' "${cpp}"

$shell ${srccom}/gentvals.sh "" signal ${srcroot}/newlib/libc/include \
	"signal.h sys/signal.h" 'SIG[A-Z0-9]*' "${cpp}"

$shell ${srccom}/gentvals.sh "" open ${srcroot}/newlib/libc/include \
	"fcntl.h sys/fcntl.h" 'O_[A-Z0-9]*' "${cpp}"

# Unfortunately, each newlib/libgloss port has seen fit to define their own
# syscall.h file.  This means that system call numbers can vary for each port.
# Support for all this crud is kept here, rather than trying to get too fancy.
# If you want to try to improve this, please do, but don't break anything.
# Note that there is a standard syscall.h file (libgloss/syscall.h) now which
# hopefully more targets can use.

targets="d30v m32r sparc"

for t in $targets
do
	case $t in
	d30v) dir=libgloss macro=d30v ;;
	m32r) dir=libgloss/m32r/sys macro=m32r ;;
	sparc) dir=libgloss macro=sparc ;;
	esac

	$shell ${srccom}/gentvals.sh $macro sys ${srcroot}/$dir \
		"syscall.h" 'SYS_[_A-Za-z0-9]*' "${cpp}"
done
