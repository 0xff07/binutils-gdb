# Configure fragment invoked in the post-target section for subdirs
# wanting multilib support.
# The intent is to keep as much of this in one place as possible (and out
# of each subdirectory, eg: newlib, libio, etc.) until the right way to do
# this (ha ha) is decided upon.

# Only do this if --enable-multilib.

if [ "${enable_multilib}" = yes ]; then

if [ -z "${with_multisubdir}" ]; then
  multisubdir=
else
  multisubdir="/${with_multisubdir}"
  # FIXME: following line needs testing in multilevel dir (eg: m68k).
  dotdot=`echo ${multisubdir} | sed -e 's:/[^/]*:../:g'`
  sed -e "s:^TOP[ 	]*=[ 	]*\([./]*\)[ 	]*$:TOP = ${dotdot}\1:" \
      -e "s:^MULTITOP[ 	]*=[ 	]*\([./]*\)[ 	]*$:MULTITOP = ${dotdot}\1:" \
	${Makefile} > Makefile.tem
  rm -f ${Makefile}
  mv Makefile.tem ${Makefile}
fi

# MULTIDIRS is non-empty for the cpu top level Makefile (eg: newlib/Makefile)
# and lists the subdirectories to recurse into.  MULTISUBDIR is non-empty in
# each cpu subdirectory's Makefile (eg: newlib/h8300h/Makefile) and is the
# installed subdirectory name with a trailing '/'.
# XXX_MULTI is a set of helpers for all, install, etc.
# Makefile.in is free to override them since these are prepended to the top.

cat > Multi.tem <<EOF
MULTIDIRS = ${multidirs}
MULTISUBDIR = ${multisubdir}
EOF
cat Multi.tem ${Makefile} > Makefile.tem
rm -f Multi.tem ${Makefile}
mv Makefile.tem ${Makefile}

# Add default definitions for all, install, clean, etc.
# if the Makefile uses them.

if grep ALL_MULTI ${Makefile} >/dev/null 2>/dev/null
then
	cat > Multi.tem <<EOF
ALL_MULTI = all-multi
INSTALL_MULTI = install-multi
MOSTLYCLEAN_MULTI = mostlyclean-multi
CLEAN_MULTI = clean-multi
DISTCLEAN_MULTI = distclean-multi
EOF

	cat Multi.tem ${Makefile} > Makefile.tem
	rm -f Multi.tem ${Makefile}
	mv Makefile.tem ${Makefile}

	cat > Multi.tem <<\EOF

# FIXME: We use --print-multi-lib but the others don't.  Standardize.
all-multi:
	if [ -z "$(MULTIDIRS)" ]; then \
	  true; \
	else \
	  rootpre=`pwd`/; export rootpre; \
	  srcrootpre=`cd $(srcdir); pwd`/; export srcrootpre; \
	  compiler="$(CC)"; \
	  for i in `$${compiler} --print-multi-lib 2>/dev/null`; do \
	    dir=`echo $$i | sed -e 's/;.*$$//'`; \
	    if [ "$${dir}" = "." ]; then \
	      true; \
	    else \
	      if [ -d $${dir} ]; then \
		flags=`echo $$i | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`; \
		if (cd $${dir}; $(MAKE) $(FLAGS_TO_PASS) \
				CFLAGS="$(CFLAGS) $${flags}" \
				CXXFLAGS="$(CXXFLAGS) $${flags}" \
				LIBCFLAGS="$(LIBCFLAGS) $${flags}" \
				LIBCXXFLAGS="$(LIBCXXFLAGS) $${flags}" \
				all); then \
		  true; \
		else \
		  exit 1; \
		fi; \
	      else true; \
	      fi; \
	    fi; \
	  done; \
	fi

install-multi mostlyclean-multi clean-multi distclean-multi realclean-multi:
	if [ -n "$(MULTIDIRS)" ]; then \
	  rootpre=`pwd`/; export rootpre; \
	  srcrootpre=`cd $(srcdir); pwd`/; export srcrootpre; \
	  $(MAKE) DO=`echo $@ | sed -e 's/-multi$$//'` DODIRS="$(MULTIDIRS)" $(FLAGS_TO_PASS) multi_subdir_do; \
	else true; fi

multi_subdir_do:
	for i in $(DODIRS); do \
		if [ -f ./$$i/Makefile ] ; then \
			if (cd ./$$i; $(MAKE) $(FLAGS_TO_PASS) $(DO)) ; \
			then true ; \
			else exit 1 ; \
			fi ; \
		else true; \
		fi ; \
	done
EOF

	cat ${Makefile} Multi.tem > Makefile.tem
	rm -f ${Makefile} Multi.tem
	mv Makefile.tem ${Makefile}
fi

fi # "${enable_multilib}" = yes
