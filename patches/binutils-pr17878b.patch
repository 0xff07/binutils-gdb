From ff574ce49154d752a159fe53f11d688a5121294a Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Mon, 9 Feb 2015 03:30:03 -0800
Subject: [PATCH 2/2] Add tests for non-object IR file

This patch adds linker, nm and ar tests for non-object IR file, including
archive with non-object IR member.

ld/

	PR ld/17878
	* Makefile.am (noinst_LTLIBRARIES): Add libldtestplug2.la and
	libldtestplug3.la.
	(libldtestplug2_la_SOURCES): New.
	(libldtestplug2_la_CFLAGS): Likewise.
	(libldtestplug2_la_LDFLAGS): Likewise.
	(libldtestplug3_la_SOURCES): New.
	(libldtestplug3_la_CFLAGS): Likewise.
	(libldtestplug3_la_LDFLAGS): Likewise.
	* Makefile.in: Regenerated.
	* testplug2.c: New file.
	* testplug3.c: Likewise.

ld/testsuite/

	PR ld/17878
	* ld-plugin/func.c: Add some comments.
	* ld-plugin/plugin-13.d: New file.
	* ld-plugin/plugin-14.d: Likewise.
	* ld-plugin/plugin-15.d: Likewise.
	* ld-plugin/plugin-16.d: Likewise.
	* ld-plugin/plugin-17.d: Likewise.
	* ld-plugin/plugin-18.d: Likewise.
	* ld-plugin/plugin-19.d: Likewise.
	* ld-plugin/plugin-20.d: Likewise.
	* ld-plugin/plugin-21.d: Likewise.
	* ld-plugin/plugin-22.d: Likewise.
	* ld-plugin/plugin-23.d: Likewise.
	* ld-plugin/plugin-24.d: Likewise.
	* ld-plugin/plugin-25.d: Likewise.
	* ld-plugin/plugin-26.d: Likewise.
	* ld-plugin/plugin.exp (plugin2_name): New.
	(plugin3_name): Likewise.
	(plugin2_path): Likewise.
	(plugin3_path): Likewise.
	(testsrcfiles): Likewise.
	(testsrcfiles_notext): Likewise.
	(plugin_tests): Add tests for non-object IR file.
	(plugin_lib_tests): Likewise.
	(plugin_extra_elf_tests): Likewise.
	(plugin_src_tests): New tests for non-object IR file.
	Run nm --plugin test.
	Run ar --plugin test.
	Run plugin_src_tests.
---
 ld/Makefile.am                     |   8 +-
 ld/Makefile.in                     |  49 ++-
 ld/testplug2.c                     | 693 +++++++++++++++++++++++++++++++++++++
 ld/testplug3.c                     | 674 ++++++++++++++++++++++++++++++++++++
 ld/testsuite/ld-plugin/func.c      |   3 +
 ld/testsuite/ld-plugin/plugin-13.d |  27 ++
 ld/testsuite/ld-plugin/plugin-14.d |  33 ++
 ld/testsuite/ld-plugin/plugin-15.d |  34 ++
 ld/testsuite/ld-plugin/plugin-16.d |  38 ++
 ld/testsuite/ld-plugin/plugin-17.d |  37 ++
 ld/testsuite/ld-plugin/plugin-18.d |  38 ++
 ld/testsuite/ld-plugin/plugin-19.d |  42 +++
 ld/testsuite/ld-plugin/plugin-20.d |   7 +
 ld/testsuite/ld-plugin/plugin-21.d |   7 +
 ld/testsuite/ld-plugin/plugin-22.d |   7 +
 ld/testsuite/ld-plugin/plugin-23.d |   7 +
 ld/testsuite/ld-plugin/plugin-24.d |   5 +
 ld/testsuite/ld-plugin/plugin-25.d |   5 +
 ld/testsuite/ld-plugin/plugin-26.d |  24 ++
 ld/testsuite/ld-plugin/plugin.exp  | 138 ++++++++
 20 files changed, 1873 insertions(+), 3 deletions(-)
 create mode 100644 ld/testplug2.c
 create mode 100644 ld/testplug3.c
 create mode 100644 ld/testsuite/ld-plugin/plugin-13.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-14.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-15.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-16.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-17.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-18.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-19.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-20.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-21.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-22.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-23.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-24.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-25.d
 create mode 100644 ld/testsuite/ld-plugin/plugin-26.d

diff --git a/ld/Makefile.am b/ld/Makefile.am
index 18bcf8b..75a481b 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -2053,10 +2053,16 @@ bootstrap: ld3$(EXEEXT)
 # Build a dummy plugin using libtool.
 #
 if ENABLE_PLUGINS
-noinst_LTLIBRARIES = libldtestplug.la
+noinst_LTLIBRARIES = libldtestplug.la libldtestplug2.la libldtestplug3.la
 libldtestplug_la_SOURCES = testplug.c
 libldtestplug_la_CFLAGS= -g -O2
 libldtestplug_la_LDFLAGS = -no-undefined -rpath /nowhere
+libldtestplug2_la_SOURCES = testplug2.c
+libldtestplug2_la_CFLAGS= -g -O2
+libldtestplug2_la_LDFLAGS = -no-undefined -rpath /nowhere
+libldtestplug3_la_SOURCES = testplug3.c
+libldtestplug3_la_CFLAGS= -g -O2
+libldtestplug3_la_LDFLAGS = -no-undefined -rpath /nowhere
 endif
 
 # DOCUMENTATION TARGETS
diff --git a/ld/Makefile.in b/ld/Makefile.in
index a3011c9..6c54fda 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -101,6 +101,24 @@ libldtestplug_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(libldtestplug_la_CFLAGS) \
 	$(CFLAGS) $(libldtestplug_la_LDFLAGS) $(LDFLAGS) -o $@
 @ENABLE_PLUGINS_TRUE@am_libldtestplug_la_rpath =
+libldtestplug2_la_LIBADD =
+@ENABLE_PLUGINS_TRUE@am_libldtestplug2_la_OBJECTS =  \
+@ENABLE_PLUGINS_TRUE@	libldtestplug2_la-testplug2.lo
+libldtestplug2_la_OBJECTS = $(am_libldtestplug2_la_OBJECTS)
+libldtestplug2_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libldtestplug2_la_CFLAGS) $(CFLAGS) \
+	$(libldtestplug2_la_LDFLAGS) $(LDFLAGS) -o $@
+@ENABLE_PLUGINS_TRUE@am_libldtestplug2_la_rpath =
+libldtestplug3_la_LIBADD =
+@ENABLE_PLUGINS_TRUE@am_libldtestplug3_la_OBJECTS =  \
+@ENABLE_PLUGINS_TRUE@	libldtestplug3_la-testplug3.lo
+libldtestplug3_la_OBJECTS = $(am_libldtestplug3_la_OBJECTS)
+libldtestplug3_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libldtestplug3_la_CFLAGS) $(CFLAGS) \
+	$(libldtestplug3_la_LDFLAGS) $(LDFLAGS) -o $@
+@ENABLE_PLUGINS_TRUE@am_libldtestplug3_la_rpath =
 am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(infodir)" \
 	"$(DESTDIR)$(man1dir)"
 PROGRAMS = $(bin_PROGRAMS)
@@ -135,7 +153,8 @@ YLWRAP = $(top_srcdir)/../ylwrap
 YACCCOMPILE = $(YACC) $(YFLAGS) $(AM_YFLAGS)
 LTYACCCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=compile $(YACC) $(YFLAGS) $(AM_YFLAGS)
-SOURCES = $(libldtestplug_la_SOURCES) $(ld_new_SOURCES) \
+SOURCES = $(libldtestplug_la_SOURCES) $(libldtestplug2_la_SOURCES) \
+	$(libldtestplug3_la_SOURCES) $(ld_new_SOURCES) \
 	$(EXTRA_ld_new_SOURCES)
 INFO_DEPS = ld.info
 am__TEXINFO_TEX_DIR = $(srcdir)/../texinfo
@@ -889,10 +908,16 @@ ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $
 #
 # Build a dummy plugin using libtool.
 #
-@ENABLE_PLUGINS_TRUE@noinst_LTLIBRARIES = libldtestplug.la
+@ENABLE_PLUGINS_TRUE@noinst_LTLIBRARIES = libldtestplug.la libldtestplug2.la libldtestplug3.la
 @ENABLE_PLUGINS_TRUE@libldtestplug_la_SOURCES = testplug.c
 @ENABLE_PLUGINS_TRUE@libldtestplug_la_CFLAGS = -g -O2
 @ENABLE_PLUGINS_TRUE@libldtestplug_la_LDFLAGS = -no-undefined -rpath /nowhere
+@ENABLE_PLUGINS_TRUE@libldtestplug2_la_SOURCES = testplug2.c
+@ENABLE_PLUGINS_TRUE@libldtestplug2_la_CFLAGS = -g -O2
+@ENABLE_PLUGINS_TRUE@libldtestplug2_la_LDFLAGS = -no-undefined -rpath /nowhere
+@ENABLE_PLUGINS_TRUE@libldtestplug3_la_SOURCES = testplug3.c
+@ENABLE_PLUGINS_TRUE@libldtestplug3_la_CFLAGS = -g -O2
+@ENABLE_PLUGINS_TRUE@libldtestplug3_la_LDFLAGS = -no-undefined -rpath /nowhere
 MAINTAINERCLEANFILES = configdoc.texi ld.1 ld.info
 
 # We want to reconfigure if configure.host or configure.tgt changes.
@@ -980,6 +1005,10 @@ clean-noinstLTLIBRARIES:
 	done
 libldtestplug.la: $(libldtestplug_la_OBJECTS) $(libldtestplug_la_DEPENDENCIES) 
 	$(libldtestplug_la_LINK) $(am_libldtestplug_la_rpath) $(libldtestplug_la_OBJECTS) $(libldtestplug_la_LIBADD) $(LIBS)
+libldtestplug2.la: $(libldtestplug2_la_OBJECTS) $(libldtestplug2_la_DEPENDENCIES) 
+	$(libldtestplug2_la_LINK) $(am_libldtestplug2_la_rpath) $(libldtestplug2_la_OBJECTS) $(libldtestplug2_la_LIBADD) $(LIBS)
+libldtestplug3.la: $(libldtestplug3_la_OBJECTS) $(libldtestplug3_la_DEPENDENCIES) 
+	$(libldtestplug3_la_LINK) $(am_libldtestplug3_la_rpath) $(libldtestplug3_la_OBJECTS) $(libldtestplug3_la_LIBADD) $(LIBS)
 install-binPROGRAMS: $(bin_PROGRAMS)
 	@$(NORMAL_INSTALL)
 	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
@@ -1397,6 +1426,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldver.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldwrite.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lexsup.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libldtestplug2_la-testplug2.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libldtestplug3_la-testplug3.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libldtestplug_la-testplug.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mri.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-dll.Po@am__quote@
@@ -1431,6 +1462,20 @@ libldtestplug_la-testplug.lo: testplug.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug_la_CFLAGS) $(CFLAGS) -c -o libldtestplug_la-testplug.lo `test -f 'testplug.c' || echo '$(srcdir)/'`testplug.c
 
+libldtestplug2_la-testplug2.lo: testplug2.c
+@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug2_la_CFLAGS) $(CFLAGS) -MT libldtestplug2_la-testplug2.lo -MD -MP -MF $(DEPDIR)/libldtestplug2_la-testplug2.Tpo -c -o libldtestplug2_la-testplug2.lo `test -f 'testplug2.c' || echo '$(srcdir)/'`testplug2.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libldtestplug2_la-testplug2.Tpo $(DEPDIR)/libldtestplug2_la-testplug2.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='testplug2.c' object='libldtestplug2_la-testplug2.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug2_la_CFLAGS) $(CFLAGS) -c -o libldtestplug2_la-testplug2.lo `test -f 'testplug2.c' || echo '$(srcdir)/'`testplug2.c
+
+libldtestplug3_la-testplug3.lo: testplug3.c
+@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug3_la_CFLAGS) $(CFLAGS) -MT libldtestplug3_la-testplug3.lo -MD -MP -MF $(DEPDIR)/libldtestplug3_la-testplug3.Tpo -c -o libldtestplug3_la-testplug3.lo `test -f 'testplug3.c' || echo '$(srcdir)/'`testplug3.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libldtestplug3_la-testplug3.Tpo $(DEPDIR)/libldtestplug3_la-testplug3.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='testplug3.c' object='libldtestplug3_la-testplug3.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libldtestplug3_la_CFLAGS) $(CFLAGS) -c -o libldtestplug3_la-testplug3.lo `test -f 'testplug3.c' || echo '$(srcdir)/'`testplug3.c
+
 .l.c:
 	$(am__skiplex) $(SHELL) $(YLWRAP) $< $(LEX_OUTPUT_ROOT).c $@ -- $(LEXCOMPILE)
 
diff --git a/ld/testplug2.c b/ld/testplug2.c
new file mode 100644
index 0000000..5e17b68
--- /dev/null
+++ b/ld/testplug2.c
@@ -0,0 +1,693 @@
+/* Test plugin for the GNU linker.  Check non-object IR file as well as
+   get_input_file, get_view and release_input_file interfaces.
+   Copyright (C) 2015 Free Software Foundation, Inc.
+
+   This file is part of the GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "plugin-api.h"
+#include "filenames.h"
+/* For ARRAY_SIZE macro only - we don't link the library itself.  */
+#include "libiberty.h"
+
+extern enum ld_plugin_status onload (struct ld_plugin_tv *tv);
+static enum ld_plugin_status onclaim_file (const struct ld_plugin_input_file *file,
+				int *claimed);
+static enum ld_plugin_status onall_symbols_read (void);
+static enum ld_plugin_status oncleanup (void);
+
+/* Helper for calling plugin api message function.  */
+#define TV_MESSAGE if (tv_message) (*tv_message)
+
+/* Struct for recording files to claim / files claimed.  */
+typedef struct claim_file
+{
+  struct claim_file *next;
+  struct ld_plugin_input_file file;
+  bfd_boolean claimed;
+  struct ld_plugin_symbol *symbols;
+  int n_syms_allocated;
+  int n_syms_used;
+} claim_file_t;
+
+/* Types of things that can be added at all symbols read time.  */
+typedef enum addfile_enum
+{
+  ADD_FILE,
+  ADD_LIB,
+  ADD_DIR
+} addfile_enum_t;
+
+/* Struct for recording files to add to final link.  */
+typedef struct add_file
+{
+  struct add_file *next;
+  const char *name;
+  addfile_enum_t type;
+} add_file_t;
+
+/* Helper macro for defining array of transfer vector tags and names.  */
+#define ADDENTRY(tag) { tag, #tag }
+
+/* Struct for looking up human-readable versions of tag names.  */
+typedef struct tag_name
+{
+  enum ld_plugin_tag tag;
+  const char *name;
+} tag_name_t;
+
+/* Array of all known tags and their names.  */
+static const tag_name_t tag_names[] =
+{
+  ADDENTRY(LDPT_NULL),
+  ADDENTRY(LDPT_API_VERSION),
+  ADDENTRY(LDPT_GOLD_VERSION),
+  ADDENTRY(LDPT_LINKER_OUTPUT),
+  ADDENTRY(LDPT_OPTION),
+  ADDENTRY(LDPT_REGISTER_CLAIM_FILE_HOOK),
+  ADDENTRY(LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK),
+  ADDENTRY(LDPT_REGISTER_CLEANUP_HOOK),
+  ADDENTRY(LDPT_ADD_SYMBOLS),
+  ADDENTRY(LDPT_GET_SYMBOLS),
+  ADDENTRY(LDPT_GET_SYMBOLS_V2),
+  ADDENTRY(LDPT_ADD_INPUT_FILE),
+  ADDENTRY(LDPT_MESSAGE),
+  ADDENTRY(LDPT_GET_INPUT_FILE),
+  ADDENTRY(LDPT_GET_VIEW),
+  ADDENTRY(LDPT_RELEASE_INPUT_FILE),
+  ADDENTRY(LDPT_ADD_INPUT_LIBRARY),
+  ADDENTRY(LDPT_OUTPUT_NAME),
+  ADDENTRY(LDPT_SET_EXTRA_LIBRARY_PATH),
+  ADDENTRY(LDPT_GNU_LD_VERSION)
+};
+
+/* Function pointers to cache hooks passed at onload time.  */
+static ld_plugin_register_claim_file tv_register_claim_file = 0;
+static ld_plugin_register_all_symbols_read tv_register_all_symbols_read = 0;
+static ld_plugin_register_cleanup tv_register_cleanup = 0;
+static ld_plugin_add_symbols tv_add_symbols = 0;
+static ld_plugin_get_symbols tv_get_symbols = 0;
+static ld_plugin_get_symbols tv_get_symbols_v2 = 0;
+static ld_plugin_add_input_file tv_add_input_file = 0;
+static ld_plugin_message tv_message = 0;
+static ld_plugin_get_input_file tv_get_input_file = 0;
+static ld_plugin_get_view tv_get_view = 0;
+static ld_plugin_release_input_file tv_release_input_file = 0;
+static ld_plugin_add_input_library tv_add_input_library = 0;
+static ld_plugin_set_extra_library_path tv_set_extra_library_path = 0;
+
+/* Other cached info from the transfer vector.  */
+static enum ld_plugin_output_file_type linker_output;
+static const char *output_name;
+
+/* Behaviour control flags set by plugin options.  */
+static enum ld_plugin_status onload_ret = LDPS_OK;
+static enum ld_plugin_status claim_file_ret = LDPS_OK;
+static enum ld_plugin_status all_symbols_read_ret = LDPS_OK;
+static enum ld_plugin_status cleanup_ret = LDPS_OK;
+static bfd_boolean register_claimfile_hook = TRUE;
+static bfd_boolean register_allsymbolsread_hook = FALSE;
+static bfd_boolean register_cleanup_hook = FALSE;
+static bfd_boolean dumpresolutions = FALSE;
+
+/* The master list of all claimable/claimed files.  */
+static claim_file_t *claimfiles_list = NULL;
+
+/* We keep a tail pointer for easy linking on the end.  */
+static claim_file_t **claimfiles_tail_chain_ptr = &claimfiles_list;
+
+/* The last claimed file added to the list, for receiving syms.  */
+static claim_file_t *last_claimfile = NULL;
+
+/* The master list of all files to add to the final link.  */
+static add_file_t *addfiles_list = NULL;
+
+/* We keep a tail pointer for easy linking on the end.  */
+static add_file_t **addfiles_tail_chain_ptr = &addfiles_list;
+
+/* Add a new claimfile on the end of the chain.  */
+static enum ld_plugin_status
+record_claim_file (const char *file, off_t filesize)
+{
+  claim_file_t *newfile;
+
+  newfile = malloc (sizeof *newfile);
+  if (!newfile)
+    return LDPS_ERR;
+  memset (newfile, 0, sizeof *newfile);
+  /* Only setup for now is remembering the name to look for.  */
+  newfile->file.name = file;
+  newfile->file.filesize = filesize;
+  /* Chain it on the end of the list.  */
+  *claimfiles_tail_chain_ptr = newfile;
+  claimfiles_tail_chain_ptr = &newfile->next;
+  /* Record it as active for receiving symbols to register.  */
+  last_claimfile = newfile;
+  return LDPS_OK;
+}
+
+/* Add a new addfile on the end of the chain.  */
+static enum ld_plugin_status
+record_add_file (const char *file, addfile_enum_t type)
+{
+  add_file_t *newfile;
+
+  newfile = malloc (sizeof *newfile);
+  if (!newfile)
+    return LDPS_ERR;
+  newfile->next = NULL;
+  newfile->name = file;
+  newfile->type = type;
+  /* Chain it on the end of the list.  */
+  *addfiles_tail_chain_ptr = newfile;
+  addfiles_tail_chain_ptr = &newfile->next;
+  return LDPS_OK;
+}
+
+/* Parse a command-line argument string into a symbol definition.
+   Symbol-strings follow the colon-separated format:
+	NAME:VERSION:def:vis:size:COMDATKEY
+   where the fields in capitals are strings and those in lower
+   case are integers.  We don't allow to specify a resolution as
+   doing so is not meaningful when calling the add symbols hook.  */
+static enum ld_plugin_status
+parse_symdefstr (const char *str, struct ld_plugin_symbol *sym)
+{
+  int n;
+  long long size;
+  const char *colon1, *colon2, *colon5;
+
+  /* Locate the colons separating the first two strings.  */
+  colon1 = strchr (str, ':');
+  if (!colon1)
+    return LDPS_ERR;
+  colon2 = strchr (colon1+1, ':');
+  if (!colon2)
+    return LDPS_ERR;
+  /* Name must not be empty (version may be).  */
+  if (colon1 == str)
+    return LDPS_ERR;
+
+  /* The fifth colon and trailing comdat key string are optional,
+     but the intermediate ones must all be present.  */
+  colon5 = strchr (colon2+1, ':');	/* Actually only third so far.  */
+  if (!colon5)
+    return LDPS_ERR;
+  colon5 = strchr (colon5+1, ':');	/* Hopefully fourth now.  */
+  if (!colon5)
+    return LDPS_ERR;
+  colon5 = strchr (colon5+1, ':');	/* Optional fifth now.  */
+
+  /* Finally we'll use sscanf to parse the numeric fields, then
+     we'll split out the strings which we need to allocate separate
+     storage for anyway so that we can add nul termination.  */
+  n = sscanf (colon2 + 1, "%i:%i:%lli", &sym->def, &sym->visibility, &size);
+  if (n != 3)
+    return LDPS_ERR;
+
+  /* Parsed successfully, so allocate strings and fill out fields.  */
+  sym->size = size;
+  sym->resolution = LDPR_UNKNOWN;
+  sym->name = malloc (colon1 - str + 1);
+  if (!sym->name)
+    return LDPS_ERR;
+  memcpy (sym->name, str, colon1 - str);
+  sym->name[colon1 - str] = '\0';
+  if (colon2 > (colon1 + 1))
+    {
+      sym->version = malloc (colon2 - colon1);
+      if (!sym->version)
+	return LDPS_ERR;
+      memcpy (sym->version, colon1 + 1, colon2 - (colon1 + 1));
+      sym->version[colon2 - (colon1 + 1)] = '\0';
+    }
+  else
+    sym->version = NULL;
+  if (colon5 && colon5[1])
+    {
+      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
+      if (!sym->comdat_key)
+	return LDPS_ERR;
+      strcpy (sym->comdat_key, colon5 + 1);
+    }
+  else
+    sym->comdat_key = 0;
+  return LDPS_OK;
+}
+
+/* Record a symbol to be added for the last-added claimfile.  */
+static enum ld_plugin_status
+record_claimed_file_symbol (const char *symdefstr)
+{
+  struct ld_plugin_symbol sym;
+
+  /* Can't add symbols except as belonging to claimed files.  */
+  if (!last_claimfile)
+    return LDPS_ERR;
+
+  /* If string doesn't parse correctly, give an error.  */
+  if (parse_symdefstr (symdefstr, &sym) != LDPS_OK)
+    return LDPS_ERR;
+
+  /* Check for enough space, resize array if needed, and add it.  */
+  if (last_claimfile->n_syms_allocated == last_claimfile->n_syms_used)
+    {
+      int new_n_syms = last_claimfile->n_syms_allocated
+			? 2 * last_claimfile->n_syms_allocated
+			: 10;
+      last_claimfile->symbols = realloc (last_claimfile->symbols,
+			new_n_syms * sizeof *last_claimfile->symbols);
+      if (!last_claimfile->symbols)
+	return LDPS_ERR;
+      last_claimfile->n_syms_allocated = new_n_syms;
+    }
+  last_claimfile->symbols[last_claimfile->n_syms_used++] = sym;
+
+  return LDPS_OK;
+}
+
+/* Records the status to return from one of the registered hooks.  */
+static enum ld_plugin_status
+set_ret_val (const char *whichval, enum ld_plugin_status retval)
+{
+  if (!strcmp ("onload", whichval))
+    onload_ret = retval;
+  else if (!strcmp ("claimfile", whichval))
+    claim_file_ret = retval;
+  else if (!strcmp ("allsymbolsread", whichval))
+    all_symbols_read_ret = retval;
+  else if (!strcmp ("cleanup", whichval))
+    cleanup_ret = retval;
+  else
+    return LDPS_ERR;
+  return LDPS_OK;
+}
+
+/* Records hooks which should be registered.  */
+static enum ld_plugin_status
+set_register_hook (const char *whichhook, bfd_boolean yesno)
+{
+  if (!strcmp ("claimfile", whichhook))
+    register_claimfile_hook = yesno;
+  else if (!strcmp ("allsymbolsread", whichhook))
+    register_allsymbolsread_hook = yesno;
+  else if (!strcmp ("cleanup", whichhook))
+    register_cleanup_hook = yesno;
+  else
+    return LDPS_ERR;
+  return LDPS_OK;
+}
+
+/* Determine type of plugin option and pass to individual parsers.  */
+static enum ld_plugin_status
+parse_option (const char *opt)
+{
+  if (!strncmp ("fail", opt, 4))
+    return set_ret_val (opt + 4, LDPS_ERR);
+  else if (!strncmp ("pass", opt, 4))
+    return set_ret_val (opt + 4, LDPS_OK);
+  else if (!strncmp ("register", opt, 8))
+    return set_register_hook (opt + 8, TRUE);
+  else if (!strncmp ("noregister", opt, 10))
+    return set_register_hook (opt + 10, FALSE);
+  else if (!strncmp ("claim:", opt, 6))
+    return record_claim_file (opt + 6, 0);
+  else if (!strncmp ("sym:", opt, 4))
+    return record_claimed_file_symbol (opt + 4);
+  else if (!strncmp ("add:", opt, 4))
+    return record_add_file (opt + 4, ADD_FILE);
+  else if (!strncmp ("lib:", opt, 4))
+    return record_add_file (opt + 4, ADD_LIB);
+  else if (!strncmp ("dir:", opt, 4))
+    return record_add_file (opt + 4, ADD_DIR);
+  else if (!strcmp ("dumpresolutions", opt))
+    dumpresolutions = TRUE;
+  else
+    return LDPS_ERR;
+  return LDPS_OK;
+}
+
+/* Output contents of transfer vector array entry in human-readable form.  */
+static void
+dump_tv_tag (size_t n, struct ld_plugin_tv *tv)
+{
+  size_t tag;
+  char unknownbuf[40];
+  const char *name;
+
+  for (tag = 0; tag < ARRAY_SIZE (tag_names); tag++)
+    if (tag_names[tag].tag == tv->tv_tag)
+      break;
+  sprintf (unknownbuf, "unknown tag #%d", tv->tv_tag);
+  name = (tag < ARRAY_SIZE (tag_names)) ? tag_names[tag].name : unknownbuf;
+  switch (tv->tv_tag)
+    {
+      case LDPT_OPTION:
+      case LDPT_OUTPUT_NAME:
+	TV_MESSAGE (LDPL_INFO, "tv[%d]: %s '%s'", n, name,
+		    tv->tv_u.tv_string);
+        break;
+      case LDPT_REGISTER_CLAIM_FILE_HOOK:
+      case LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK:
+      case LDPT_REGISTER_CLEANUP_HOOK:
+      case LDPT_ADD_SYMBOLS:
+      case LDPT_GET_SYMBOLS:
+      case LDPT_GET_SYMBOLS_V2:
+      case LDPT_ADD_INPUT_FILE:
+      case LDPT_MESSAGE:
+      case LDPT_GET_INPUT_FILE:
+      case LDPT_GET_VIEW:
+      case LDPT_RELEASE_INPUT_FILE:
+      case LDPT_ADD_INPUT_LIBRARY:
+      case LDPT_SET_EXTRA_LIBRARY_PATH:
+	TV_MESSAGE (LDPL_INFO, "tv[%d]: %s func@0x%p", n, name,
+		    (void *)(tv->tv_u.tv_message));
+        break;
+      case LDPT_NULL:
+      case LDPT_API_VERSION:
+      case LDPT_GOLD_VERSION:
+      case LDPT_LINKER_OUTPUT:
+      case LDPT_GNU_LD_VERSION:
+      default:
+	TV_MESSAGE (LDPL_INFO, "tv[%d]: %s value %W (%d)", n, name,
+		    (bfd_vma)tv->tv_u.tv_val, tv->tv_u.tv_val);
+	break;
+    }
+}
+
+/* Handle/record information received in a transfer vector entry.  */
+static enum ld_plugin_status
+parse_tv_tag (struct ld_plugin_tv *tv)
+{
+#define SETVAR(x) x = tv->tv_u.x
+  switch (tv->tv_tag)
+    {
+      case LDPT_OPTION:
+	return parse_option (tv->tv_u.tv_string);
+      case LDPT_NULL:
+      case LDPT_GOLD_VERSION:
+      case LDPT_GNU_LD_VERSION:
+      case LDPT_API_VERSION:
+      default:
+	break;
+      case LDPT_OUTPUT_NAME:
+	output_name = tv->tv_u.tv_string;
+	break;
+      case LDPT_LINKER_OUTPUT:
+	linker_output = tv->tv_u.tv_val;
+	break;
+      case LDPT_REGISTER_CLAIM_FILE_HOOK:
+	SETVAR(tv_register_claim_file);
+	break;
+      case LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK:
+	SETVAR(tv_register_all_symbols_read);
+	break;
+      case LDPT_REGISTER_CLEANUP_HOOK:
+	SETVAR(tv_register_cleanup);
+	break;
+      case LDPT_ADD_SYMBOLS:
+	SETVAR(tv_add_symbols);
+	break;
+      case LDPT_GET_SYMBOLS:
+	SETVAR(tv_get_symbols);
+	break;
+      case LDPT_GET_SYMBOLS_V2:
+	tv_get_symbols_v2 = tv->tv_u.tv_get_symbols;
+	break;
+      case LDPT_ADD_INPUT_FILE:
+	SETVAR(tv_add_input_file);
+	break;
+      case LDPT_MESSAGE:
+	SETVAR(tv_message);
+	break;
+      case LDPT_GET_INPUT_FILE:
+	SETVAR(tv_get_input_file);
+	break;
+      case LDPT_GET_VIEW:
+	SETVAR(tv_get_view);
+	break;
+      case LDPT_RELEASE_INPUT_FILE:
+	SETVAR(tv_release_input_file);
+	break;
+      case LDPT_ADD_INPUT_LIBRARY:
+	SETVAR(tv_add_input_library);
+	break;
+      case LDPT_SET_EXTRA_LIBRARY_PATH:
+	SETVAR(tv_set_extra_library_path);
+	break;
+    }
+#undef SETVAR
+  return LDPS_OK;
+}
+
+/* Standard plugin API entry point.  */
+enum ld_plugin_status
+onload (struct ld_plugin_tv *tv)
+{
+  enum ld_plugin_status rv;
+
+  /* This plugin does nothing but dump the tv array.  It would
+     be an error if this function was called without one.  */
+  if (!tv)
+    return LDPS_ERR;
+
+  /* First entry should always be LDPT_MESSAGE, letting us get
+     hold of it easily so we can send output straight away.  */
+  if (tv[0].tv_tag == LDPT_MESSAGE)
+    tv_message = tv[0].tv_u.tv_message;
+
+  do
+    if ((rv = parse_tv_tag (tv)) != LDPS_OK)
+      return rv;
+  while ((tv++)->tv_tag != LDPT_NULL);
+
+  /* Register hooks only if instructed by options.  */
+  if (register_claimfile_hook)
+    {
+      if (!tv_register_claim_file)
+	{
+	  TV_MESSAGE (LDPL_FATAL, "No register_claim_file hook");
+	  fflush (NULL);
+	  return LDPS_ERR;
+	}
+      (*tv_register_claim_file) (onclaim_file);
+    }
+  if (register_allsymbolsread_hook)
+    {
+      if (!tv_register_all_symbols_read)
+	{
+	  TV_MESSAGE (LDPL_FATAL, "No register_all_symbols_read hook");
+	  fflush (NULL);
+	  return LDPS_ERR;
+	}
+      (*tv_register_all_symbols_read) (onall_symbols_read);
+    }
+  if (register_cleanup_hook)
+    {
+      if (!tv_register_cleanup)
+	{
+	  TV_MESSAGE (LDPL_FATAL, "No register_cleanup hook");
+	  fflush (NULL);
+	  return LDPS_ERR;
+	}
+      (*tv_register_cleanup) (oncleanup);
+    }
+
+  /* Claim testsuite/ld-plugin/func.c, standalone or in a library.  Its
+     size must be SIZE_OF_FUNC_C bytes.  */
+#define SIZE_OF_FUNC_C	248
+  if (onload_ret == LDPS_OK
+      && (record_claim_file ("func.c", SIZE_OF_FUNC_C) != LDPS_OK
+	  || record_claimed_file_symbol ("func::0:0:0") != LDPS_OK
+	  || record_claimed_file_symbol ("_func::0:0:0") != LDPS_OK
+	  || record_claim_file ("libfunc.a", SIZE_OF_FUNC_C) != LDPS_OK
+	  || record_claimed_file_symbol ("func::0:0:0") != LDPS_OK
+	  || record_claimed_file_symbol ("_func::0:0:0") != LDPS_OK))
+    onload_ret = LDPS_ERR;
+
+  return onload_ret;
+}
+
+char *
+xstrdup (const char *s)
+{
+  size_t len = strlen (s) + 1;
+  char *ret = malloc (len + 1);
+  return (char *) memcpy (ret, s, len);
+}
+
+/* Standard plugin API registerable hook.  */
+static enum ld_plugin_status
+onclaim_file (const struct ld_plugin_input_file *file, int *claimed)
+{
+  /* Let's see if we want to claim this file.  */
+  claim_file_t *claimfile = claimfiles_list;
+  size_t len = strlen (file->name);
+  char *name = xstrdup (file->name);
+  char *p = name + len;
+  bfd_boolean islib;
+
+  /* Only match the file name without the directory part.  */
+  islib = *p == 'a' && *(p - 1) == '.';
+  for (; p != name; p--)
+    if (IS_DIR_SEPARATOR (*p))
+      {
+	p++;
+	break;
+      }
+
+  while (claimfile)
+    {
+      /* Claim the file only if the file name and size match and don't
+	 match the whole library.  */
+      if (!strcmp (p, claimfile->file.name)
+	  && claimfile->file.filesize == file->filesize
+	  && (!islib || file->offset != 0))
+	break;
+      claimfile = claimfile->next;
+    }
+
+  free (name);
+
+  /* If we decided to claim it, record that fact, and add any symbols
+     that were defined for it by plugin options.  */
+  *claimed = (claimfile != 0);
+  if (claimfile)
+    {
+      claimfile->claimed = TRUE;
+      claimfile->file = *file;
+      if (claimfile->n_syms_used && !tv_add_symbols)
+	return LDPS_ERR;
+      else if (claimfile->n_syms_used)
+	return (*tv_add_symbols) (claimfile->file.handle,
+				claimfile->n_syms_used, claimfile->symbols);
+    }
+
+  return claim_file_ret;
+}
+
+/* Standard plugin API registerable hook.  */
+static enum ld_plugin_status
+onall_symbols_read (void)
+{
+  static const char *resolutions[] =
+    {
+      "LDPR_UNKNOWN",
+      "LDPR_UNDEF",
+      "LDPR_PREVAILING_DEF",
+      "LDPR_PREVAILING_DEF_IRONLY",
+      "LDPR_PREEMPTED_REG",
+      "LDPR_PREEMPTED_IR",
+      "LDPR_RESOLVED_IR",
+      "LDPR_RESOLVED_EXEC",
+      "LDPR_RESOLVED_DYN",
+      "LDPR_PREVAILING_DEF_IRONLY_EXP",
+    };
+  claim_file_t *claimfile = dumpresolutions ? claimfiles_list : NULL;
+  add_file_t *addfile = addfiles_list;
+  struct ld_plugin_input_file file;
+  const void *view;
+  char buffer[30];
+  int fd;
+  char *filename;
+  TV_MESSAGE (LDPL_INFO, "hook called: all symbols read.");
+  for ( ; claimfile; claimfile = claimfile->next)
+    {
+      enum ld_plugin_status rv;
+      int n;
+      if (claimfile->n_syms_used && !tv_get_symbols_v2)
+	return LDPS_ERR;
+      else if (!claimfile->n_syms_used)
+        continue;
+      else if (!claimfile->file.handle)
+        continue;
+      rv = tv_get_input_file (claimfile->file.handle, &file);
+      if (rv != LDPS_OK)
+	return rv;
+      TV_MESSAGE (LDPL_INFO, "Input: %s (%s)", file.name,
+		  claimfile->file.name);
+      rv = tv_get_view (claimfile->file.handle, &view);
+      if (rv != LDPS_OK)
+	return rv;
+#define EXPECTED_VIEW "/* The first line of this file must match the expectation of"
+#define EXPECTED_VIEW_LENGTH (sizeof (EXPECTED_VIEW) - 1)
+      if (file.filesize != SIZE_OF_FUNC_C
+	  || SIZE_OF_FUNC_C < sizeof EXPECTED_VIEW_LENGTH
+	  || memcmp (view, EXPECTED_VIEW, EXPECTED_VIEW_LENGTH) != 0)
+	{
+	  char result[EXPECTED_VIEW_LENGTH + 1];
+	  memcpy (result, view, sizeof (result));
+	  result[EXPECTED_VIEW_LENGTH] = '\0';
+	  TV_MESSAGE (LDPL_INFO, "Incorrect view:");
+	  TV_MESSAGE (LDPL_INFO, "  Expect: " EXPECTED_VIEW);
+	  TV_MESSAGE (LDPL_INFO, "  Result: %s", result);
+	}
+      rv = tv_get_symbols_v2 (claimfile->file.handle, claimfile->n_syms_used,
+			      claimfile->symbols);
+      if (rv != LDPS_OK)
+	return rv;
+      for (n = 0; n < claimfile->n_syms_used; n++)
+	TV_MESSAGE (LDPL_INFO, "Sym: '%s%s%s' Resolution: %s",
+		    claimfile->symbols[n].name,
+		    claimfile->symbols[n].version ? "@" : "",
+		    (claimfile->symbols[n].version
+		     ? claimfile->symbols[n].version : ""),
+		    resolutions[claimfile->symbols[n].resolution]);
+      fd = claimfile->file.fd;
+      filename = xstrdup (claimfile->file.name);
+      rv = tv_release_input_file (claimfile->file.handle);
+      if (rv != LDPS_OK)
+	{
+	  free (filename);
+	  return rv;
+	}
+      if (read (fd, buffer, sizeof (buffer)) >= 0)
+	{
+	  rv == LDPS_ERR;
+	  TV_MESSAGE (LDPL_FATAL, "Unreleased file descriptor on: %s",
+		      claimfile->file.name);
+	}
+      free (filename);
+    }
+  for ( ; addfile ; addfile = addfile->next)
+    {
+      enum ld_plugin_status rv;
+      if (addfile->type == ADD_LIB && tv_add_input_library)
+	rv = (*tv_add_input_library) (addfile->name);
+      else if (addfile->type == ADD_FILE && tv_add_input_file)
+	rv = (*tv_add_input_file) (addfile->name);
+      else if (addfile->type == ADD_DIR && tv_set_extra_library_path)
+	rv = (*tv_set_extra_library_path) (addfile->name);
+      else
+	rv = LDPS_ERR;
+      if (rv != LDPS_OK)
+	return rv;
+    }
+  fflush (NULL);
+  return all_symbols_read_ret;
+}
+
+/* Standard plugin API registerable hook.  */
+static enum ld_plugin_status
+oncleanup (void)
+{
+  TV_MESSAGE (LDPL_INFO, "hook called: cleanup.");
+  fflush (NULL);
+  return cleanup_ret;
+}
diff --git a/ld/testplug3.c b/ld/testplug3.c
new file mode 100644
index 0000000..a45991b
--- /dev/null
+++ b/ld/testplug3.c
@@ -0,0 +1,674 @@
+/* Test plugin for the GNU linker.  Check non-object IR file and calling
+   release_input_file from onclaim_file.
+   Copyright (C) 2015 Free Software Foundation, Inc.
+
+   This file is part of the GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "plugin-api.h"
+#include "filenames.h"
+/* For ARRAY_SIZE macro only - we don't link the library itself.  */
+#include "libiberty.h"
+
+extern enum ld_plugin_status onload (struct ld_plugin_tv *tv);
+static enum ld_plugin_status onclaim_file (const struct ld_plugin_input_file *file,
+				int *claimed);
+static enum ld_plugin_status onall_symbols_read (void);
+static enum ld_plugin_status oncleanup (void);
+
+/* Helper for calling plugin api message function.  */
+#define TV_MESSAGE if (tv_message) (*tv_message)
+
+/* Struct for recording files to claim / files claimed.  */
+typedef struct claim_file
+{
+  struct claim_file *next;
+  struct ld_plugin_input_file file;
+  bfd_boolean claimed;
+  struct ld_plugin_symbol *symbols;
+  int n_syms_allocated;
+  int n_syms_used;
+} claim_file_t;
+
+/* Types of things that can be added at all symbols read time.  */
+typedef enum addfile_enum
+{
+  ADD_FILE,
+  ADD_LIB,
+  ADD_DIR
+} addfile_enum_t;
+
+/* Struct for recording files to add to final link.  */
+typedef struct add_file
+{
+  struct add_file *next;
+  const char *name;
+  addfile_enum_t type;
+} add_file_t;
+
+/* Helper macro for defining array of transfer vector tags and names.  */
+#define ADDENTRY(tag) { tag, #tag }
+
+/* Struct for looking up human-readable versions of tag names.  */
+typedef struct tag_name
+{
+  enum ld_plugin_tag tag;
+  const char *name;
+} tag_name_t;
+
+/* Array of all known tags and their names.  */
+static const tag_name_t tag_names[] =
+{
+  ADDENTRY(LDPT_NULL),
+  ADDENTRY(LDPT_API_VERSION),
+  ADDENTRY(LDPT_GOLD_VERSION),
+  ADDENTRY(LDPT_LINKER_OUTPUT),
+  ADDENTRY(LDPT_OPTION),
+  ADDENTRY(LDPT_REGISTER_CLAIM_FILE_HOOK),
+  ADDENTRY(LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK),
+  ADDENTRY(LDPT_REGISTER_CLEANUP_HOOK),
+  ADDENTRY(LDPT_ADD_SYMBOLS),
+  ADDENTRY(LDPT_GET_SYMBOLS),
+  ADDENTRY(LDPT_GET_SYMBOLS_V2),
+  ADDENTRY(LDPT_ADD_INPUT_FILE),
+  ADDENTRY(LDPT_MESSAGE),
+  ADDENTRY(LDPT_GET_INPUT_FILE),
+  ADDENTRY(LDPT_GET_VIEW),
+  ADDENTRY(LDPT_RELEASE_INPUT_FILE),
+  ADDENTRY(LDPT_ADD_INPUT_LIBRARY),
+  ADDENTRY(LDPT_OUTPUT_NAME),
+  ADDENTRY(LDPT_SET_EXTRA_LIBRARY_PATH),
+  ADDENTRY(LDPT_GNU_LD_VERSION)
+};
+
+/* Function pointers to cache hooks passed at onload time.  */
+static ld_plugin_register_claim_file tv_register_claim_file = 0;
+static ld_plugin_register_all_symbols_read tv_register_all_symbols_read = 0;
+static ld_plugin_register_cleanup tv_register_cleanup = 0;
+static ld_plugin_add_symbols tv_add_symbols = 0;
+static ld_plugin_get_symbols tv_get_symbols = 0;
+static ld_plugin_get_symbols tv_get_symbols_v2 = 0;
+static ld_plugin_add_input_file tv_add_input_file = 0;
+static ld_plugin_message tv_message = 0;
+static ld_plugin_get_input_file tv_get_input_file = 0;
+static ld_plugin_get_view tv_get_view = 0;
+static ld_plugin_release_input_file tv_release_input_file = 0;
+static ld_plugin_add_input_library tv_add_input_library = 0;
+static ld_plugin_set_extra_library_path tv_set_extra_library_path = 0;
+
+/* Other cached info from the transfer vector.  */
+static enum ld_plugin_output_file_type linker_output;
+static const char *output_name;
+
+/* Behaviour control flags set by plugin options.  */
+static enum ld_plugin_status onload_ret = LDPS_OK;
+static enum ld_plugin_status claim_file_ret = LDPS_OK;
+static enum ld_plugin_status all_symbols_read_ret = LDPS_OK;
+static enum ld_plugin_status cleanup_ret = LDPS_OK;
+static bfd_boolean register_claimfile_hook = TRUE;
+static bfd_boolean register_allsymbolsread_hook = FALSE;
+static bfd_boolean register_cleanup_hook = FALSE;
+static bfd_boolean dumpresolutions = FALSE;
+
+/* The master list of all claimable/claimed files.  */
+static claim_file_t *claimfiles_list = NULL;
+
+/* We keep a tail pointer for easy linking on the end.  */
+static claim_file_t **claimfiles_tail_chain_ptr = &claimfiles_list;
+
+/* The last claimed file added to the list, for receiving syms.  */
+static claim_file_t *last_claimfile = NULL;
+
+/* The master list of all files to add to the final link.  */
+static add_file_t *addfiles_list = NULL;
+
+/* We keep a tail pointer for easy linking on the end.  */
+static add_file_t **addfiles_tail_chain_ptr = &addfiles_list;
+
+/* Add a new claimfile on the end of the chain.  */
+static enum ld_plugin_status
+record_claim_file (const char *file, off_t filesize)
+{
+  claim_file_t *newfile;
+
+  newfile = malloc (sizeof *newfile);
+  if (!newfile)
+    return LDPS_ERR;
+  memset (newfile, 0, sizeof *newfile);
+  /* Only setup for now is remembering the name to look for.  */
+  newfile->file.name = file;
+  newfile->file.filesize = filesize;
+  /* Chain it on the end of the list.  */
+  *claimfiles_tail_chain_ptr = newfile;
+  claimfiles_tail_chain_ptr = &newfile->next;
+  /* Record it as active for receiving symbols to register.  */
+  last_claimfile = newfile;
+  return LDPS_OK;
+}
+
+/* Add a new addfile on the end of the chain.  */
+static enum ld_plugin_status
+record_add_file (const char *file, addfile_enum_t type)
+{
+  add_file_t *newfile;
+
+  newfile = malloc (sizeof *newfile);
+  if (!newfile)
+    return LDPS_ERR;
+  newfile->next = NULL;
+  newfile->name = file;
+  newfile->type = type;
+  /* Chain it on the end of the list.  */
+  *addfiles_tail_chain_ptr = newfile;
+  addfiles_tail_chain_ptr = &newfile->next;
+  return LDPS_OK;
+}
+
+/* Parse a command-line argument string into a symbol definition.
+   Symbol-strings follow the colon-separated format:
+	NAME:VERSION:def:vis:size:COMDATKEY
+   where the fields in capitals are strings and those in lower
+   case are integers.  We don't allow to specify a resolution as
+   doing so is not meaningful when calling the add symbols hook.  */
+static enum ld_plugin_status
+parse_symdefstr (const char *str, struct ld_plugin_symbol *sym)
+{
+  int n;
+  long long size;
+  const char *colon1, *colon2, *colon5;
+
+  /* Locate the colons separating the first two strings.  */
+  colon1 = strchr (str, ':');
+  if (!colon1)
+    return LDPS_ERR;
+  colon2 = strchr (colon1+1, ':');
+  if (!colon2)
+    return LDPS_ERR;
+  /* Name must not be empty (version may be).  */
+  if (colon1 == str)
+    return LDPS_ERR;
+
+  /* The fifth colon and trailing comdat key string are optional,
+     but the intermediate ones must all be present.  */
+  colon5 = strchr (colon2+1, ':');	/* Actually only third so far.  */
+  if (!colon5)
+    return LDPS_ERR;
+  colon5 = strchr (colon5+1, ':');	/* Hopefully fourth now.  */
+  if (!colon5)
+    return LDPS_ERR;
+  colon5 = strchr (colon5+1, ':');	/* Optional fifth now.  */
+
+  /* Finally we'll use sscanf to parse the numeric fields, then
+     we'll split out the strings which we need to allocate separate
+     storage for anyway so that we can add nul termination.  */
+  n = sscanf (colon2 + 1, "%i:%i:%lli", &sym->def, &sym->visibility, &size);
+  if (n != 3)
+    return LDPS_ERR;
+
+  /* Parsed successfully, so allocate strings and fill out fields.  */
+  sym->size = size;
+  sym->resolution = LDPR_UNKNOWN;
+  sym->name = malloc (colon1 - str + 1);
+  if (!sym->name)
+    return LDPS_ERR;
+  memcpy (sym->name, str, colon1 - str);
+  sym->name[colon1 - str] = '\0';
+  if (colon2 > (colon1 + 1))
+    {
+      sym->version = malloc (colon2 - colon1);
+      if (!sym->version)
+	return LDPS_ERR;
+      memcpy (sym->version, colon1 + 1, colon2 - (colon1 + 1));
+      sym->version[colon2 - (colon1 + 1)] = '\0';
+    }
+  else
+    sym->version = NULL;
+  if (colon5 && colon5[1])
+    {
+      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
+      if (!sym->comdat_key)
+	return LDPS_ERR;
+      strcpy (sym->comdat_key, colon5 + 1);
+    }
+  else
+    sym->comdat_key = 0;
+  return LDPS_OK;
+}
+
+/* Record a symbol to be added for the last-added claimfile.  */
+static enum ld_plugin_status
+record_claimed_file_symbol (const char *symdefstr)
+{
+  struct ld_plugin_symbol sym;
+
+  /* Can't add symbols except as belonging to claimed files.  */
+  if (!last_claimfile)
+    return LDPS_ERR;
+
+  /* If string doesn't parse correctly, give an error.  */
+  if (parse_symdefstr (symdefstr, &sym) != LDPS_OK)
+    return LDPS_ERR;
+
+  /* Check for enough space, resize array if needed, and add it.  */
+  if (last_claimfile->n_syms_allocated == last_claimfile->n_syms_used)
+    {
+      int new_n_syms = last_claimfile->n_syms_allocated
+			? 2 * last_claimfile->n_syms_allocated
+			: 10;
+      last_claimfile->symbols = realloc (last_claimfile->symbols,
+			new_n_syms * sizeof *last_claimfile->symbols);
+      if (!last_claimfile->symbols)
+	return LDPS_ERR;
+      last_claimfile->n_syms_allocated = new_n_syms;
+    }
+  last_claimfile->symbols[last_claimfile->n_syms_used++] = sym;
+
+  return LDPS_OK;
+}
+
+/* Records the status to return from one of the registered hooks.  */
+static enum ld_plugin_status
+set_ret_val (const char *whichval, enum ld_plugin_status retval)
+{
+  if (!strcmp ("onload", whichval))
+    onload_ret = retval;
+  else if (!strcmp ("claimfile", whichval))
+    claim_file_ret = retval;
+  else if (!strcmp ("allsymbolsread", whichval))
+    all_symbols_read_ret = retval;
+  else if (!strcmp ("cleanup", whichval))
+    cleanup_ret = retval;
+  else
+    return LDPS_ERR;
+  return LDPS_OK;
+}
+
+/* Records hooks which should be registered.  */
+static enum ld_plugin_status
+set_register_hook (const char *whichhook, bfd_boolean yesno)
+{
+  if (!strcmp ("claimfile", whichhook))
+    register_claimfile_hook = yesno;
+  else if (!strcmp ("allsymbolsread", whichhook))
+    register_allsymbolsread_hook = yesno;
+  else if (!strcmp ("cleanup", whichhook))
+    register_cleanup_hook = yesno;
+  else
+    return LDPS_ERR;
+  return LDPS_OK;
+}
+
+/* Determine type of plugin option and pass to individual parsers.  */
+static enum ld_plugin_status
+parse_option (const char *opt)
+{
+  if (!strncmp ("fail", opt, 4))
+    return set_ret_val (opt + 4, LDPS_ERR);
+  else if (!strncmp ("pass", opt, 4))
+    return set_ret_val (opt + 4, LDPS_OK);
+  else if (!strncmp ("register", opt, 8))
+    return set_register_hook (opt + 8, TRUE);
+  else if (!strncmp ("noregister", opt, 10))
+    return set_register_hook (opt + 10, FALSE);
+  else if (!strncmp ("claim:", opt, 6))
+    return record_claim_file (opt + 6, 0);
+  else if (!strncmp ("sym:", opt, 4))
+    return record_claimed_file_symbol (opt + 4);
+  else if (!strncmp ("add:", opt, 4))
+    return record_add_file (opt + 4, ADD_FILE);
+  else if (!strncmp ("lib:", opt, 4))
+    return record_add_file (opt + 4, ADD_LIB);
+  else if (!strncmp ("dir:", opt, 4))
+    return record_add_file (opt + 4, ADD_DIR);
+  else if (!strcmp ("dumpresolutions", opt))
+    dumpresolutions = TRUE;
+  else
+    return LDPS_ERR;
+  return LDPS_OK;
+}
+
+/* Output contents of transfer vector array entry in human-readable form.  */
+static void
+dump_tv_tag (size_t n, struct ld_plugin_tv *tv)
+{
+  size_t tag;
+  char unknownbuf[40];
+  const char *name;
+
+  for (tag = 0; tag < ARRAY_SIZE (tag_names); tag++)
+    if (tag_names[tag].tag == tv->tv_tag)
+      break;
+  sprintf (unknownbuf, "unknown tag #%d", tv->tv_tag);
+  name = (tag < ARRAY_SIZE (tag_names)) ? tag_names[tag].name : unknownbuf;
+  switch (tv->tv_tag)
+    {
+      case LDPT_OPTION:
+      case LDPT_OUTPUT_NAME:
+	TV_MESSAGE (LDPL_INFO, "tv[%d]: %s '%s'", n, name,
+		    tv->tv_u.tv_string);
+        break;
+      case LDPT_REGISTER_CLAIM_FILE_HOOK:
+      case LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK:
+      case LDPT_REGISTER_CLEANUP_HOOK:
+      case LDPT_ADD_SYMBOLS:
+      case LDPT_GET_SYMBOLS:
+      case LDPT_GET_SYMBOLS_V2:
+      case LDPT_ADD_INPUT_FILE:
+      case LDPT_MESSAGE:
+      case LDPT_GET_INPUT_FILE:
+      case LDPT_GET_VIEW:
+      case LDPT_RELEASE_INPUT_FILE:
+      case LDPT_ADD_INPUT_LIBRARY:
+      case LDPT_SET_EXTRA_LIBRARY_PATH:
+	TV_MESSAGE (LDPL_INFO, "tv[%d]: %s func@0x%p", n, name,
+		    (void *)(tv->tv_u.tv_message));
+        break;
+      case LDPT_NULL:
+      case LDPT_API_VERSION:
+      case LDPT_GOLD_VERSION:
+      case LDPT_LINKER_OUTPUT:
+      case LDPT_GNU_LD_VERSION:
+      default:
+	TV_MESSAGE (LDPL_INFO, "tv[%d]: %s value %W (%d)", n, name,
+		    (bfd_vma)tv->tv_u.tv_val, tv->tv_u.tv_val);
+	break;
+    }
+}
+
+/* Handle/record information received in a transfer vector entry.  */
+static enum ld_plugin_status
+parse_tv_tag (struct ld_plugin_tv *tv)
+{
+#define SETVAR(x) x = tv->tv_u.x
+  switch (tv->tv_tag)
+    {
+      case LDPT_OPTION:
+	return parse_option (tv->tv_u.tv_string);
+      case LDPT_NULL:
+      case LDPT_GOLD_VERSION:
+      case LDPT_GNU_LD_VERSION:
+      case LDPT_API_VERSION:
+      default:
+	break;
+      case LDPT_OUTPUT_NAME:
+	output_name = tv->tv_u.tv_string;
+	break;
+      case LDPT_LINKER_OUTPUT:
+	linker_output = tv->tv_u.tv_val;
+	break;
+      case LDPT_REGISTER_CLAIM_FILE_HOOK:
+	SETVAR(tv_register_claim_file);
+	break;
+      case LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK:
+	SETVAR(tv_register_all_symbols_read);
+	break;
+      case LDPT_REGISTER_CLEANUP_HOOK:
+	SETVAR(tv_register_cleanup);
+	break;
+      case LDPT_ADD_SYMBOLS:
+	SETVAR(tv_add_symbols);
+	break;
+      case LDPT_GET_SYMBOLS:
+	SETVAR(tv_get_symbols);
+	break;
+      case LDPT_GET_SYMBOLS_V2:
+	tv_get_symbols_v2 = tv->tv_u.tv_get_symbols;
+	break;
+      case LDPT_ADD_INPUT_FILE:
+	SETVAR(tv_add_input_file);
+	break;
+      case LDPT_MESSAGE:
+	SETVAR(tv_message);
+	break;
+      case LDPT_GET_INPUT_FILE:
+	SETVAR(tv_get_input_file);
+	break;
+      case LDPT_GET_VIEW:
+	SETVAR(tv_get_view);
+	break;
+      case LDPT_RELEASE_INPUT_FILE:
+	SETVAR(tv_release_input_file);
+	break;
+      case LDPT_ADD_INPUT_LIBRARY:
+	SETVAR(tv_add_input_library);
+	break;
+      case LDPT_SET_EXTRA_LIBRARY_PATH:
+	SETVAR(tv_set_extra_library_path);
+	break;
+    }
+#undef SETVAR
+  return LDPS_OK;
+}
+
+/* Standard plugin API entry point.  */
+enum ld_plugin_status
+onload (struct ld_plugin_tv *tv)
+{
+  enum ld_plugin_status rv;
+
+  /* This plugin does nothing but dump the tv array.  It would
+     be an error if this function was called without one.  */
+  if (!tv)
+    return LDPS_ERR;
+
+  /* First entry should always be LDPT_MESSAGE, letting us get
+     hold of it easily so we can send output straight away.  */
+  if (tv[0].tv_tag == LDPT_MESSAGE)
+    tv_message = tv[0].tv_u.tv_message;
+
+  do
+    if ((rv = parse_tv_tag (tv)) != LDPS_OK)
+      return rv;
+  while ((tv++)->tv_tag != LDPT_NULL);
+
+  /* Register hooks only if instructed by options.  */
+  if (register_claimfile_hook)
+    {
+      if (!tv_register_claim_file)
+	{
+	  TV_MESSAGE (LDPL_FATAL, "No register_claim_file hook");
+	  fflush (NULL);
+	  return LDPS_ERR;
+	}
+      (*tv_register_claim_file) (onclaim_file);
+    }
+  if (register_allsymbolsread_hook)
+    {
+      if (!tv_register_all_symbols_read)
+	{
+	  TV_MESSAGE (LDPL_FATAL, "No register_all_symbols_read hook");
+	  fflush (NULL);
+	  return LDPS_ERR;
+	}
+      (*tv_register_all_symbols_read) (onall_symbols_read);
+    }
+  if (register_cleanup_hook)
+    {
+      if (!tv_register_cleanup)
+	{
+	  TV_MESSAGE (LDPL_FATAL, "No register_cleanup hook");
+	  fflush (NULL);
+	  return LDPS_ERR;
+	}
+      (*tv_register_cleanup) (oncleanup);
+    }
+
+  /* Claim testsuite/ld-plugin/func.c, standalone or in a library.  Its
+     size must be SIZE_OF_FUNC_C bytes.  */
+#define SIZE_OF_FUNC_C	248
+  if (onload_ret == LDPS_OK
+      && (record_claim_file ("func.c", SIZE_OF_FUNC_C) != LDPS_OK
+	  || record_claimed_file_symbol ("func::0:0:0") != LDPS_OK
+	  || record_claimed_file_symbol ("_func::0:0:0") != LDPS_OK
+	  || record_claim_file ("libfunc.a", SIZE_OF_FUNC_C) != LDPS_OK
+	  || record_claimed_file_symbol ("func::0:0:0") != LDPS_OK
+	  || record_claimed_file_symbol ("_func::0:0:0") != LDPS_OK))
+    onload_ret = LDPS_ERR;
+
+  return onload_ret;
+}
+
+char *
+xstrdup (const char *s)
+{
+  size_t len = strlen (s) + 1;
+  char *ret = malloc (len + 1);
+  return (char *) memcpy (ret, s, len);
+}
+
+/* Standard plugin API registerable hook.  */
+static enum ld_plugin_status
+onclaim_file (const struct ld_plugin_input_file *file, int *claimed)
+{
+  /* Let's see if we want to claim this file.  */
+  claim_file_t *claimfile = claimfiles_list;
+  size_t len = strlen (file->name);
+  char *name = xstrdup (file->name);
+  char *p = name + len;
+  bfd_boolean islib;
+
+  /* Only match the file name without the directory part.  */
+  islib = *p == 'a' && *(p - 1) == '.';
+  for (; p != name; p--)
+    if (IS_DIR_SEPARATOR (*p))
+      {
+	p++;
+	break;
+      }
+
+  while (claimfile)
+    {
+      /* Claim the file only if the file name and size match and don't
+	 match the whole library.  */
+      if (!strcmp (p, claimfile->file.name)
+	  && claimfile->file.filesize == file->filesize
+	  && (!islib || file->offset != 0))
+	break;
+      claimfile = claimfile->next;
+    }
+
+  free (name);
+
+  /* If we decided to claim it, record that fact, and add any symbols
+     that were defined for it by plugin options.  */
+  *claimed = (claimfile != 0);
+  if (claimfile)
+    {
+      char buffer[30];
+      int fd;
+
+      TV_MESSAGE (LDPL_INFO, "Claimed: %s [@%ld/%ld]", file->name,
+		  (long)file->offset, (long)file->filesize);
+
+      claimfile->claimed = TRUE;
+      claimfile->file = *file;
+      if (claimfile->n_syms_used && !tv_add_symbols)
+	claim_file_ret = LDPS_ERR;
+      else if (claimfile->n_syms_used)
+	claim_file_ret = (*tv_add_symbols) (claimfile->file.handle,
+					    claimfile->n_syms_used,
+					    claimfile->symbols);
+
+      fd = claimfile->file.fd;
+      name = xstrdup (claimfile->file.name);
+      claim_file_ret = tv_release_input_file (claimfile->file.handle);
+      if (claim_file_ret != LDPS_OK)
+	{
+	  free (name);
+	  return claim_file_ret;
+	}
+      if (read (fd, buffer, sizeof (buffer)) >= 0)
+	{
+	  claim_file_ret == LDPS_ERR;
+	  TV_MESSAGE (LDPL_FATAL, "Unreleased file descriptor on: %s", name);
+	}
+      free (name);
+    }
+
+  return claim_file_ret;
+}
+
+/* Standard plugin API registerable hook.  */
+static enum ld_plugin_status
+onall_symbols_read (void)
+{
+  static const char *resolutions[] =
+    {
+      "LDPR_UNKNOWN",
+      "LDPR_UNDEF",
+      "LDPR_PREVAILING_DEF",
+      "LDPR_PREVAILING_DEF_IRONLY",
+      "LDPR_PREEMPTED_REG",
+      "LDPR_PREEMPTED_IR",
+      "LDPR_RESOLVED_IR",
+      "LDPR_RESOLVED_EXEC",
+      "LDPR_RESOLVED_DYN",
+      "LDPR_PREVAILING_DEF_IRONLY_EXP",
+    };
+  claim_file_t *claimfile = dumpresolutions ? claimfiles_list : NULL;
+  add_file_t *addfile = addfiles_list;
+  TV_MESSAGE (LDPL_INFO, "hook called: all symbols read.");
+  for ( ; claimfile; claimfile = claimfile->next)
+    {
+      enum ld_plugin_status rv;
+      int n;
+      if (claimfile->n_syms_used && !tv_get_symbols_v2)
+	return LDPS_ERR;
+      else if (!claimfile->n_syms_used)
+        continue;
+      else if (!claimfile->file.handle)
+        continue;
+      rv = tv_get_symbols_v2 (claimfile->file.handle, claimfile->n_syms_used,
+			      claimfile->symbols);
+      if (rv != LDPS_OK)
+	return rv;
+      for (n = 0; n < claimfile->n_syms_used; n++)
+	TV_MESSAGE (LDPL_INFO, "Sym: '%s%s%s' Resolution: %s",
+		    claimfile->symbols[n].name,
+		    claimfile->symbols[n].version ? "@" : "",
+		    (claimfile->symbols[n].version
+		     ? claimfile->symbols[n].version : ""),
+		    resolutions[claimfile->symbols[n].resolution]);
+    }
+  for ( ; addfile ; addfile = addfile->next)
+    {
+      enum ld_plugin_status rv;
+      if (addfile->type == ADD_LIB && tv_add_input_library)
+	rv = (*tv_add_input_library) (addfile->name);
+      else if (addfile->type == ADD_FILE && tv_add_input_file)
+	rv = (*tv_add_input_file) (addfile->name);
+      else if (addfile->type == ADD_DIR && tv_set_extra_library_path)
+	rv = (*tv_set_extra_library_path) (addfile->name);
+      else
+	rv = LDPS_ERR;
+      if (rv != LDPS_OK)
+	return rv;
+    }
+  fflush (NULL);
+  return all_symbols_read_ret;
+}
+
+/* Standard plugin API registerable hook.  */
+static enum ld_plugin_status
+oncleanup (void)
+{
+  TV_MESSAGE (LDPL_INFO, "hook called: cleanup.");
+  fflush (NULL);
+  return cleanup_ret;
+}
diff --git a/ld/testsuite/ld-plugin/func.c b/ld/testsuite/ld-plugin/func.c
index 8c668db..7b0c043 100644
--- a/ld/testsuite/ld-plugin/func.c
+++ b/ld/testsuite/ld-plugin/func.c
@@ -1,3 +1,6 @@
+/* The first line of this file must match the expectation of
+   onall_symbols_read in testplug2.c and the size of this file
+   must match the expectation of onclaim_file in testplug2.c.  */
 
 extern int retval;
 
diff --git a/ld/testsuite/ld-plugin/plugin-13.d b/ld/testsuite/ld-plugin/plugin-13.d
new file mode 100644
index 0000000..ebfdc11
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-13.d
@@ -0,0 +1,27 @@
+Hello from testplugin.
+.*: LDPT_MESSAGE func@0x.*
+.*: LDPT_API_VERSION value        0x1 \(1\)
+.*: LDPT_GNU_LD_VERSION value       0x.*
+.*: LDPT_LINKER_OUTPUT value        0x1 \(1\)
+.*: LDPT_OUTPUT_NAME 'tmpdir/main.x'
+.*: LDPT_REGISTER_CLAIM_FILE_HOOK func@0x.*
+.*: LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK func@0x.*
+.*: LDPT_REGISTER_CLEANUP_HOOK func@0x.*
+.*: LDPT_ADD_SYMBOLS func@0x.*
+.*: LDPT_GET_INPUT_FILE func@0x.*
+.*: LDPT_GET_VIEW func@0x.*
+.*: LDPT_RELEASE_INPUT_FILE func@0x.*
+.*: LDPT_GET_SYMBOLS func@0x.*
+.*: LDPT_GET_SYMBOLS_V2 func@0x.*
+.*: LDPT_ADD_INPUT_FILE func@0x.*
+.*: LDPT_ADD_INPUT_LIBRARY func@0x.*
+.*: LDPT_SET_EXTRA_LIBRARY_PATH func@0x.*
+.*: LDPT_OPTION 'registerclaimfile'
+.*: LDPT_OPTION 'claim:.*/ld/testsuite/ld-plugin/func.c'
+.*: LDPT_NULL value        0x0 \(0\)
+hook called: claim_file tmpdir/main.o \[@0/.* not claimed
+hook called: claim_file .*/ld/testsuite/ld-plugin/func.c \[@0/.* CLAIMED
+hook called: claim_file tmpdir/text.o \[@0/.* not claimed
+#...
+.*main.c.*: undefined reference to `func'
+#...
diff --git a/ld/testsuite/ld-plugin/plugin-14.d b/ld/testsuite/ld-plugin/plugin-14.d
new file mode 100644
index 0000000..96e1703
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-14.d
@@ -0,0 +1,33 @@
+Hello from testplugin.
+.*: LDPT_MESSAGE func@0x.*
+.*: LDPT_API_VERSION value        0x1 \(1\)
+.*: LDPT_GNU_LD_VERSION value       0x.*
+.*: LDPT_LINKER_OUTPUT value        0x1 \(1\)
+.*: LDPT_OUTPUT_NAME 'tmpdir/main.x'
+.*: LDPT_REGISTER_CLAIM_FILE_HOOK func@0x.*
+.*: LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK func@0x.*
+.*: LDPT_REGISTER_CLEANUP_HOOK func@0x.*
+.*: LDPT_ADD_SYMBOLS func@0x.*
+.*: LDPT_GET_INPUT_FILE func@0x.*
+.*: LDPT_GET_VIEW func@0x.*
+.*: LDPT_RELEASE_INPUT_FILE func@0x.*
+.*: LDPT_GET_SYMBOLS func@0x.*
+.*: LDPT_GET_SYMBOLS_V2 func@0x.*
+.*: LDPT_ADD_INPUT_FILE func@0x.*
+.*: LDPT_ADD_INPUT_LIBRARY func@0x.*
+.*: LDPT_SET_EXTRA_LIBRARY_PATH func@0x.*
+.*: LDPT_OPTION 'registerclaimfile'
+.*: LDPT_OPTION 'registerallsymbolsread'
+.*: LDPT_OPTION 'registercleanup'
+.*: LDPT_OPTION 'claim:.*/ld/testsuite/ld-plugin/func.c'
+.*: LDPT_NULL value        0x0 \(0\)
+#...
+hook called: claim_file tmpdir/main.o \[@0/.* not claimed
+hook called: claim_file .*/ld/testsuite/ld-plugin/func.c \[@0/.* CLAIMED
+hook called: claim_file tmpdir/text.o \[@0/.* not claimed
+#...
+hook called: all symbols read.
+tmpdir/main.o: In function `main':
+.*main.c.*: undefined reference to `func'
+hook called: cleanup.
+#...
diff --git a/ld/testsuite/ld-plugin/plugin-15.d b/ld/testsuite/ld-plugin/plugin-15.d
new file mode 100644
index 0000000..ec7e52c
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-15.d
@@ -0,0 +1,34 @@
+Hello from testplugin.
+.*: LDPT_MESSAGE func@0x.*
+.*: LDPT_API_VERSION value        0x1 \(1\)
+.*: LDPT_GNU_LD_VERSION value       0x.*
+.*: LDPT_LINKER_OUTPUT value        0x1 \(1\)
+.*: LDPT_OUTPUT_NAME 'tmpdir/main.x'
+.*: LDPT_REGISTER_CLAIM_FILE_HOOK func@0x.*
+.*: LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK func@0x.*
+.*: LDPT_REGISTER_CLEANUP_HOOK func@0x.*
+.*: LDPT_ADD_SYMBOLS func@0x.*
+.*: LDPT_GET_INPUT_FILE func@0x.*
+.*: LDPT_GET_VIEW func@0x.*
+.*: LDPT_RELEASE_INPUT_FILE func@0x.*
+.*: LDPT_GET_SYMBOLS func@0x.*
+.*: LDPT_GET_SYMBOLS_V2 func@0x.*
+.*: LDPT_ADD_INPUT_FILE func@0x.*
+.*: LDPT_ADD_INPUT_LIBRARY func@0x.*
+.*: LDPT_SET_EXTRA_LIBRARY_PATH func@0x.*
+.*: LDPT_OPTION 'registerclaimfile'
+.*: LDPT_OPTION 'registerallsymbolsread'
+.*: LDPT_OPTION 'registercleanup'
+.*: LDPT_OPTION 'claim:.*/ld/testsuite/ld-plugin/func.c'
+.*: LDPT_OPTION 'sym:_?func::0:0:0'
+.*: LDPT_NULL value        0x0 \(0\)
+#...
+hook called: claim_file tmpdir/main.o \[@0/.* not claimed
+hook called: claim_file .*/ld/testsuite/ld-plugin/func.c \[@0/.* CLAIMED
+hook called: claim_file tmpdir/text.o \[@0/.* not claimed
+#...
+hook called: all symbols read.
+tmpdir/main.o: In function `main':
+.*main.c.*: undefined reference to `func'
+hook called: cleanup.
+#...
diff --git a/ld/testsuite/ld-plugin/plugin-16.d b/ld/testsuite/ld-plugin/plugin-16.d
new file mode 100644
index 0000000..479785e
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-16.d
@@ -0,0 +1,38 @@
+Hello from testplugin.
+.*: LDPT_MESSAGE func@0x.*
+.*: LDPT_API_VERSION value        0x1 \(1\)
+.*: LDPT_GNU_LD_VERSION value       0x.*
+.*: LDPT_LINKER_OUTPUT value        0x1 \(1\)
+.*: LDPT_OUTPUT_NAME 'tmpdir/main.x'
+.*: LDPT_REGISTER_CLAIM_FILE_HOOK func@0x.*
+.*: LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK func@0x.*
+.*: LDPT_REGISTER_CLEANUP_HOOK func@0x.*
+.*: LDPT_ADD_SYMBOLS func@0x.*
+.*: LDPT_GET_INPUT_FILE func@0x.*
+.*: LDPT_GET_VIEW func@0x.*
+.*: LDPT_RELEASE_INPUT_FILE func@0x.*
+.*: LDPT_GET_SYMBOLS func@0x.*
+.*: LDPT_GET_SYMBOLS_V2 func@0x.*
+.*: LDPT_ADD_INPUT_FILE func@0x.*
+.*: LDPT_ADD_INPUT_LIBRARY func@0x.*
+.*: LDPT_SET_EXTRA_LIBRARY_PATH func@0x.*
+.*: LDPT_OPTION 'registerclaimfile'
+.*: LDPT_OPTION 'registerallsymbolsread'
+.*: LDPT_OPTION 'registercleanup'
+.*: LDPT_OPTION 'claim:.*/ld/testsuite/ld-plugin/func.c'
+.*: LDPT_OPTION 'sym:_?func::0:0:0'
+.*: LDPT_OPTION 'sym:_?func2::0:0:0'
+.*: LDPT_OPTION 'dumpresolutions'
+.*: LDPT_NULL value        0x0 \(0\)
+#...
+hook called: claim_file tmpdir/main.o \[@0/.* not claimed
+hook called: claim_file .*/ld/testsuite/ld-plugin/func.c \[@0/.* CLAIMED
+hook called: claim_file tmpdir/text.o \[@0/.* not claimed
+#...
+hook called: all symbols read.
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF
+Sym: '_?func2' Resolution: LDPR_PREVAILING_DEF_IRONLY
+tmpdir/main.o: In function `main':
+.*main.c.*: undefined reference to `func'
+hook called: cleanup.
+#...
diff --git a/ld/testsuite/ld-plugin/plugin-17.d b/ld/testsuite/ld-plugin/plugin-17.d
new file mode 100644
index 0000000..159d4e4
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-17.d
@@ -0,0 +1,37 @@
+Hello from testplugin.
+.*: LDPT_MESSAGE func@0x.*
+.*: LDPT_API_VERSION value        0x1 \(1\)
+.*: LDPT_GNU_LD_VERSION value       0x.*
+.*: LDPT_LINKER_OUTPUT value        0x1 \(1\)
+.*: LDPT_OUTPUT_NAME 'tmpdir/main.x'
+.*: LDPT_REGISTER_CLAIM_FILE_HOOK func@0x.*
+.*: LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK func@0x.*
+.*: LDPT_REGISTER_CLEANUP_HOOK func@0x.*
+.*: LDPT_ADD_SYMBOLS func@0x.*
+.*: LDPT_GET_INPUT_FILE func@0x.*
+.*: LDPT_GET_VIEW func@0x.*
+.*: LDPT_RELEASE_INPUT_FILE func@0x.*
+.*: LDPT_GET_SYMBOLS func@0x.*
+.*: LDPT_GET_SYMBOLS_V2 func@0x.*
+.*: LDPT_ADD_INPUT_FILE func@0x.*
+.*: LDPT_ADD_INPUT_LIBRARY func@0x.*
+.*: LDPT_SET_EXTRA_LIBRARY_PATH func@0x.*
+.*: LDPT_OPTION 'registerclaimfile'
+.*: LDPT_OPTION 'registerallsymbolsread'
+.*: LDPT_OPTION 'registercleanup'
+.*: LDPT_OPTION 'claim:.*/ld/testsuite/ld-plugin/func.c'
+.*: LDPT_OPTION 'sym:_?func::0:0:0'
+.*: LDPT_OPTION 'sym:_?func2::0:0:0'
+.*: LDPT_OPTION 'dumpresolutions'
+.*: LDPT_OPTION 'add:tmpdir/func.o'
+.*: LDPT_NULL value        0x0 \(0\)
+#...
+hook called: claim_file tmpdir/main.o \[@0/.* not claimed
+hook called: claim_file .*/ld/testsuite/ld-plugin/func.c \[@0/.* CLAIMED
+hook called: claim_file tmpdir/text.o \[@0/.* not claimed
+#...
+hook called: all symbols read.
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF
+Sym: '_?func2' Resolution: LDPR_PREVAILING_DEF_IRONLY
+hook called: cleanup.
+#...
diff --git a/ld/testsuite/ld-plugin/plugin-18.d b/ld/testsuite/ld-plugin/plugin-18.d
new file mode 100644
index 0000000..0200a05
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-18.d
@@ -0,0 +1,38 @@
+Hello from testplugin.
+.*: LDPT_MESSAGE func@0x.*
+.*: LDPT_API_VERSION value        0x1 \(1\)
+.*: LDPT_GNU_LD_VERSION value       0x.*
+.*: LDPT_LINKER_OUTPUT value        0x1 \(1\)
+.*: LDPT_OUTPUT_NAME 'tmpdir/main.x'
+.*: LDPT_REGISTER_CLAIM_FILE_HOOK func@0x.*
+.*: LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK func@0x.*
+.*: LDPT_REGISTER_CLEANUP_HOOK func@0x.*
+.*: LDPT_ADD_SYMBOLS func@0x.*
+.*: LDPT_GET_INPUT_FILE func@0x.*
+.*: LDPT_GET_VIEW func@0x.*
+.*: LDPT_RELEASE_INPUT_FILE func@0x.*
+.*: LDPT_GET_SYMBOLS func@0x.*
+.*: LDPT_GET_SYMBOLS_V2 func@0x.*
+.*: LDPT_ADD_INPUT_FILE func@0x.*
+.*: LDPT_ADD_INPUT_LIBRARY func@0x.*
+.*: LDPT_SET_EXTRA_LIBRARY_PATH func@0x.*
+.*: LDPT_OPTION 'registerclaimfile'
+.*: LDPT_OPTION 'registerallsymbolsread'
+.*: LDPT_OPTION 'registercleanup'
+.*: LDPT_OPTION 'claim:.*/ld/testsuite/ld-plugin/func.c'
+.*: LDPT_OPTION 'sym:_?func::0:0:0'
+.*: LDPT_OPTION 'sym:_?func2::0:0:0'
+.*: LDPT_OPTION 'dumpresolutions'
+.*: LDPT_OPTION 'add:tmpdir/func.o'
+.*: LDPT_NULL value        0x0 \(0\)
+#...
+hook called: claim_file tmpdir/main.o \[@0/.* not claimed
+hook called: claim_file .*/ld/testsuite/ld-plugin/func.c \[@0/.* CLAIMED
+#...
+hook called: claim_file tmpdir/libtext.a \[@.* not claimed
+#...
+hook called: all symbols read.
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF
+Sym: '_?func2' Resolution: LDPR_PREVAILING_DEF_IRONLY
+hook called: cleanup.
+#...
diff --git a/ld/testsuite/ld-plugin/plugin-19.d b/ld/testsuite/ld-plugin/plugin-19.d
new file mode 100644
index 0000000..e838028
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-19.d
@@ -0,0 +1,42 @@
+Hello from testplugin.
+.*: LDPT_MESSAGE func@0x.*
+.*: LDPT_API_VERSION value        0x1 \(1\)
+.*: LDPT_GNU_LD_VERSION value       0x.*
+.*: LDPT_LINKER_OUTPUT value        0x1 \(1\)
+.*: LDPT_OUTPUT_NAME 'tmpdir/main.x'
+.*: LDPT_REGISTER_CLAIM_FILE_HOOK func@0x.*
+.*: LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK func@0x.*
+.*: LDPT_REGISTER_CLEANUP_HOOK func@0x.*
+.*: LDPT_ADD_SYMBOLS func@0x.*
+.*: LDPT_GET_INPUT_FILE func@0x.*
+.*: LDPT_GET_VIEW func@0x.*
+.*: LDPT_RELEASE_INPUT_FILE func@0x.*
+.*: LDPT_GET_SYMBOLS func@0x.*
+.*: LDPT_GET_SYMBOLS_V2 func@0x.*
+.*: LDPT_ADD_INPUT_FILE func@0x.*
+.*: LDPT_ADD_INPUT_LIBRARY func@0x.*
+.*: LDPT_SET_EXTRA_LIBRARY_PATH func@0x.*
+.*: LDPT_OPTION 'registerclaimfile'
+.*: LDPT_OPTION 'registerallsymbolsread'
+.*: LDPT_OPTION 'registercleanup'
+.*: LDPT_OPTION 'claim:.*/ld/testsuite/ld-plugin/func.c'
+.*: LDPT_OPTION 'sym:_?func::0:0:0'
+.*: LDPT_OPTION 'sym:_?func2::0:0:0'
+.*: LDPT_OPTION 'dumpresolutions'
+.*: LDPT_OPTION 'add:tmpdir/func.o'
+.*: LDPT_OPTION 'claim:tmpdir/libtext.a'
+.*: LDPT_OPTION 'sym:_?text::0:0:0'
+.*: LDPT_OPTION 'add:tmpdir/text.o'
+.*: LDPT_NULL value        0x0 \(0\)
+#...
+hook called: claim_file tmpdir/main.o \[@0/.* not claimed
+hook called: claim_file .*/ld/testsuite/ld-plugin/func.c \[@0/.* CLAIMED
+#...
+hook called: claim_file tmpdir/libtext.a \[@.* CLAIMED
+#...
+hook called: all symbols read.
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF
+Sym: '_?func2' Resolution: LDPR_PREVAILING_DEF_IRONLY
+Sym: '_?text' Resolution: LDPR_PREVAILING_DEF
+hook called: cleanup.
+#...
diff --git a/ld/testsuite/ld-plugin/plugin-20.d b/ld/testsuite/ld-plugin/plugin-20.d
new file mode 100644
index 0000000..dbee504
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-20.d
@@ -0,0 +1,7 @@
+hook called: all symbols read.
+Input: func.c \(tmpdir/libfunc.a\)
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+tmpdir/main.o: In function `main':
+.*main.c.*: undefined reference to `func'
+hook called: cleanup.
diff --git a/ld/testsuite/ld-plugin/plugin-21.d b/ld/testsuite/ld-plugin/plugin-21.d
new file mode 100644
index 0000000..ebfa6c5
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-21.d
@@ -0,0 +1,7 @@
+hook called: all symbols read.
+Input: .*/ld/testsuite/ld-plugin/func.c \(.*/ld/testsuite/ld-plugin/func.c\)
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+tmpdir/main.o: In function `main':
+.*main.c.*: undefined reference to `func'
+hook called: cleanup.
diff --git a/ld/testsuite/ld-plugin/plugin-22.d b/ld/testsuite/ld-plugin/plugin-22.d
new file mode 100644
index 0000000..07a47ac
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-22.d
@@ -0,0 +1,7 @@
+Claimed: tmpdir/libfunc.a \[@.*
+hook called: all symbols read.
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+tmpdir/main.o: In function `main':
+.*main.c.*: undefined reference to `func'
+hook called: cleanup.
diff --git a/ld/testsuite/ld-plugin/plugin-23.d b/ld/testsuite/ld-plugin/plugin-23.d
new file mode 100644
index 0000000..45e4052
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-23.d
@@ -0,0 +1,7 @@
+Claimed: .*/ld/testsuite/ld-plugin/func.c \[@0.*
+hook called: all symbols read.
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+tmpdir/main.o: In function `main':
+.*main.c.*: undefined reference to `func'
+hook called: cleanup.
diff --git a/ld/testsuite/ld-plugin/plugin-24.d b/ld/testsuite/ld-plugin/plugin-24.d
new file mode 100644
index 0000000..1f21a4d
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-24.d
@@ -0,0 +1,5 @@
+hook called: all symbols read.
+Input: .*/ld/testsuite/ld-plugin/func.c \(.*/ld/testsuite/ld-plugin/func.c\)
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+hook called: cleanup.
diff --git a/ld/testsuite/ld-plugin/plugin-25.d b/ld/testsuite/ld-plugin/plugin-25.d
new file mode 100644
index 0000000..6e7638f
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-25.d
@@ -0,0 +1,5 @@
+Claimed: .*/ld/testsuite/ld-plugin/func.c \[@0.*
+hook called: all symbols read.
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+Sym: '_?func' Resolution: LDPR_PREVAILING_DEF.*
+hook called: cleanup.
diff --git a/ld/testsuite/ld-plugin/plugin-26.d b/ld/testsuite/ld-plugin/plugin-26.d
new file mode 100644
index 0000000..c631e38
--- /dev/null
+++ b/ld/testsuite/ld-plugin/plugin-26.d
@@ -0,0 +1,24 @@
+Hello from testplugin.
+.*: LDPT_MESSAGE func@0x.*
+.*: LDPT_API_VERSION value        0x1 \(1\)
+.*: LDPT_GNU_LD_VERSION value       0x.*
+.*: LDPT_LINKER_OUTPUT value        0x1 \(1\)
+.*: LDPT_OUTPUT_NAME 'tmpdir/main.x'
+.*: LDPT_REGISTER_CLAIM_FILE_HOOK func@0x.*
+.*: LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK func@0x.*
+.*: LDPT_REGISTER_CLEANUP_HOOK func@0x.*
+.*: LDPT_ADD_SYMBOLS func@0x.*
+.*: LDPT_GET_INPUT_FILE func@0x.*
+.*: LDPT_GET_VIEW func@0x.*
+.*: LDPT_RELEASE_INPUT_FILE func@0x.*
+.*: LDPT_GET_SYMBOLS func@0x.*
+.*: LDPT_GET_SYMBOLS_V2 func@0x.*
+.*: LDPT_ADD_INPUT_FILE func@0x.*
+.*: LDPT_ADD_INPUT_LIBRARY func@0x.*
+.*: LDPT_SET_EXTRA_LIBRARY_PATH func@0x.*
+.*: LDPT_OPTION 'registerclaimfile'
+.*: LDPT_NULL value        0x0 \(0\)
+hook called: claim_file tmpdir/main.o \[@0/.* not claimed
+hook called: claim_file .*/ld/testsuite/ld-plugin/func.c \[@0/.* not claimed
+.*/ld/testsuite/ld-plugin/func.c: file format not recognized; treating as linker script
+.*/ld/testsuite/ld-plugin/func.c:5: syntax error
diff --git a/ld/testsuite/ld-plugin/plugin.exp b/ld/testsuite/ld-plugin/plugin.exp
index 23a8cfb..b832534 100644
--- a/ld/testsuite/ld-plugin/plugin.exp
+++ b/ld/testsuite/ld-plugin/plugin.exp
@@ -41,6 +41,14 @@ set plugin_name [file_contents "$base_dir/libldtestplug.la"]
 set plugin_name [regsub "'.*" [regsub ".*dlname='" "$plugin_name" ""] ""]
 verbose "plugin name is '$plugin_name'"
 
+set plugin2_name [file_contents "$base_dir/libldtestplug2.la"]
+set plugin2_name [regsub "'.*" [regsub ".*dlname='" "$plugin2_name" ""] ""]
+verbose "plugin2 name is '$plugin2_name'"
+
+set plugin3_name [file_contents "$base_dir/libldtestplug3.la"]
+set plugin3_name [regsub "'.*" [regsub ".*dlname='" "$plugin3_name" ""] ""]
+verbose "plugin3 name is '$plugin3_name'"
+
 # Use libtool to find full path to plugin rather than worrying
 # about run paths or anything like that.
 catch "exec $base_dir/libtool --config" lt_config
@@ -50,7 +58,11 @@ regexp -line "^objdir=.*$" "$lt_config" lt_objdir
 verbose "lt_objdir line is '$lt_objdir'" 3
 set lt_objdir [regsub "objdir=" "$lt_objdir" ""]
 set plugin_path "$base_dir/$lt_objdir/$plugin_name"
+set plugin2_path "$base_dir/$lt_objdir/$plugin2_name"
+set plugin3_path "$base_dir/$lt_objdir/$plugin3_name"
 verbose "Full plugin path $plugin_path" 2
+verbose "Full plugin2 path $plugin2_path" 2
+verbose "Full plugin3 path $plugin3_path" 2
 
 set regclm "-plugin-opt registerclaimfile"
 set regas "-plugin-opt registerallsymbolsread"
@@ -88,6 +100,8 @@ if { $can_compile && !$failed_compile } {
 
 set testobjfiles "tmpdir/main.o tmpdir/func.o tmpdir/text.o"
 set testobjfiles_notext "tmpdir/main.o tmpdir/func.o"
+set testsrcfiles "tmpdir/main.o $srcdir/$subdir/func.c tmpdir/text.o"
+set testsrcfiles_notext "tmpdir/main.o $srcdir/$subdir/func.c"
 # Rather than having libs we just define dummy values for anything
 # we may need to link a target exe; we aren't going to run it anyway.
 set libs "[ld_simple_link_defsyms] --defsym ${_}printf=${_}main --defsym ${_}puts=${_}main"
@@ -125,6 +139,35 @@ set plugin_tests [list \
 			-plugin-opt dumpresolutions \
 			-plugin-opt add:tmpdir/func.o \
     $testobjfiles $libs" "" "" "" {{ld plugin-9.d}} "main.x" ] \
+    [list "load plugin with source" "-plugin $plugin_path $regclm \
+			-plugin-opt claim:$srcdir/$subdir/func.c \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-13.d}} "main.x" ] \
+    [list "plugin claimfile lost symbol with source" \
+		       "-plugin $plugin_path $regclm $regas $regcln \
+			-plugin-opt claim:$srcdir/$subdir/func.c \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-14.d}} "main.x" ] \
+    [list "plugin claimfile replace symbol with source" \
+		       "-plugin $plugin_path $regclm $regas $regcln \
+			-plugin-opt claim:$srcdir/$subdir/func.c \
+			-plugin-opt sym:${_}func::0:0:0 \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-15.d}} "main.x" ] \
+    [list "plugin claimfile resolve symbol with source" \
+		       "-plugin $plugin_path $regclm $regas $regcln \
+			-plugin-opt claim:$srcdir/$subdir/func.c \
+			-plugin-opt sym:${_}func::0:0:0 \
+			-plugin-opt sym:${_}func2::0:0:0 \
+			-plugin-opt dumpresolutions \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-16.d}} "main.x" ] \
+    [list "plugin claimfile replace file with source" \
+		       "-plugin $plugin_path $regclm $regas $regcln \
+			-plugin-opt claim:$srcdir/$subdir/func.c \
+			-plugin-opt sym:${_}func::0:0:0 \
+			-plugin-opt sym:${_}func2::0:0:0 \
+			-plugin-opt dumpresolutions \
+			-plugin-opt add:tmpdir/func.o \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-17.d}} "main.x" ] \
+    [list "load plugin with source not claimed" "-plugin $plugin_path $regclm \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-26.d}} "main.x" ] \
 ]
 
 set plugin_lib_tests [list \
@@ -145,6 +188,25 @@ set plugin_lib_tests [list \
 			-plugin-opt sym:${_}text::0:0:0 \
 			-plugin-opt add:tmpdir/text.o \
     $testobjfiles_notext -Ltmpdir -ltext $libs" "" "" "" {{ld plugin-11.d}} "main.x" ] \
+    [list "plugin ignore lib with source" \
+	               "-plugin $plugin_path $regclm $regas $regcln \
+			-plugin-opt claim:$srcdir/$subdir/func.c \
+			-plugin-opt sym:${_}func::0:0:0 \
+			-plugin-opt sym:${_}func2::0:0:0 \
+			-plugin-opt dumpresolutions \
+			-plugin-opt add:tmpdir/func.o \
+    $testsrcfiles_notext -Ltmpdir -ltext $libs" "" "" "" {{ld plugin-18.d}} "main.x" ] \
+    [list "plugin claimfile replace lib with source" \
+		       "-plugin $plugin_path $regclm $regas $regcln \
+			-plugin-opt claim:$srcdir/$subdir/func.c \
+			-plugin-opt sym:${_}func::0:0:0 \
+			-plugin-opt sym:${_}func2::0:0:0 \
+			-plugin-opt dumpresolutions \
+			-plugin-opt add:tmpdir/func.o \
+			-plugin-opt claim:tmpdir/libtext.a \
+			-plugin-opt sym:${_}text::0:0:0 \
+			-plugin-opt add:tmpdir/text.o \
+    $testsrcfiles_notext -Ltmpdir -ltext $libs" "" "" "" {{ld plugin-19.d}} "main.x" ] \
 ]
 
 set plugin_extra_elf_tests [list \
@@ -161,6 +223,20 @@ set plugin_extra_elf_tests [list \
 			-plugin-opt add:tmpdir/func3h.o \
     $testobjfiles $libs --verbose=2" "" "" "" {{ld plugin-12.d} \
 				{readelf -s plugin-vis-1.d}} "main.x" ] \
+    [list "plugin set symbol visibility with source" \
+		       "-plugin $plugin_path $regclm $regas $regcln \
+			-plugin-opt claim:$srcdir/$subdir/func.c \
+			-plugin-opt sym:${_}func::0:0:0 \
+			-plugin-opt sym:${_}func1::0:1:0 \
+			-plugin-opt sym:${_}func2::0:2:0 \
+			-plugin-opt sym:${_}func3::0:3:0 \
+			-plugin-opt dumpresolutions \
+			-plugin-opt add:tmpdir/func.o \
+			-plugin-opt add:tmpdir/func1p.o \
+			-plugin-opt add:tmpdir/func2i.o \
+			-plugin-opt add:tmpdir/func3h.o \
+    $testsrcfiles $libs --verbose=2" "" "" "" {{ld plugin-12.d} \
+				{readelf -s plugin-vis-1.d}} "main.x" ] \
 ]
 
 if { !$can_compile || $failed_compile } {
@@ -191,3 +267,65 @@ if ![ar_simple_create $ar "" "tmpdir/libtext.a" "tmpdir/text.o"] {
 } else {
     run_ld_link_tests $plugin_lib_tests
 }
+
+set plugin_src_tests [list \
+    [list "plugin 2 with source lib" \
+	               "-plugin $plugin2_path $regclm $regas $regcln \
+			-plugin-opt dumpresolutions \
+     tmpdir/main.o -Ltmpdir -ltext -lfunc $libs" "" "" "" {{ld plugin-20.d}} "main.x" ] \
+    [list "load plugin 2 with source" \
+	               "-plugin $plugin2_path $regclm $regas $regcln \
+			-plugin-opt dumpresolutions \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-21.d}} "main.x" ] \
+    [list "load plugin 2 with source and -r" \
+	               "-r -plugin $plugin2_path $regclm $regas $regcln \
+			-plugin-opt dumpresolutions \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-24.d}} "main.x" ] \
+    [list "plugin 3 with source lib" \
+	               "-plugin $plugin3_path $regclm $regas $regcln \
+			-plugin-opt dumpresolutions \
+     tmpdir/main.o -Ltmpdir -ltext -lfunc $libs" "" "" "" {{ld plugin-22.d}} "main.x" ] \
+    [list "load plugin 3 with source" \
+	               "-plugin $plugin3_path $regclm $regas $regcln \
+			-plugin-opt dumpresolutions \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-23.d}} "main.x" ] \
+    [list "load plugin 3 with source and -r" \
+	               "-r -plugin $plugin3_path $regclm $regas $regcln \
+			-plugin-opt dumpresolutions \
+    $testsrcfiles $libs" "" "" "" {{ld plugin-25.d}} "main.x" ] \
+]
+
+# Check if nm --plugin works.
+set testname "nm --plugin"
+set nm_plugin "$NM --plugin $plugin2_path $srcdir/$subdir/func.c"
+catch "exec $nm_plugin" plugin_nm_output
+send_log "$nm_plugin\n"
+send_log "$plugin_nm_output\n"
+if { [regexp "0+ T func" "$plugin_nm_output"] &&
+     [regexp "0+ T _func" "$plugin_nm_output"] } {
+    pass $testname
+} else {
+    fail $testname
+}
+
+# Check if ar --plugin works.
+file delete tmpdir/libfunc.a
+if [ar_simple_create $ar "--plugin $plugin2_path" "tmpdir/libfunc.a" \
+			 "tmpdir/main.o $srcdir/$subdir/func.c"] {
+    set testname "ar --plugin"
+    set nm_plugin "$NM -s --plugin $plugin2_path tmpdir/libfunc.a"
+    catch "exec $nm_plugin" plugin_nm_output
+    send_log "$nm_plugin\n"
+    send_log "$plugin_nm_output\n"
+    if { [regexp "func in func.c" "$plugin_nm_output"] &&
+         [regexp "_func in func.c" "$plugin_nm_output"] } {
+	pass $testname
+	run_ld_link_tests $plugin_src_tests
+    } else {
+	fail $testname
+    }
+} else {
+    foreach testitem $plugin_src_tests {
+	unresolved [lindex $testitem 0]
+    }
+}
-- 
2.1.0

