From d5635c4f38f4d6c90aae549e64d518b25893ccc8 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Tue, 18 Sep 2018 05:54:56 -0700
Subject: [PATCH 1/3] ELF: Group PT_NOTE segments by section alignments

Alignments of SHT_NOTE sections can be 8 bytes for 64-bit ELF files.  We
should put all adjacent SHT_NOTE sections with the same section alignment
into a single PT_NOTE segment even when the section alignment != 4 bytes.

	PR ld/23658
	* elf.c (get_program_header_size): Put all adjacent SHT_NOTE
	sections with the same section alignment into a single PT_NOTE
	segment.
	(_bfd_elf_map_sections_to_segments): Likewise.
---
 bfd/elf.c | 50 +++++++++++++++++++++++++-------------------------
 1 file changed, 25 insertions(+), 25 deletions(-)

diff --git a/bfd/elf.c b/bfd/elf.c
index 5320ae2237..52ffb0ccab 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -4373,21 +4373,20 @@ get_program_header_size (bfd *abfd, struct bfd_link_info *info)
       if ((s->flags & SEC_LOAD) != 0
 	  && CONST_STRNEQ (s->name, ".note"))
 	{
+	  unsigned int alignment_power;
 	  /* We need a PT_NOTE segment.  */
 	  ++segs;
-	  /* Try to create just one PT_NOTE segment
-	     for all adjacent loadable .note* sections.
-	     gABI requires that within a PT_NOTE segment
-	     (and also inside of each SHT_NOTE section)
-	     each note is padded to a multiple of 4 size,
-	     so we check whether the sections are correctly
-	     aligned.  */
-	  if (s->alignment_power == 2)
-	    while (s->next != NULL
-		   && s->next->alignment_power == 2
-		   && (s->next->flags & SEC_LOAD) != 0
-		   && CONST_STRNEQ (s->next->name, ".note"))
-	      s = s->next;
+	  /* Try to create just one PT_NOTE segment for all adjacent
+	     loadable .note* sections.  gABI requires that within a
+	     PT_NOTE segment (and also inside of each SHT_NOTE section)
+	     each note should have the same alignment.  So we check
+	     whether the sections are correctly aligned.  */
+	  alignment_power = s->alignment_power;
+	  while (s->next != NULL
+		 && s->next->alignment_power == alignment_power
+		 && (s->next->flags & SEC_LOAD) != 0
+		 && CONST_STRNEQ (s->next->name, ".note"))
+	    s = s->next;
 	}
     }
 
@@ -4897,21 +4896,22 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)
 	      && CONST_STRNEQ (s->name, ".note"))
 	    {
 	      asection *s2;
+	      unsigned int alignment_power = s->alignment_power;
 
 	      count = 1;
 	      amt = sizeof (struct elf_segment_map);
-	      if (s->alignment_power == 2)
-		for (s2 = s; s2->next != NULL; s2 = s2->next)
-		  {
-		    if (s2->next->alignment_power == 2
-			&& (s2->next->flags & SEC_LOAD) != 0
-			&& CONST_STRNEQ (s2->next->name, ".note")
-			&& align_power (s2->lma + s2->size, 2)
-			   == s2->next->lma)
-		      count++;
-		    else
-		      break;
-		  }
+	      for (s2 = s; s2->next != NULL; s2 = s2->next)
+		{
+		  if (s2->next->alignment_power == alignment_power
+		      && (s2->next->flags & SEC_LOAD) != 0
+		      && CONST_STRNEQ (s2->next->name, ".note")
+		      && align_power (s2->lma + s2->size,
+				      alignment_power)
+		      == s2->next->lma)
+		    count++;
+		  else
+		    break;
+		}
 	      amt += (count - 1) * sizeof (asection *);
 	      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
 	      if (m == NULL)
-- 
2.17.1

