From b6d1f243eaf973f74b59845ed68b096da125b29d Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Tue, 14 Jun 2016 09:11:03 -0700
Subject: [PATCH] Don't generate PLT for IFUNC GOT/pointer reference

PLT entry isn't needed when all references to a STT_GNU_IFUNC symbols
are done via GOT or static function pointers.  For GOT entries, We
generate dynamic R_*_GLOB_DAT relocations for preemptable symbols and
R_*_IRELATIVE relocations for non-preemptable symbols to update them
with real function address.  For static pointer pointers, we generate
dynamic pointer relocations and store them in:

1. .rel[a].ifunc section in PIC object.
2. .rel[a].got section in dynamic executable.
3. .rel[a].iplt section in static executable.

bfd/

	PR ld/20253
	* elf-ifunc.c (_bfd_elf_create_ifunc_sections): Replace
	"shared object" with "PIC object" in comments.
	(_bfd_elf_allocate_ifunc_dyn_relocs): Replace "shared object"
	with "PIC object" in comments.  Generate dynamic relocations
	for non-GOT references.  Make room for the special first entry
	in PLT and allocate PLT entry only for PLT and PC-relative
	references.  Store dynamic GOT relocations in .rel[a].iplt
	section for static executables.  If PLT isn't used, always use
	GOT for symbol value.
	* elf32-i386.c (elf_i386_check_relocs): Increment PLT reference
	count only in the code section.  Allocate dynamic pointer
	relocation against STT_GNU_IFUNC symbol in the non-code section.
	(elf_i386_adjust_dynamic_symbol): Increment PLT reference count
	only for PC-relative references.
	(elf_i386_relocate_section): Allow R_386_GOT32/R_386_GOT32X
	relocations against STT_GNU_IFUNC symbols without PLT.  Generate
	dynamic pointer relocation against STT_GNU_IFUNC symbol in
	the non-code section and store it in the proper REL section.
	(elf_i386_finish_dynamic_symbol): Generate dynamic
	R_386_IRELATIVE and R_386_GLOB_DAT GOT relocations against
	STT_GNU_IFUNC symbols without PLT.
	(elf_i386_finish_dynamic_sections): Don't handle local
	STT_GNU_IFUNC symbols here.
	(elf_i386_output_arch_local_syms): Handle local STT_GNU_IFUNC
	symbols here.
	(elf_backend_output_arch_local_syms): New.
	* elf32-x86-64.c (elf_i386_check_relocs): Increment PLT reference
	count only in the code section.  Allocate dynamic pointer
	relocation against STT_GNU_IFUNC symbol in the non-code section.
	(elf_x86_64_adjust_dynamic_symbol): Increment PLT reference
	count only for PC-relative references.
	(elf_x86_64_relocate_section): Allow R_X86_64_GOTPCREL,
	R_X86_64_GOTPCRELX, R_X86_64_REX_GOTPCRELX and
	R_X86_64_GOTPCREL64 relocations against STT_GNU_IFUNC symbols
	without PLT.  Generate dynamic pointer relocation against
	STT_GNU_IFUNC symbol in the non-code section and store it in
	the proper RELA section.
	(elf_x86_64_finish_dynamic_symbol): Generate dynamic
	R_X86_64_IRELATIVE and R_X86_64_GLOB_DAT GOT relocations against
	STT_GNU_IFUNC symbols without PLT.
	(elf_x86_64_finish_dynamic_sections): Don't handle local
	STT_GNU_IFUNC symbols here.
	(elf_x86_64_output_arch_local_syms): Handle local STT_GNU_IFUNC
	symbols here.
	(elf_backend_output_arch_local_syms): New.

ld/

	PR ld/20253
	* testsuite/ld-i386/no-plt.exp: Run PR ld/20253 tests.
	* testsuite/ld-x86-64/no-plt.exp: Likewise.
	* testsuite/ld-i386/pr13302.d: Remove .rel.plt section.
	* testsuite/ld-x86-64/pr13082-5a.d: Likewise.
	* testsuite/ld-x86-64/pr13082-5b.d: Likewise.
	* testsuite/ld-x86-64/pr13082-6a.d: Likewise.
	* testsuite/ld-x86-64/pr13082-6b.d: Likewise.
	* testsuite/ld-ifunc/ifunc-13-i386.d: Likewise.
	* testsuite/ld-ifunc/ifunc-13-x86-64.d: Likewise.
	* testsuite/ld-ifunc/ifunc-15-i386.d: Likewise.
	* testsuite/ld-ifunc/ifunc-15-x86-64.d: Likewise.
	* testsuite/ld-i386/pr20244-2a.d: Remove .plt section.
	* testsuite/ld-ifunc/ifunc-21-i386.d: Likewise.
	* testsuite/ld-ifunc/ifunc-21-x86-64.d: Likewise.
	* testsuite/ld-ifunc/ifunc-22-i386.d: Likewise.
	* testsuite/ld-ifunc/ifunc-22-x86-64.d: Likewise.
	* testsuite/ld-i386/pr20244-2b.d: Updated.
	* testsuite/ld-i386/pr20244-2c.d: Likewise.
	* testsuite/ld-ifunc/ifunc-18a-i386.d: Likewise.
	* testsuite/ld-ifunc/ifunc-18a-x86-64.d: Likewise.
	* testsuite/ld-ifunc/ifunc-18b-i386.d: Likewise.
	* testsuite/ld-ifunc/ifunc-18b-x86-64.d: Likewise.
	* testsuite/ld-i386/pr20253-1a.c: New file.
	* testsuite/ld-i386/pr20253-1b.S: Likewise.
	* testsuite/ld-i386/pr20253-1c.S: Likewise.
	* testsuite/ld-i386/pr20253-1d.S: Likewise.
	* testsuite/ld-i386/pr20253-2a.c: Likewise.
	* testsuite/ld-i386/pr20253-2b.S: Likewise.
	* testsuite/ld-i386/pr20253-2c.S: Likewise.
	* testsuite/ld-i386/pr20253-2d.S: Likewise.
	* testsuite/ld-x86-64/pr20253-1.s: Likewise.
	* testsuite/ld-x86-64/pr20253-1a.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1b.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1c.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1d.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1e.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1f.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1g.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1h.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1i.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1j.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1k.d: Likewise.
	* testsuite/ld-x86-64/pr20253-1l.d: Likewise.
	* testsuite/ld-x86-64/pr20253-2a.c: Likewise.
	* testsuite/ld-x86-64/pr20253-2b.S: Likewise.
	* testsuite/ld-x86-64/pr20253-2c.S: Likewise.
	* testsuite/ld-x86-64/pr20253-2d.S: Likewise.
	* testsuite/ld-x86-64/x86-64.exp: Run pr20253-1 tests.
---
 bfd/elf-ifunc.c                          | 145 +++++++++++------
 bfd/elf32-i386.c                         | 257 +++++++++++++++++++++----------
 bfd/elf64-x86-64.c                       | 247 +++++++++++++++++++----------
 ld/testsuite/ld-i386/no-plt.exp          |  82 ++++++++++
 ld/testsuite/ld-i386/pr13302.d           |   5 +-
 ld/testsuite/ld-i386/pr20244-2a.d        |  33 ++--
 ld/testsuite/ld-i386/pr20244-2b.d        |   3 +-
 ld/testsuite/ld-i386/pr20244-2c.d        |   4 +-
 ld/testsuite/ld-i386/pr20253-1a.c        |   8 +
 ld/testsuite/ld-i386/pr20253-1b.S        |  48 ++++++
 ld/testsuite/ld-i386/pr20253-1c.S        |  31 ++++
 ld/testsuite/ld-i386/pr20253-1d.S        |  77 +++++++++
 ld/testsuite/ld-i386/pr20253-2a.c        |   8 +
 ld/testsuite/ld-i386/pr20253-2b.S        |  35 +++++
 ld/testsuite/ld-i386/pr20253-2c.S        |  20 +++
 ld/testsuite/ld-i386/pr20253-2d.S        |  45 ++++++
 ld/testsuite/ld-ifunc/ifunc-13-i386.d    |   8 +-
 ld/testsuite/ld-ifunc/ifunc-13-x86-64.d  |   8 +-
 ld/testsuite/ld-ifunc/ifunc-15-i386.d    |   4 -
 ld/testsuite/ld-ifunc/ifunc-15-x86-64.d  |   4 -
 ld/testsuite/ld-ifunc/ifunc-18a-i386.d   |   5 +-
 ld/testsuite/ld-ifunc/ifunc-18a-x86-64.d |   5 +-
 ld/testsuite/ld-ifunc/ifunc-18b-i386.d   |   5 +-
 ld/testsuite/ld-ifunc/ifunc-18b-x86-64.d |   5 +-
 ld/testsuite/ld-ifunc/ifunc-21-i386.d    |  26 ++--
 ld/testsuite/ld-ifunc/ifunc-21-x86-64.d  |  26 ++--
 ld/testsuite/ld-ifunc/ifunc-22-i386.d    |  26 ++--
 ld/testsuite/ld-ifunc/ifunc-22-x86-64.d  |  26 ++--
 ld/testsuite/ld-x86-64/no-plt.exp        |  67 ++++++++
 ld/testsuite/ld-x86-64/pr13082-5a.d      |   7 +-
 ld/testsuite/ld-x86-64/pr13082-5b.d      |   5 +-
 ld/testsuite/ld-x86-64/pr13082-6a.d      |   5 +-
 ld/testsuite/ld-x86-64/pr13082-6b.d      |   5 +-
 ld/testsuite/ld-x86-64/pr20253-1.s       |  18 +++
 ld/testsuite/ld-x86-64/pr20253-1a.d      |   9 ++
 ld/testsuite/ld-x86-64/pr20253-1b.d      |  25 +++
 ld/testsuite/ld-x86-64/pr20253-1c.d      |   9 ++
 ld/testsuite/ld-x86-64/pr20253-1d.d      |  25 +++
 ld/testsuite/ld-x86-64/pr20253-1e.d      |   9 ++
 ld/testsuite/ld-x86-64/pr20253-1f.d      |  25 +++
 ld/testsuite/ld-x86-64/pr20253-1g.d      |   9 ++
 ld/testsuite/ld-x86-64/pr20253-1h.d      |  25 +++
 ld/testsuite/ld-x86-64/pr20253-1i.d      |   9 ++
 ld/testsuite/ld-x86-64/pr20253-1j.d      |  25 +++
 ld/testsuite/ld-x86-64/pr20253-1k.d      |   9 ++
 ld/testsuite/ld-x86-64/pr20253-1l.d      |  25 +++
 ld/testsuite/ld-x86-64/pr20253-2a.c      |   8 +
 ld/testsuite/ld-x86-64/pr20253-2b.S      |  42 +++++
 ld/testsuite/ld-x86-64/pr20253-2c.S      |  25 +++
 ld/testsuite/ld-x86-64/pr20253-2d.S      |  57 +++++++
 ld/testsuite/ld-x86-64/x86-64.exp        |  12 ++
 51 files changed, 1322 insertions(+), 329 deletions(-)
 create mode 100644 ld/testsuite/ld-i386/pr20253-1a.c
 create mode 100644 ld/testsuite/ld-i386/pr20253-1b.S
 create mode 100644 ld/testsuite/ld-i386/pr20253-1c.S
 create mode 100644 ld/testsuite/ld-i386/pr20253-1d.S
 create mode 100644 ld/testsuite/ld-i386/pr20253-2a.c
 create mode 100644 ld/testsuite/ld-i386/pr20253-2b.S
 create mode 100644 ld/testsuite/ld-i386/pr20253-2c.S
 create mode 100644 ld/testsuite/ld-i386/pr20253-2d.S
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1.s
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1a.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1b.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1c.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1d.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1e.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1f.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1g.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1h.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1i.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1j.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1k.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-1l.d
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-2a.c
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-2b.S
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-2c.S
 create mode 100644 ld/testsuite/ld-x86-64/pr20253-2d.S

diff --git a/bfd/elf-ifunc.c b/bfd/elf-ifunc.c
index 1377fed..d1805bd 100644
--- a/bfd/elf-ifunc.c
+++ b/bfd/elf-ifunc.c
@@ -55,7 +55,7 @@ _bfd_elf_create_ifunc_sections (bfd *abfd, struct bfd_link_info *info)
 
   if (bfd_link_pic (info))
     {
-      /* We need to create .rel[a].ifunc for shared objects.  */
+      /* We need to create .rel[a].ifunc for PIC objects.  */
       const char *rel_sec = (bed->rela_plts_and_copies_p
 			     ? ".rela.ifunc" : ".rel.ifunc");
 
@@ -121,13 +121,16 @@ _bfd_elf_allocate_ifunc_dyn_relocs (struct bfd_link_info *info,
   const struct elf_backend_data *bed;
   struct elf_link_hash_table *htab;
   bfd_boolean readonly_dynrelocs_against_ifunc;
-
-  /* When a shared library references a STT_GNU_IFUNC symbol defined
-     in executable, the address of the resolved function may be used.
-     But in non-shared executable, the address of its .plt slot may
-     be used.  Pointer equality may not work correctly.  PIE should
-     be used if pointer equality is required here.  */
-  if (!bfd_link_pic (info)
+  bfd_boolean use_plt = h->plt.refcount > 0;
+
+  /* When a PIC object references a STT_GNU_IFUNC symbol defined
+     in executable or it isn't referenced via PLT, the address of
+     the resolved function may be used.  But in non-PIC executable,
+     the address of its .plt slot may be used.  Pointer equality may
+     not work correctly.  PIE or non-PLT reference should be used if
+     pointer equality is required here.  */
+  if (use_plt
+      && !bfd_link_pic (info) && use_plt
       && (h->dynindx != -1
 	  || info->export_dynamic)
       && h->pointer_equality_needed)
@@ -144,16 +147,30 @@ _bfd_elf_allocate_ifunc_dyn_relocs (struct bfd_link_info *info,
 
   htab = elf_hash_table (info);
 
-  /* When building shared library, we need to handle the case where it is
-     marked with regular reference, but not non-GOT reference since the
-     non-GOT reference bit may not be set here.  */
-  if (bfd_link_pic (info) && !h->non_got_ref && h->ref_regular)
-    for (p = *head; p != NULL; p = p->next)
-      if (p->count)
-	{
-	  h->non_got_ref = 1;
-	  goto keep;
-	}
+  /* When the symbol is marked with regular reference, if PLT isn't used
+     or we are building a PIC object, we must keep dynamic relocation
+     if there is non-GOT reference and use PLT if there is PC-relative
+     reference.  */
+  if ((!use_plt || bfd_link_pic (info))
+      && h->ref_regular)
+    {
+      bfd_boolean keep = FALSE;
+      for (p = *head; p != NULL; p = p->next)
+	if (p->count)
+	  {
+	    h->non_got_ref = 1;
+	    /* Need dynamic relocations for non-GOT reference.  */
+	    keep = TRUE;
+	    if (p->pc_count)
+	      {
+		/* Must use PLT for PC-relative reference.  */
+		use_plt = TRUE;
+		break;
+	      }
+	  }
+      if (keep)
+	goto keep;
+    }
 
   /* Support garbage collection against STT_GNU_IFUNC symbols.  */
   if (h->plt.refcount <= 0 && h->got.refcount <= 0)
@@ -165,7 +182,7 @@ _bfd_elf_allocate_ifunc_dyn_relocs (struct bfd_link_info *info,
     }
 
   /* Return and discard space for dynamic relocations against it if
-     it is never referenced in a non-shared object.  */
+     it is never referenced.  */
   if (!h->ref_regular)
     {
       if (h->plt.refcount > 0
@@ -192,9 +209,9 @@ keep:
       gotplt = htab->sgotplt;
       relplt = htab->srelplt;
 
-      /* If this is the first .plt entry, make room for the special
-	 first entry.  */
-      if (plt->size == 0)
+      /* If this is the first .plt entry and PLT is used, make room for
+	 the special first entry.  */
+      if (plt->size == 0 && use_plt)
 	plt->size += plt_header_size;
     }
   else
@@ -204,25 +221,33 @@ keep:
       relplt = htab->irelplt;
     }
 
-  /* Don't update value of STT_GNU_IFUNC symbol to PLT.  We need
-     the original value for R_*_IRELATIVE.  */
-  h->plt.offset = plt->size;
+  if (use_plt)
+    {
+      /* Don't update value of STT_GNU_IFUNC symbol to PLT.  We need
+	 the original value for R_*_IRELATIVE.  */
+      h->plt.offset = plt->size;
 
-  /* Make room for this entry in the .plt/.iplt section.  */
-  plt->size += plt_entry_size;
+      /* Make room for this entry in the .plt/.iplt section.  */
+      plt->size += plt_entry_size;
 
-  /* We also need to make an entry in the .got.plt/.got.iplt section,
-     which will be placed in the .got section by the linker script.  */
-  gotplt->size += got_entry_size;
+      /* We also need to make an entry in the .got.plt/.got.iplt section,
+	 which will be placed in the .got section by the linker script.  */
+      gotplt->size += got_entry_size;
+    }
 
   /* We also need to make an entry in the .rel[a].plt/.rel[a].iplt
-     section.  */
-  relplt->size += sizeof_reloc;
-  relplt->reloc_count++;
+     section if PLT is used or for static executable where dynamic
+     relocation in GOT is stored in .rel[a].iplt section.  */
+  if (use_plt || htab->splt == NULL)
+    {
+      relplt->size += sizeof_reloc;
+      relplt->reloc_count++;
+    }
 
   /* We need dynamic relocation for STT_GNU_IFUNC symbol only when
-     there is a non-GOT reference in a shared object.  */
-  if (!bfd_link_pic (info)
+     there is a non-GOT reference in a shared object or PLT isn't
+     used.  */
+  if ((use_plt && !bfd_link_pic (info))
       || !h->non_got_ref)
     *head = NULL;
 
@@ -245,7 +270,20 @@ keep:
 	  p = p->next;
 	}
       while (p != NULL);
-      htab->irelifunc->size += count * sizeof_reloc;
+
+      /* Dynamic relocations are stored in
+	 1. .rel[a].ifunc section in PIC object.
+	 2. .rel[a].got section in dynamic executable.
+	 3. .rel[a].iplt section in static executable.  */
+      if (bfd_link_pic (info))
+	htab->irelifunc->size += count * sizeof_reloc;
+      else if (htab->splt != NULL)
+	htab->srelgot->size += count * sizeof_reloc;
+      else
+	{
+	  htab->irelplt->size += count * sizeof_reloc;
+	  htab->irelplt->reloc_count += count;
+	}
     }
 
   if (readonly_dynrelocs_against_ifunc_p)
@@ -254,24 +292,27 @@ keep:
   /* For STT_GNU_IFUNC symbol, .got.plt has the real function address
      and .got has the PLT entry adddress.  We will load the GOT entry
      with the PLT entry in finish_dynamic_symbol if it is used.  For
-     branch, it uses .got.plt.  For symbol value,
-     1. Use .got.plt in a shared object if it is forced local or not
+     branch, it uses .got.plt.  For symbol value, if PLT is used,
+     1. Use .got.plt in a PIC object if it is forced local or not
      dynamic.
-     2. Use .got.plt in a non-shared object if pointer equality isn't
+     2. Use .got.plt in a non-PIC object if pointer equality isn't
      needed.
      3. Use .got.plt in PIE.
      4. Use .got.plt if .got isn't used.
      5. Otherwise use .got so that it can be shared among different
      objects at run-time.
-     We only need to relocate .got entry in shared object.  */
-  if (h->got.refcount <= 0
-      || (bfd_link_pic (info)
-	  && (h->dynindx == -1
-	      || h->forced_local))
-      || (!bfd_link_pic (info)
-	  && !h->pointer_equality_needed)
-      || bfd_link_pie (info)
-      || htab->sgot == NULL)
+     If PLT isn't used, always use .got for symbol value.
+     We only need to relocate .got entry in PIC object or in dynamic
+     executable without PLT.  */
+  if (use_plt
+      && (h->got.refcount <= 0
+	  || (bfd_link_pic (info)
+	      && (h->dynindx == -1
+		  || h->forced_local))
+	  || (!bfd_link_pic (info)
+	      && !h->pointer_equality_needed)
+	  || bfd_link_pie (info)
+	  || htab->sgot == NULL))
     {
       /* Use .got.plt.  */
       h->got.offset = (bfd_vma) -1;
@@ -280,7 +321,13 @@ keep:
     {
       h->got.offset = htab->sgot->size;
       htab->sgot->size += got_entry_size;
-      if (bfd_link_pic (info))
+      if (!use_plt)
+	{
+	  /* PLT isn't used.  */
+	  h->plt.offset = (bfd_vma) -1;
+	}
+      /* Static executable doesn't use .rel[a].got section.  */
+      if (htab->splt != NULL)
 	htab->srelgot->size += sizeof_reloc;
     }
 
diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
index 2b7de33..867e888 100644
--- a/bfd/elf32-i386.c
+++ b/bfd/elf32-i386.c
@@ -2165,8 +2165,11 @@ do_relocation:
 	      h->non_got_ref = 1;
 
 	      /* We may need a .plt entry if the function this reloc
-		 refers to is in a shared lib.  */
-	      h->plt.refcount += 1;
+		 in the code section refers to is in a shared lib.  */
+	      if ((sec->flags & SEC_CODE) != 0
+		  || h->type != STT_GNU_IFUNC)
+		h->plt.refcount += 1;
+
 	      if (r_type == R_386_PC32)
 		{
 		  /* Since something like ".long foo - ." may be used
@@ -2207,7 +2210,10 @@ do_size:
 	     If on the other hand, we are creating an executable, we
 	     may need to keep relocations for symbols satisfied by a
 	     dynamic library if we manage to avoid copy relocs for the
-	     symbol.  */
+	     symbol.
+
+	     Generate dynamic pointer relocation against STT_GNU_IFUNC
+	     symbol in the non-code section.  */
 	  if ((bfd_link_pic (info)
 	       && (r_type != R_386_PC32
 		   || (h != NULL
@@ -2215,6 +2221,10 @@ do_size:
 			      || SYMBOLIC_BIND (info, h))
 			   || h->root.type == bfd_link_hash_defweak
 			   || !h->def_regular))))
+	      || (h != NULL
+		  && h->type == STT_GNU_IFUNC
+		  && r_type == R_386_32
+		  && (sec->flags & SEC_CODE) == 0)
 	      || (ELIMINATE_COPY_RELOCS
 		  && !bfd_link_pic (info)
 		  && h != NULL
@@ -2448,12 +2458,17 @@ elf_i386_adjust_dynamic_symbol (struct bfd_link_info *info,
 
 	  if (pc_count || count)
 	    {
-	      h->needs_plt = 1;
 	      h->non_got_ref = 1;
-	      if (h->plt.refcount <= 0)
-		h->plt.refcount = 1;
-	      else
-		h->plt.refcount += 1;
+	      if (pc_count)
+		{
+		  /* Increment PLT reference count only for PC-relative
+		     references.  */
+		  h->needs_plt = 1;
+		  if (h->plt.refcount <= 0)
+		    h->plt.refcount = 1;
+		  else
+		    h->plt.refcount += 1;
+		}
 	    }
 	}
 
@@ -3898,8 +3913,6 @@ elf_i386_relocate_section (bfd *output_bfd,
 		continue;
 	      abort ();
 	    }
-	  else if (h->plt.offset == (bfd_vma) -1)
-	    abort ();
 
 	  /* STT_GNU_IFUNC symbol must go through PLT.  */
 	  if (htab->elf.splt != NULL)
@@ -3913,77 +3926,10 @@ elf_i386_relocate_section (bfd *output_bfd,
 	      gotplt = htab->elf.igotplt;
 	    }
 
-	  relocation = (plt->output_section->vma
-			+ plt->output_offset + h->plt.offset);
-
 	  switch (r_type)
 	    {
 	    default:
-	      if (h->root.root.string)
-		name = h->root.root.string;
-	      else
-		name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
-					 NULL);
-	      (*_bfd_error_handler)
-		(_("%B: relocation %s against STT_GNU_IFUNC "
-		   "symbol `%s' isn't handled by %s"), input_bfd,
-		 elf_howto_table[r_type].name,
-		 name, __FUNCTION__);
-	      bfd_set_error (bfd_error_bad_value);
-	      return FALSE;
-
-	    case R_386_32:
-	      /* Generate dynamic relcoation only when there is a
-		 non-GOT reference in a shared object.  */
-	      if (bfd_link_pic (info) && h->non_got_ref)
-		{
-		  Elf_Internal_Rela outrel;
-		  asection *sreloc;
-		  bfd_vma offset;
-
-		  /* Need a dynamic relocation to get the real function
-		     adddress.  */
-		  offset = _bfd_elf_section_offset (output_bfd,
-						    info,
-						    input_section,
-						    rel->r_offset);
-		  if (offset == (bfd_vma) -1
-		      || offset == (bfd_vma) -2)
-		    abort ();
-
-		  outrel.r_offset = (input_section->output_section->vma
-				     + input_section->output_offset
-				     + offset);
-
-		  if (h->dynindx == -1
-		      || h->forced_local
-		      || bfd_link_executable (info))
-		    {
-		      /* This symbol is resolved locally.  */
-		      outrel.r_info = ELF32_R_INFO (0, R_386_IRELATIVE);
-		      bfd_put_32 (output_bfd,
-				  (h->root.u.def.value
-				   + h->root.u.def.section->output_section->vma
-				   + h->root.u.def.section->output_offset),
-				  contents + offset);
-		    }
-		  else
-		    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
-
-		  sreloc = htab->elf.irelifunc;
-		  elf_append_rel (output_bfd, sreloc, &outrel);
-
-		  /* If this reloc is against an external symbol, we
-		     do not want to fiddle with the addend.  Otherwise,
-		     we need to include the symbol value so that it
-		     becomes an addend for the dynamic reloc.  For an
-		     internal symbol, we have updated addend.  */
-		  continue;
-		}
-	      /* FALLTHROUGH */
-	    case R_386_PC32:
-	    case R_386_PLT32:
-	      goto do_relocation;
+	      break;
 
 	    case R_386_GOT32:
 	    case R_386_GOT32X:
@@ -3999,6 +3945,9 @@ elf_i386_relocate_section (bfd *output_bfd,
 		     even just remember the offset, as finish_dynamic_symbol
 		     would use that as offset into .got.  */
 
+		  if (h->plt.offset == (bfd_vma) -1)
+		    abort ();
+
 		  if (htab->elf.splt != NULL)
 		    {
 		      plt_index = h->plt.offset / plt_entry_size - 1;
@@ -4059,6 +4008,99 @@ elf_i386_relocate_section (bfd *output_bfd,
 		}
 
 	      goto do_relocation;
+	    }
+
+	  if (h->plt.offset == (bfd_vma) -1)
+	    {
+	      /* Handle static pointers of STT_GNU_IFUNC symbols.  */
+	      if (r_type == R_386_32
+		  && (input_section->flags & SEC_CODE) == 0)
+		goto do_ifunc_pointer;
+	      abort ();
+	    }
+
+	  relocation = (plt->output_section->vma
+			+ plt->output_offset + h->plt.offset);
+
+	  switch (r_type)
+	    {
+	    default:
+	      if (h->root.root.string)
+		name = h->root.root.string;
+	      else
+		name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
+					 NULL);
+	      (*_bfd_error_handler)
+		(_("%B: relocation %s against STT_GNU_IFUNC "
+		   "symbol `%s' isn't handled by %s"), input_bfd,
+		 elf_howto_table[r_type].name,
+		 name, __FUNCTION__);
+	      bfd_set_error (bfd_error_bad_value);
+	      return FALSE;
+
+	    case R_386_32:
+	      /* Generate dynamic relcoation only when there is a
+		 non-GOT reference in a shared object.  */
+	      if ((bfd_link_pic (info) && h->non_got_ref)
+		  || h->plt.offset == (bfd_vma) -1)
+		{
+		  Elf_Internal_Rela outrel;
+		  asection *sreloc;
+		  bfd_vma offset;
+
+do_ifunc_pointer:
+		  /* Need a dynamic relocation to get the real function
+		     adddress.  */
+		  offset = _bfd_elf_section_offset (output_bfd,
+						    info,
+						    input_section,
+						    rel->r_offset);
+		  if (offset == (bfd_vma) -1
+		      || offset == (bfd_vma) -2)
+		    abort ();
+
+		  outrel.r_offset = (input_section->output_section->vma
+				     + input_section->output_offset
+				     + offset);
+
+		  if (h->dynindx == -1
+		      || h->forced_local
+		      || bfd_link_executable (info))
+		    {
+		      /* This symbol is resolved locally.  */
+		      outrel.r_info = ELF32_R_INFO (0, R_386_IRELATIVE);
+		      bfd_put_32 (output_bfd,
+				  (h->root.u.def.value
+				   + h->root.u.def.section->output_section->vma
+				   + h->root.u.def.section->output_offset),
+				  contents + offset);
+		    }
+		  else
+		    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
+
+		  /* Dynamic relocations are stored in
+		     1. .rel.ifunc section in PIC object.
+		     2. .rel.got section in dynamic executable.
+		     3. .rel.iplt section in static executable.  */
+		  if (bfd_link_pic (info))
+		    sreloc = htab->elf.irelifunc;
+		  else if (htab->elf.splt != NULL)
+		    sreloc = htab->elf.srelgot;
+		  else
+		    sreloc = htab->elf.irelplt;
+		  elf_append_rel (output_bfd, sreloc, &outrel);
+
+		  /* If this reloc is against an external symbol, we
+		     do not want to fiddle with the addend.  Otherwise,
+		     we need to include the symbol value so that it
+		     becomes an addend for the dynamic reloc.  For an
+		     internal symbol, we have updated addend.  */
+		  continue;
+		}
+	      /* FALLTHROUGH */
+	    case R_386_PC32:
+	    case R_386_PLT32:
+	      goto do_relocation;
 
 	    case R_386_GOTOFF:
 	      relocation -= (gotplt->output_section->vma
@@ -5432,6 +5474,7 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,
       && !local_undefweak)
     {
       Elf_Internal_Rela rel;
+      asection *relgot = htab->elf.srelgot;
 
       /* This symbol has an entry in the global offset table.  Set it
 	 up.  */
@@ -5451,7 +5494,28 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,
       if (h->def_regular
 	  && h->type == STT_GNU_IFUNC)
 	{
-	  if (bfd_link_pic (info))
+	  if (h->plt.offset == (bfd_vma) -1)
+	    {
+	      /* STT_GNU_IFUNC is referenced without PLT.  */
+	      if (htab->elf.splt == NULL)
+		{
+		  /* use .rel[a].iplt section to store .got relocations
+		     in static executable.  */
+		  relgot = htab->elf.irelplt;
+		}
+	      if (SYMBOL_REFERENCES_LOCAL (info, h))
+		{
+		  bfd_put_32 (output_bfd,
+			      (h->root.u.def.value
+			       + h->root.u.def.section->output_section->vma
+			       + h->root.u.def.section->output_offset),
+			      htab->elf.sgot->contents + h->got.offset);
+		  rel.r_info = ELF32_R_INFO (0, R_386_IRELATIVE);
+		}
+	      else
+		goto do_glob_dat;
+	    }
+	  else if (bfd_link_pic (info))
 	    {
 	      /* Generate R_386_GLOB_DAT.  */
 	      goto do_glob_dat;
@@ -5489,7 +5553,7 @@ do_glob_dat:
 	  rel.r_info = ELF32_R_INFO (h->dynindx, R_386_GLOB_DAT);
 	}
 
-      elf_append_rel (output_bfd, htab->elf.srelgot, &rel);
+      elf_append_rel (output_bfd, relgot, &rel);
     }
 
   if (h->needs_copy)
@@ -5826,11 +5890,6 @@ elf_i386_finish_dynamic_sections (bfd *output_bfd,
   if (htab->elf.sgot && htab->elf.sgot->size > 0)
     elf_section_data (htab->elf.sgot->output_section)->this_hdr.sh_entsize = 4;
 
-  /* Fill PLT and GOT entries for local STT_GNU_IFUNC symbols.  */
-  htab_traverse (htab->loc_hash_table,
-		 elf_i386_finish_local_dynamic_symbol,
-		 info);
-
   /* Fill PLT entries for undefined weak symbols in PIE.  */
   if (bfd_link_pie (info))
     bfd_hash_traverse (&info->hash->table,
@@ -5840,6 +5899,33 @@ elf_i386_finish_dynamic_sections (bfd *output_bfd,
   return TRUE;
 }
 
+/* Fill PLT/GOT entries and allocate dynamic relocations for local
+   STT_GNU_IFUNC symbols, which aren't in the ELF linker hash table.
+   It has to be done before elf_link_sort_relocs is called so that
+   dynamic relocations are properly sorted.  */
+
+static bfd_boolean
+elf_i386_output_arch_local_syms
+  (bfd *output_bfd ATTRIBUTE_UNUSED,
+   struct bfd_link_info *info,
+   void *flaginfo ATTRIBUTE_UNUSED,
+   int (*func) (void *, const char *,
+		Elf_Internal_Sym *,
+		asection *,
+		struct elf_link_hash_entry *) ATTRIBUTE_UNUSED)
+{
+  struct elf_i386_link_hash_table *htab = elf_i386_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  /* Fill PLT and GOT entries for local STT_GNU_IFUNC symbols.  */
+  htab_traverse (htab->loc_hash_table,
+		 elf_i386_finish_local_dynamic_symbol,
+		 info);
+
+  return TRUE;
+}
+
 /* Return an array of PLT entry symbol values.  */
 
 static bfd_vma *
@@ -5982,6 +6068,7 @@ elf_i386_hash_symbol (struct elf_link_hash_entry *h)
 #define elf_backend_fake_sections	      elf_i386_fake_sections
 #define elf_backend_finish_dynamic_sections   elf_i386_finish_dynamic_sections
 #define elf_backend_finish_dynamic_symbol     elf_i386_finish_dynamic_symbol
+#define elf_backend_output_arch_local_syms     elf_i386_output_arch_local_syms
 #define elf_backend_gc_mark_hook	      elf_i386_gc_mark_hook
 #define elf_backend_grok_prstatus	      elf_i386_grok_prstatus
 #define elf_backend_grok_psinfo		      elf_i386_grok_psinfo
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index 57a3c73..4ea9702 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -2557,8 +2557,11 @@ pointer:
 	      h->non_got_ref = 1;
 
 	      /* We may need a .plt entry if the function this reloc
-		 refers to is in a shared lib.  */
-	      h->plt.refcount += 1;
+		 in the code section refers to is in a shared lib.  */
+	      if ((sec->flags & SEC_CODE) != 0
+		  || h->type != STT_GNU_IFUNC)
+		h->plt.refcount += 1;
+
 	      if (r_type == R_X86_64_PC32)
 		{
 		  /* Since something like ".long foo - ." may be used
@@ -2605,7 +2608,10 @@ do_size:
 	     If on the other hand, we are creating an executable, we
 	     may need to keep relocations for symbols satisfied by a
 	     dynamic library if we manage to avoid copy relocs for the
-	     symbol.  */
+	     symbol.
+
+	     Generate dynamic pointer relocation against STT_GNU_IFUNC
+	     symbol in the non-code section.  */
 	  if ((bfd_link_pic (info)
 	       && (! IS_X86_64_PCREL_TYPE (r_type)
 		   || (h != NULL
@@ -2613,6 +2619,10 @@ do_size:
 			      || SYMBOLIC_BIND (info, h))
 			   || h->root.type == bfd_link_hash_defweak
 			   || !h->def_regular))))
+	      || (h != NULL
+		  && h->type == STT_GNU_IFUNC
+		  && r_type == htab->pointer_r_type
+		  && (sec->flags & SEC_CODE) == 0)
 	      || (ELIMINATE_COPY_RELOCS
 		  && !bfd_link_pic (info)
 		  && h != NULL
@@ -2850,12 +2860,17 @@ elf_x86_64_adjust_dynamic_symbol (struct bfd_link_info *info,
 
 	  if (pc_count || count)
 	    {
-	      h->needs_plt = 1;
 	      h->non_got_ref = 1;
-	      if (h->plt.refcount <= 0)
-		h->plt.refcount = 1;
-	      else
-		h->plt.refcount += 1;
+	      if (pc_count)
+		{
+		  /* Increment PLT reference count only for PC-relative
+		     references.  */
+		  h->needs_plt = 1;
+		  if (h->plt.refcount <= 0)
+		    h->plt.refcount = 1;
+		  else
+		    h->plt.refcount += 1;
+		}
 	    }
 	}
 
@@ -4233,8 +4248,84 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 		continue;
 	      abort ();
 	    }
-	  else if (h->plt.offset == (bfd_vma) -1)
-	    abort ();
+
+	  switch (r_type)
+	    {
+	    default:
+	      break;
+
+	    case R_X86_64_GOTPCREL:
+	    case R_X86_64_GOTPCRELX:
+	    case R_X86_64_REX_GOTPCRELX:
+	    case R_X86_64_GOTPCREL64:
+	      base_got = htab->elf.sgot;
+	      off = h->got.offset;
+
+	      if (base_got == NULL)
+		abort ();
+
+	      if (off == (bfd_vma) -1)
+		{
+		  /* We can't use h->got.offset here to save state, or
+		     even just remember the offset, as finish_dynamic_symbol
+		     would use that as offset into .got.  */
+
+		  if (h->plt.offset == (bfd_vma) -1)
+		    abort ();
+
+		  if (htab->elf.splt != NULL)
+		    {
+		      plt_index = h->plt.offset / plt_entry_size - 1;
+		      off = (plt_index + 3) * GOT_ENTRY_SIZE;
+		      base_got = htab->elf.sgotplt;
+		    }
+		  else
+		    {
+		      plt_index = h->plt.offset / plt_entry_size;
+		      off = plt_index * GOT_ENTRY_SIZE;
+		      base_got = htab->elf.igotplt;
+		    }
+
+		  if (h->dynindx == -1
+		      || h->forced_local
+		      || info->symbolic)
+		    {
+		      /* This references the local defitionion.  We must
+			 initialize this entry in the global offset table.
+			 Since the offset must always be a multiple of 8,
+			 we use the least significant bit to record
+			 whether we have initialized it already.
+
+			 When doing a dynamic link, we create a .rela.got
+			 relocation entry to initialize the value.  This
+			 is done in the finish_dynamic_symbol routine.	 */
+		      if ((off & 1) != 0)
+			off &= ~1;
+		      else
+			{
+			  bfd_put_64 (output_bfd, relocation,
+				      base_got->contents + off);
+			  /* Note that this is harmless for the GOTPLT64
+			     case, as -1 | 1 still is -1.  */
+			  h->got.offset |= 1;
+			}
+		    }
+		}
+
+	      relocation = (base_got->output_section->vma
+			    + base_got->output_offset + off);
+
+	      goto do_relocation;
+	    }
+
+	  if (h->plt.offset == (bfd_vma) -1)
+	    {
+	      /* Handle static pointers of STT_GNU_IFUNC symbols.  */
+	      if (r_type == htab->pointer_r_type
+		  && (input_section->flags & SEC_CODE) == 0)
+		goto do_ifunc_pointer;
+	      abort ();
+	    }
 
 	  /* STT_GNU_IFUNC symbol must go through PLT.  */
 	  if (htab->elf.splt != NULL)
@@ -4284,6 +4375,7 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 		goto do_relocation;
 	      /* FALLTHROUGH */
 	    case R_X86_64_64:
+do_ifunc_pointer:
 	      if (rel->r_addend != 0)
 		{
 		  if (h->root.root.string)
@@ -4300,8 +4392,10 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 		}
 
 	      /* Generate dynamic relcoation only when there is a
-		 non-GOT reference in a shared object.  */
-	      if (bfd_link_pic (info) && h->non_got_ref)
+		 non-GOT reference in a shared object or there is no
+		 PLT.  */
+	      if ((bfd_link_pic (info) && h->non_got_ref)
+		  || h->plt.offset == (bfd_vma) -1)
 		{
 		  Elf_Internal_Rela outrel;
 		  asection *sreloc;
@@ -4335,7 +4429,16 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 		      outrel.r_addend = 0;
 		    }
 
-		  sreloc = htab->elf.irelifunc;
+		  /* Dynamic relocations are stored in
+		     1. .rela.ifunc section in PIC object.
+		     2. .rela.got section in dynamic executable.
+		     3. .rela.iplt section in static executable.  */
+		  if (bfd_link_pic (info))
+		    sreloc = htab->elf.irelifunc;
+		  else if (htab->elf.splt != NULL)
+		    sreloc = htab->elf.srelgot;
+		  else
+		    sreloc = htab->elf.irelplt;
 		  elf_append_rela (output_bfd, sreloc, &outrel);
 
 		  /* If this reloc is against an external symbol, we
@@ -4352,66 +4455,6 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 	    case R_X86_64_PLT32:
 	    case R_X86_64_PLT32_BND:
 	      goto do_relocation;
-
-	    case R_X86_64_GOTPCREL:
-	    case R_X86_64_GOTPCRELX:
-	    case R_X86_64_REX_GOTPCRELX:
-	    case R_X86_64_GOTPCREL64:
-	      base_got = htab->elf.sgot;
-	      off = h->got.offset;
-
-	      if (base_got == NULL)
-		abort ();
-
-	      if (off == (bfd_vma) -1)
-		{
-		  /* We can't use h->got.offset here to save state, or
-		     even just remember the offset, as finish_dynamic_symbol
-		     would use that as offset into .got.  */
-
-		  if (htab->elf.splt != NULL)
-		    {
-		      plt_index = h->plt.offset / plt_entry_size - 1;
-		      off = (plt_index + 3) * GOT_ENTRY_SIZE;
-		      base_got = htab->elf.sgotplt;
-		    }
-		  else
-		    {
-		      plt_index = h->plt.offset / plt_entry_size;
-		      off = plt_index * GOT_ENTRY_SIZE;
-		      base_got = htab->elf.igotplt;
-		    }
-
-		  if (h->dynindx == -1
-		      || h->forced_local
-		      || info->symbolic)
-		    {
-		      /* This references the local defitionion.  We must
-			 initialize this entry in the global offset table.
-			 Since the offset must always be a multiple of 8,
-			 we use the least significant bit to record
-			 whether we have initialized it already.
-
-			 When doing a dynamic link, we create a .rela.got
-			 relocation entry to initialize the value.  This
-			 is done in the finish_dynamic_symbol routine.	 */
-		      if ((off & 1) != 0)
-			off &= ~1;
-		      else
-			{
-			  bfd_put_64 (output_bfd, relocation,
-				      base_got->contents + off);
-			  /* Note that this is harmless for the GOTPLT64
-			     case, as -1 | 1 still is -1.  */
-			  h->got.offset |= 1;
-			}
-		    }
-		}
-
-	      relocation = (base_got->output_section->vma
-			    + base_got->output_offset + off);
-
-	      goto do_relocation;
 	    }
 	}
 
@@ -5870,6 +5913,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
       && !local_undefweak)
     {
       Elf_Internal_Rela rela;
+      asection *relgot = htab->elf.srelgot;
 
       /* This symbol has an entry in the global offset table.  Set it
 	 up.  */
@@ -5888,7 +5932,27 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
       if (h->def_regular
 	  && h->type == STT_GNU_IFUNC)
 	{
-	  if (bfd_link_pic (info))
+	  if (h->plt.offset == (bfd_vma) -1)
+	    {
+	      /* STT_GNU_IFUNC is referenced without PLT.  */
+	      if (htab->elf.splt == NULL)
+		{
+		  /* use .rel[a].iplt section to store .got relocations
+		     in static executable.  */
+		  relgot = htab->elf.irelplt;
+		}
+	      if (SYMBOL_REFERENCES_LOCAL (info, h))
+		{
+		  rela.r_info = htab->r_info (0,
+					      R_X86_64_IRELATIVE);
+		  rela.r_addend = (h->root.u.def.value
+				   + h->root.u.def.section->output_section->vma
+				   + h->root.u.def.section->output_offset);
+		}
+	      else
+		goto do_glob_dat;
+	    }
+	  else if (bfd_link_pic (info))
 	    {
 	      /* Generate R_X86_64_GLOB_DAT.  */
 	      goto do_glob_dat;
@@ -5932,7 +5996,7 @@ do_glob_dat:
 	  rela.r_addend = 0;
 	}
 
-      elf_append_rela (output_bfd, htab->elf.srelgot, &rela);
+      elf_append_rela (output_bfd, relgot, &rela);
     }
 
   if (h->needs_copy)
@@ -6265,11 +6329,6 @@ elf_x86_64_finish_dynamic_sections (bfd *output_bfd,
     elf_section_data (htab->elf.sgot->output_section)->this_hdr.sh_entsize
       = GOT_ENTRY_SIZE;
 
-  /* Fill PLT and GOT entries for local STT_GNU_IFUNC symbols.  */
-  htab_traverse (htab->loc_hash_table,
-		 elf_x86_64_finish_local_dynamic_symbol,
-		 info);
-
   /* Fill PLT entries for undefined weak symbols in PIE.  */
   if (bfd_link_pie (info))
     bfd_hash_traverse (&info->hash->table,
@@ -6279,6 +6338,33 @@ elf_x86_64_finish_dynamic_sections (bfd *output_bfd,
   return TRUE;
 }
 
+/* Fill PLT/GOT entries and allocate dynamic relocations for local
+   STT_GNU_IFUNC symbols, which aren't in the ELF linker hash table.
+   It has to be done before elf_link_sort_relocs is called so that
+   dynamic relocations are properly sorted.  */
+
+static bfd_boolean
+elf_x86_64_output_arch_local_syms
+  (bfd *output_bfd ATTRIBUTE_UNUSED,
+   struct bfd_link_info *info,
+   void *flaginfo ATTRIBUTE_UNUSED,
+   int (*func) (void *, const char *,
+		Elf_Internal_Sym *,
+		asection *,
+		struct elf_link_hash_entry *) ATTRIBUTE_UNUSED)
+{
+  struct elf_x86_64_link_hash_table *htab = elf_x86_64_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  /* Fill PLT and GOT entries for local STT_GNU_IFUNC symbols.  */
+  htab_traverse (htab->loc_hash_table,
+		 elf_x86_64_finish_local_dynamic_symbol,
+		 info);
+
+  return TRUE;
+}
+
 /* Return an array of PLT entry symbol values.  */
 
 static bfd_vma *
@@ -6641,6 +6727,7 @@ static const struct bfd_elf_special_section
 #define elf_backend_create_dynamic_sections elf_x86_64_create_dynamic_sections
 #define elf_backend_finish_dynamic_sections elf_x86_64_finish_dynamic_sections
 #define elf_backend_finish_dynamic_symbol   elf_x86_64_finish_dynamic_symbol
+#define elf_backend_output_arch_local_syms  elf_x86_64_output_arch_local_syms
 #define elf_backend_gc_mark_hook	    elf_x86_64_gc_mark_hook
 #define elf_backend_grok_prstatus	    elf_x86_64_grok_prstatus
 #define elf_backend_grok_psinfo		    elf_x86_64_grok_psinfo
diff --git a/ld/testsuite/ld-i386/no-plt.exp b/ld/testsuite/ld-i386/no-plt.exp
index c4af0a9..8133866 100644
--- a/ld/testsuite/ld-i386/no-plt.exp
+++ b/ld/testsuite/ld-i386/no-plt.exp
@@ -265,6 +265,27 @@ if { [check_ifunc_available] } {
 	    "-fPIC -O2 -g" \
 	    { pr20244-3a.c pr20244-3b.S pr20244-3c.S pr20244-3d.S } \
 	] \
+	[list \
+	    "Build pr20253-1a.o pr20253-1b.o pr20253-1c.o pr20253-1d.o" \
+	    "" \
+	    "-fPIE -O2 -g" \
+	    { pr20253-1a.c pr20253-1b.S pr20253-1c.S pr20253-1d.S } \
+	] \
+	[list \
+	    "Build libpr20253-1a.so" \
+	    "-shared tmpdir/pr20253-1b.o \
+	     tmpdir/pr20253-1c.o tmpdir/pr20253-1d.o" \
+	    "" \
+	    { dummy.s } \
+	    {} \
+	    "libpr20253-1a.so" \
+	] \
+	[list \
+	    "Build pr20253-2a.o pr20253-2b.o pr20253-2c.o pr20253-2d.o" \
+	    "" \
+	    "-fPIE -O2 -g" \
+	    { pr20253-2a.c pr20253-2b.S pr20253-2c.S pr20253-2d.S } \
+	] \
     ]
 
     run_ld_link_exec_tests [] [list \
@@ -286,5 +307,66 @@ if { [check_ifunc_available] } {
 	    "pr20244-3b" \
 	    "pass.out" \
 	] \
+	[list \
+	    "Run pr20253-1a" \
+	    "tmpdir/pr20253-1a.o tmpdir/pr20253-1b.o \
+	     tmpdir/pr20253-1c.o tmpdir/pr20253-1d.o" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-1a" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-1b" \
+	    "--static tmpdir/pr20253-1a.o tmpdir/pr20253-1b.o \
+	    tmpdir/pr20253-1c.o tmpdir/pr20253-1d.o" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-1b" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-1c" \
+	    "-pie tmpdir/pr20253-1a.o tmpdir/pr20253-1b.o \
+	    tmpdir/pr20253-1c.o tmpdir/pr20253-1d.o" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-1c" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-1d" \
+	    "tmpdir/pr20253-1a.o tmpdir/libpr20253-1a.so" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-1d" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-1e" \
+	    "-pie tmpdir/pr20253-1a.o tmpdir/libpr20253-1a.so" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-1e" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-2a" \
+	    "tmpdir/pr20253-2a.o tmpdir/pr20253-2b.o \
+	     tmpdir/pr20253-2c.o tmpdir/pr20253-2d.o" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-2a" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-2b" \
+	    "--static tmpdir/pr20253-2a.o tmpdir/pr20253-2b.o \
+	    tmpdir/pr20253-2c.o tmpdir/pr20253-2d.o" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-2b" \
+	    "pass.out" \
+	] \
     ]
 }
diff --git a/ld/testsuite/ld-i386/pr13302.d b/ld/testsuite/ld-i386/pr13302.d
index 35c09ae..f205126 100644
--- a/ld/testsuite/ld-i386/pr13302.d
+++ b/ld/testsuite/ld-i386/pr13302.d
@@ -3,10 +3,7 @@
 #ld: -pie -melf_i386
 #readelf: -r --wide
 
-Relocation section '.rel.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+Relocation section '.rel.dyn' at offset 0x[0-9a-f]+ contains 2 entries:
  Offset     Info    Type                Sym. Value  Symbol's Name
 [0-9a-f]+ +[0-9a-f]+ +R_386_IRELATIVE +
-
-Relocation section '.rel.plt' at offset 0x[0-9a-f]+ contains 1 entries:
- Offset     Info    Type                Sym. Value  Symbol's Name
 [0-9a-f]+ +[0-9a-f]+ +R_386_IRELATIVE +
diff --git a/ld/testsuite/ld-i386/pr20244-2a.d b/ld/testsuite/ld-i386/pr20244-2a.d
index a04902f..ec3948e 100644
--- a/ld/testsuite/ld-i386/pr20244-2a.d
+++ b/ld/testsuite/ld-i386/pr20244-2a.d
@@ -8,36 +8,25 @@
 
 SYMBOL TABLE:
 #...
-0+80480b1 l   i   .text	00000000 bar
+0+8048085 l   i   .text	00000000 bar
 #...
-0+80480b2 g     F .text	00000000 _start
+0+8048086 g     F .text	00000000 _start
 #...
-0+80480b0 g   i   .text	00000000 foo
+0+8048084 g   i   .text	00000000 foo
 #...
 
-
-Disassembly of section .plt:
-
-0+8048090 <.plt>:
- +[a-f0-9]+:	ff 25 e0 90 04 08    	jmp    \*0x80490e0
- +[a-f0-9]+:	68 00 00 00 00       	push   \$0x0
- +[a-f0-9]+:	e9 00 00 00 00       	jmp    80480a0 <foo-0x10>
- +[a-f0-9]+:	ff 25 e4 90 04 08    	jmp    \*0x80490e4
- +[a-f0-9]+:	68 00 00 00 00       	push   \$0x0
- +[a-f0-9]+:	e9 00 00 00 00       	jmp    80480b0 <foo>
-
 Disassembly of section .text:
 
-0+80480b0 <foo>:
+0+8048084 <foo>:
  +[a-f0-9]+:	c3                   	ret    
 
-0+80480b1 <bar>:
+0+8048085 <bar>:
  +[a-f0-9]+:	c3                   	ret    
 
-0+80480b2 <_start>:
- +[a-f0-9]+:	ff 15 e0 90 04 08    	call   \*0x80490e0
- +[a-f0-9]+:	ff 25 e4 90 04 08    	jmp    \*0x80490e4
- +[a-f0-9]+:	c7 05 e4 90 04 08 00 00 00 00 	movl   \$0x0,0x80490e4
- +[a-f0-9]+:	83 3d e0 90 04 08 00 	cmpl   \$0x0,0x80490e0
- +[a-f0-9]+:	b9 10 00 00 00       	mov    \$0x10,%ecx
+0+8048086 <_start>:
+ +[a-f0-9]+:	ff 15 a8 90 04 08    	call   \*0x80490a8
+ +[a-f0-9]+:	ff 25 ac 90 04 08    	jmp    \*0x80490ac
+ +[a-f0-9]+:	c7 05 ac 90 04 08 00 00 00 00 	movl   \$0x0,0x80490ac
+ +[a-f0-9]+:	83 3d a8 90 04 08 00 	cmpl   \$0x0,0x80490a8
+ +[a-f0-9]+:	b9 fc ff ff ff       	mov    \$0xfffffffc,%ecx
 #pass
diff --git a/ld/testsuite/ld-i386/pr20244-2b.d b/ld/testsuite/ld-i386/pr20244-2b.d
index fc0fa17..f23a406 100644
--- a/ld/testsuite/ld-i386/pr20244-2b.d
+++ b/ld/testsuite/ld-i386/pr20244-2b.d
@@ -7,5 +7,4 @@
 .*: +file format .*
 
 Contents of section .got.plt:
- 80490d4 00000000 00000000 00000000 b0800408  ................
- 80490e4 b1800408                             ....            
+ 80490b0 00000000 00000000 00000000           ............    
diff --git a/ld/testsuite/ld-i386/pr20244-2c.d b/ld/testsuite/ld-i386/pr20244-2c.d
index 54eee9f..acca560 100644
--- a/ld/testsuite/ld-i386/pr20244-2c.d
+++ b/ld/testsuite/ld-i386/pr20244-2c.d
@@ -6,5 +6,5 @@
 
 Relocation section '.rel.plt' at offset 0x74 contains 2 entries:
  Offset     Info    Type                Sym. Value  Symbol's Name
-0+80490e4  0000002a R_386_IRELATIVE       
-0+80490e0  0000002a R_386_IRELATIVE       
+0+80490ac  0000002a R_386_IRELATIVE       
+0+80490a8  0000002a R_386_IRELATIVE       
diff --git a/ld/testsuite/ld-i386/pr20253-1a.c b/ld/testsuite/ld-i386/pr20253-1a.c
new file mode 100644
index 0000000..370275a
--- /dev/null
+++ b/ld/testsuite/ld-i386/pr20253-1a.c
@@ -0,0 +1,8 @@
+extern void check (void);
+
+int
+main ()
+{
+  check ();
+  return 0;
+}
diff --git a/ld/testsuite/ld-i386/pr20253-1b.S b/ld/testsuite/ld-i386/pr20253-1b.S
new file mode 100644
index 0000000..d600bc7
--- /dev/null
+++ b/ld/testsuite/ld-i386/pr20253-1b.S
@@ -0,0 +1,48 @@
+	.section	.rodata.str1.1,"aMS",@progbits,1
+.LC0:
+	.string	"PASS"
+	.text
+	.globl	check
+	.type	check, @function
+check:
+	pushl	%ebx
+	call	__x86.get_pc_thunk.bx
+	addl	$_GLOBAL_OFFSET_TABLE_, %ebx
+	subl	$8, %esp
+	call	*get_func1@GOT(%ebx)
+	cmpl	func1@GOT(%ebx), %eax
+	jne	.L3
+	movl	func1_p@GOT(%ebx), %edx
+	cmpl	%eax, (%edx)
+	jne	.L3
+	call	*func1@GOT(%ebx)
+	cmpl	$1, %eax
+	jne	.L3
+	call	*call_func1@GOT(%ebx)
+	cmpl	$1, %eax
+	jne	.L3
+	call	*get_func2@GOT(%ebx)
+	movl	func2_p@GOT(%ebx), %edx
+	cmpl	%eax, (%edx)
+	jne	.L3
+	call	*call_func2@GOT(%ebx)
+	cmpl	$2, %eax
+	jne	.L3
+	leal	.LC0@GOTOFF(%ebx), %eax
+	subl	$12, %esp
+	pushl	%eax
+	call	*puts@GOT(%ebx)
+	addl	$24, %esp
+	popl	%ebx
+	ret
+.L3:
+	call	*abort@GOT(%ebx)
+	.size	check, .-check
+	.section	.text.__x86.get_pc_thunk.bx,"axG",@progbits,__x86.get_pc_thunk.bx,comdat
+	.globl	__x86.get_pc_thunk.bx
+	.hidden	__x86.get_pc_thunk.bx
+	.type	__x86.get_pc_thunk.bx, @function
+__x86.get_pc_thunk.bx:
+	movl	(%esp), %ebx
+	ret
+	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-i386/pr20253-1c.S b/ld/testsuite/ld-i386/pr20253-1c.S
new file mode 100644
index 0000000..f8ee774
--- /dev/null
+++ b/ld/testsuite/ld-i386/pr20253-1c.S
@@ -0,0 +1,31 @@
+	.text
+	.globl	get_func1
+	.type	get_func1, @function
+get_func1:
+	call	__x86.get_pc_thunk.ax
+	addl	$_GLOBAL_OFFSET_TABLE_, %eax
+	movl	func1@GOT(%eax), %eax
+	ret
+	.size	get_func1, .-get_func1
+	.globl	call_func1
+	.type	call_func1, @function
+call_func1:
+	call	__x86.get_pc_thunk.ax
+	addl	$_GLOBAL_OFFSET_TABLE_, %eax
+	jmp	*func1@GOT(%eax)
+	.size	call_func1, .-call_func1
+	.globl	func1_p
+	.section	.data.rel,"aw",@progbits
+	.align 4
+	.type	func1_p, @object
+	.size	func1_p, 4
+func1_p:
+	.long	func1
+	.section	.text.__x86.get_pc_thunk.ax,"axG",@progbits,__x86.get_pc_thunk.ax,comdat
+	.globl	__x86.get_pc_thunk.ax
+	.hidden	__x86.get_pc_thunk.ax
+	.type	__x86.get_pc_thunk.ax, @function
+__x86.get_pc_thunk.ax:
+	movl	(%esp), %eax
+	ret
+	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-i386/pr20253-1d.S b/ld/testsuite/ld-i386/pr20253-1d.S
new file mode 100644
index 0000000..8f9445b
--- /dev/null
+++ b/ld/testsuite/ld-i386/pr20253-1d.S
@@ -0,0 +1,77 @@
+	.text
+	.type	implementation1, @function
+implementation1:
+	movl	$1, %eax
+	ret
+	.size	implementation1, .-implementation1
+	.type	implementation2, @function
+implementation2:
+	movl	$2, %eax
+	ret
+	.size	implementation2, .-implementation2
+	.type	resolver2, @function
+resolver2:
+	call	__x86.get_pc_thunk.ax
+	addl	$_GLOBAL_OFFSET_TABLE_, %eax
+	leal	implementation2@GOTOFF(%eax), %eax
+	ret
+	.size	resolver2, .-resolver2
+	.type	func2, @gnu_indirect_function
+	.set	func2,resolver2
+	.type	resolver1, @function
+resolver1:
+	call	__x86.get_pc_thunk.ax
+	addl	$_GLOBAL_OFFSET_TABLE_, %eax
+	leal	implementation1@GOTOFF(%eax), %eax
+	ret
+	.size	resolver1, .-resolver1
+	.globl	func1
+	.type	func1, @gnu_indirect_function
+	.set	func1,resolver1
+	.globl	get_func2
+	.type	get_func2, @function
+get_func2:
+	call	__x86.get_pc_thunk.ax
+	addl	$_GLOBAL_OFFSET_TABLE_, %eax
+	movl	func2@GOT(%eax), %eax
+	ret
+	.size	get_func2, .-get_func2
+	.globl	call_func2
+	.type	call_func2, @function
+call_func2:
+	pushl	%ebx
+	call	__x86.get_pc_thunk.bx
+	addl	$_GLOBAL_OFFSET_TABLE_, %ebx
+	subl	$8, %esp
+	call	*get_func2@GOT(%ebx)
+	cmpl	func2@GOT(%ebx), %eax
+	jne	.L10
+	addl	$8, %esp
+	movl	%ebx, %eax
+	popl	%ebx
+	jmp	*func2@GOT(%eax)
+.L10:
+	call	*abort@GOT(%ebx)
+	.size	call_func2, .-call_func2
+	.globl	func2_p
+	.section	.data.rel,"aw",@progbits
+	.align 4
+	.type	func2_p, @object
+	.size	func2_p, 4
+func2_p:
+	.long	func2
+	.section	.text.__x86.get_pc_thunk.ax,"axG",@progbits,__x86.get_pc_thunk.ax,comdat
+	.globl	__x86.get_pc_thunk.ax
+	.hidden	__x86.get_pc_thunk.ax
+	.type	__x86.get_pc_thunk.ax, @function
+__x86.get_pc_thunk.ax:
+	movl	(%esp), %eax
+	ret
+	.section	.text.__x86.get_pc_thunk.bx,"axG",@progbits,__x86.get_pc_thunk.bx,comdat
+	.globl	__x86.get_pc_thunk.bx
+	.hidden	__x86.get_pc_thunk.bx
+	.type	__x86.get_pc_thunk.bx, @function
+__x86.get_pc_thunk.bx:
+	movl	(%esp), %ebx
+	ret
+	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-i386/pr20253-2a.c b/ld/testsuite/ld-i386/pr20253-2a.c
new file mode 100644
index 0000000..370275a
--- /dev/null
+++ b/ld/testsuite/ld-i386/pr20253-2a.c
@@ -0,0 +1,8 @@
+extern void check (void);
+
+int
+main ()
+{
+  check ();
+  return 0;
+}
diff --git a/ld/testsuite/ld-i386/pr20253-2b.S b/ld/testsuite/ld-i386/pr20253-2b.S
new file mode 100644
index 0000000..d4be99a
--- /dev/null
+++ b/ld/testsuite/ld-i386/pr20253-2b.S
@@ -0,0 +1,35 @@
+	.section	.rodata.str1.1,"aMS",@progbits,1
+.LC0:
+	.string	"PASS"
+	.text
+	.globl	check
+	.type	check, @function
+check:
+	subl	$12, %esp
+	call	*get_func1@GOT
+	movl	func1@GOT, %edx
+	cmpl	%edx, %eax
+	jne	.L3
+	cmpl	%edx, func1_p
+	jne	.L3
+	call	*func1@GOT
+	cmpl	$1, %eax
+	jne	.L3
+	call	*call_func1@GOT
+	cmpl	$1, %eax
+	jne	.L3
+	call	*get_func2@GOT
+	cmpl	%eax, func2_p
+	jne	.L3
+	call	*call_func2@GOT
+	cmpl	$2, %eax
+	jne	.L3
+	subl	$12, %esp
+	pushl	$.LC0
+	call	*puts@GOT
+	addl	$28, %esp
+	ret
+.L3:
+	call	*abort@GOT
+	.size	check, .-check
+	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-i386/pr20253-2c.S b/ld/testsuite/ld-i386/pr20253-2c.S
new file mode 100644
index 0000000..34a7fdc
--- /dev/null
+++ b/ld/testsuite/ld-i386/pr20253-2c.S
@@ -0,0 +1,20 @@
+	.text
+	.globl	get_func1
+	.type	get_func1, @function
+get_func1:
+	movl	func1@GOT, %eax
+	ret
+	.size	get_func1, .-get_func1
+	.globl	call_func1
+	.type	call_func1, @function
+call_func1:
+	jmp	*func1@GOT
+	.size	call_func1, .-call_func1
+	.globl	func1_p
+	.data
+	.align 4
+	.type	func1_p, @object
+	.size	func1_p, 4
+func1_p:
+	.long	func1
+	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-i386/pr20253-2d.S b/ld/testsuite/ld-i386/pr20253-2d.S
new file mode 100644
index 0000000..7786589
--- /dev/null
+++ b/ld/testsuite/ld-i386/pr20253-2d.S
@@ -0,0 +1,45 @@
+	.text
+	.type	implementation1, @function
+implementation1:
+	movl	$1, %eax
+	ret
+	.size	implementation1, .-implementation1
+	.type	implementation2, @function
+implementation2:
+	movl	$2, %eax
+	ret
+	.size	implementation2, .-implementation2
+	.type	resolver2, @function
+resolver2:
+	movl	$implementation2, %eax
+	ret
+	.size	resolver2, .-resolver2
+	.type	func2, @gnu_indirect_function
+	.set	func2,resolver2
+	.type	resolver1, @function
+resolver1:
+	movl	$implementation1, %eax
+	ret
+	.size	resolver1, .-resolver1
+	.globl	func1
+	.type	func1, @gnu_indirect_function
+	.set	func1,resolver1
+	.globl	get_func2
+	.type	get_func2, @function
+get_func2:
+	movl	func2@GOT, %eax
+	ret
+	.size	get_func2, .-get_func2
+	.globl	call_func2
+	.type	call_func2, @function
+call_func2:
+	jmp	*func2@GOT
+	.size	call_func2, .-call_func2
+	.globl	func2_p
+	.data
+	.align 4
+	.type	func2_p, @object
+	.size	func2_p, 4
+func2_p:
+	.long	func2
+	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-ifunc/ifunc-13-i386.d b/ld/testsuite/ld-ifunc/ifunc-13-i386.d
index 677fa92..5f9309c 100644
--- a/ld/testsuite/ld-ifunc/ifunc-13-i386.d
+++ b/ld/testsuite/ld-ifunc/ifunc-13-i386.d
@@ -5,10 +5,10 @@
 #readelf: -r --wide
 #target: x86_64-*-* i?86-*-*
 
-Relocation section '.rel.ifunc' at offset 0x[0-9a-f]+ contains 1 entries:
+Relocation section '.rel.got' at offset 0x[0-9a-f]+ contains 1 entries:
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_32[ ]+ifunc\(\)[ ]+ifunc
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_GLOB_DAT[ ]+ifunc\(\)[ ]+ifunc
 
-Relocation section '.rel.plt' at offset 0x[0-9a-f]+ contains 1 entries:
+Relocation section '.rel.ifunc' at offset 0x[0-9a-f]+ contains 1 entries:
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_JUMP_SLOT[ ]+ifunc\(\)[ ]+ifunc
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_32[ ]+ifunc\(\)[ ]+ifunc
diff --git a/ld/testsuite/ld-ifunc/ifunc-13-x86-64.d b/ld/testsuite/ld-ifunc/ifunc-13-x86-64.d
index b01c735..bcd4ae3 100644
--- a/ld/testsuite/ld-ifunc/ifunc-13-x86-64.d
+++ b/ld/testsuite/ld-ifunc/ifunc-13-x86-64.d
@@ -5,10 +5,10 @@
 #readelf: -r --wide
 #target: x86_64-*-*
 
-Relocation section '.rela.ifunc' at offset 0x[0-9a-f]+ contains 1 entries:
+Relocation section '.rela.got' at offset 0x[0-9a-f]+ contains 1 entries:
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_64[ ]+ifunc\(\)[ ]+ifunc \+ 0
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_GLOB_DAT[ ]+ifunc\(\)[ ]+ifunc \+ 0
 
-Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
+Relocation section '.rela.ifunc' at offset 0x[0-9a-f]+ contains 1 entries:
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_JUMP_SLOT[ ]+ifunc\(\)[ ]+ifunc \+ 0
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_64[ ]+ifunc\(\)[ ]+ifunc \+ 0
diff --git a/ld/testsuite/ld-ifunc/ifunc-15-i386.d b/ld/testsuite/ld-ifunc/ifunc-15-i386.d
index c37dd51..0d44ba1 100644
--- a/ld/testsuite/ld-ifunc/ifunc-15-i386.d
+++ b/ld/testsuite/ld-ifunc/ifunc-15-i386.d
@@ -7,7 +7,3 @@
 Relocation section '.rel.got' at offset 0x[0-9a-f]+ contains 1 entries:
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_GLOB_DAT[ ]+ifunc\(\)[ ]+ifunc
-
-Relocation section '.rel.plt' at offset 0x[0-9a-f]+ contains 1 entries:
-[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_JUMP_SLOT[ ]+ifunc\(\)[ ]+ifunc
diff --git a/ld/testsuite/ld-ifunc/ifunc-15-x86-64.d b/ld/testsuite/ld-ifunc/ifunc-15-x86-64.d
index a4a5cb1..8a28ec9 100644
--- a/ld/testsuite/ld-ifunc/ifunc-15-x86-64.d
+++ b/ld/testsuite/ld-ifunc/ifunc-15-x86-64.d
@@ -7,7 +7,3 @@
 Relocation section '.rela.got' at offset 0x[0-9a-f]+ contains 1 entries:
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_GLOB_DAT[ ]+ifunc\(\)[ ]+ifunc \+ 0
-
-Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
-[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_JUMP_SLOT[ ]+ifunc\(\)[ ]+ifunc \+ 0
diff --git a/ld/testsuite/ld-ifunc/ifunc-18a-i386.d b/ld/testsuite/ld-ifunc/ifunc-18a-i386.d
index 10490b1..233df61 100644
--- a/ld/testsuite/ld-ifunc/ifunc-18a-i386.d
+++ b/ld/testsuite/ld-ifunc/ifunc-18a-i386.d
@@ -5,6 +5,10 @@
 #readelf: -r --wide
 #target: x86_64-*-* i?86-*-*
 
+Relocation section '.rel.got' at .*
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_IRELATIVE[ ]*
+
 Relocation section '.rel.ifunc' at .*
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_IRELATIVE[ ]*
@@ -12,4 +16,3 @@ Relocation section '.rel.ifunc' at .*
 Relocation section '.rel.plt' at .*
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_IRELATIVE[ ]*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_IRELATIVE[ ]*
diff --git a/ld/testsuite/ld-ifunc/ifunc-18a-x86-64.d b/ld/testsuite/ld-ifunc/ifunc-18a-x86-64.d
index 0d600eb..4963d28 100644
--- a/ld/testsuite/ld-ifunc/ifunc-18a-x86-64.d
+++ b/ld/testsuite/ld-ifunc/ifunc-18a-x86-64.d
@@ -5,6 +5,10 @@
 #readelf: -r --wide
 #target: x86_64-*-*
 
+Relocation section '.rela.got' at .*
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
+
 Relocation section '.rela.ifunc' at .*
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
@@ -12,4 +16,3 @@ Relocation section '.rela.ifunc' at .*
 Relocation section '.rela.plt' at .*
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
diff --git a/ld/testsuite/ld-ifunc/ifunc-18b-i386.d b/ld/testsuite/ld-ifunc/ifunc-18b-i386.d
index a5eda94..bc3a975 100644
--- a/ld/testsuite/ld-ifunc/ifunc-18b-i386.d
+++ b/ld/testsuite/ld-ifunc/ifunc-18b-i386.d
@@ -5,6 +5,10 @@
 #readelf: -r --wide
 #target: x86_64-*-* i?86-*-*
 
+Relocation section '.rel.got' at .*
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_IRELATIVE[ ]*
+
 Relocation section '.rel.ifunc' at .*
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_IRELATIVE[ ]*
@@ -12,4 +16,3 @@ Relocation section '.rel.ifunc' at .*
 Relocation section '.rel.plt' at .*
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_IRELATIVE[ ]*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_IRELATIVE[ ]*
diff --git a/ld/testsuite/ld-ifunc/ifunc-18b-x86-64.d b/ld/testsuite/ld-ifunc/ifunc-18b-x86-64.d
index 8dfebfb..00a95ef 100644
--- a/ld/testsuite/ld-ifunc/ifunc-18b-x86-64.d
+++ b/ld/testsuite/ld-ifunc/ifunc-18b-x86-64.d
@@ -5,6 +5,10 @@
 #readelf: -r --wide
 #target: x86_64-*-*
 
+Relocation section '.rela.got' at .*
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
+
 Relocation section '.rela.ifunc' at .*
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
@@ -12,4 +16,3 @@ Relocation section '.rela.ifunc' at .*
 Relocation section '.rela.plt' at .*
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
diff --git a/ld/testsuite/ld-ifunc/ifunc-21-i386.d b/ld/testsuite/ld-ifunc/ifunc-21-i386.d
index e609dbe..d61ccd0 100644
--- a/ld/testsuite/ld-ifunc/ifunc-21-i386.d
+++ b/ld/testsuite/ld-ifunc/ifunc-21-i386.d
@@ -5,18 +5,20 @@
 
 .*: +file format .*
 
-#...
-0+8048090 <__start>:
-[ 	]*[a-f0-9]+:	ff 93 0c 00 00 00    	call   \*0xc\(%ebx\)
-[ 	]*[a-f0-9]+:	ff a3 0c 00 00 00    	jmp    \*0xc\(%ebx\)
-[ 	]*[a-f0-9]+:	03 83 0c 00 00 00    	add    0xc\(%ebx\),%eax
-[ 	]*[a-f0-9]+:	8b 83 0c 00 00 00    	mov    0xc\(%ebx\),%eax
-[ 	]*[a-f0-9]+:	85 83 0c 00 00 00    	test   %eax,0xc\(%ebx\)
-[ 	]*[a-f0-9]+:	c7 c0 b5 80 04 08    	mov    \$0x80480b5,%eax
 
-0+80480b4 <foo>:
-[ 	]*[a-f0-9]+:	c3                   	ret    
+Disassembly of section .text:
 
-0+80480b5 <bar>:
-[ 	]*[a-f0-9]+:	c3                   	ret    
+0+804807c <__start>:
+ +[a-f0-9]+:	ff 93 fc ff ff ff    	call   \*-0x4\(%ebx\)
+ +[a-f0-9]+:	ff a3 fc ff ff ff    	jmp    \*-0x4\(%ebx\)
+ +[a-f0-9]+:	03 83 fc ff ff ff    	add    -0x4\(%ebx\),%eax
+ +[a-f0-9]+:	8b 83 fc ff ff ff    	mov    -0x4\(%ebx\),%eax
+ +[a-f0-9]+:	85 83 fc ff ff ff    	test   %eax,-0x4\(%ebx\)
+ +[a-f0-9]+:	c7 c0 a1 80 04 08    	mov    \$0x80480a1,%eax
+
+0+80480a0 <foo>:
+ +[a-f0-9]+:	c3                   	ret    
+
+0+80480a1 <bar>:
+ +[a-f0-9]+:	c3                   	ret    
 #pass
diff --git a/ld/testsuite/ld-ifunc/ifunc-21-x86-64.d b/ld/testsuite/ld-ifunc/ifunc-21-x86-64.d
index e28734e..4e3582d 100644
--- a/ld/testsuite/ld-ifunc/ifunc-21-x86-64.d
+++ b/ld/testsuite/ld-ifunc/ifunc-21-x86-64.d
@@ -5,18 +5,20 @@
 
 .*: +file format .*
 
-#...
-0+4000e0 <__start>:
-[ 	]*[a-f0-9]+:	ff 15 42 00 20 00    	callq  \*0x200042\(%rip\)        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	ff 25 3c 00 20 00    	jmpq   \*0x20003c\(%rip\)        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	48 03 05 35 00 20 00 	add    0x200035\(%rip\),%rax        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	48 8b 05 2e 00 20 00 	mov    0x20002e\(%rip\),%rax        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	48 85 05 27 00 20 00 	test   %rax,0x200027\(%rip\)        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	48 c7 c0 09 01 40 00 	mov    \$0x400109,%rax
 
-0+400108 <foo>:
-[ 	]*[a-f0-9]+:	c3                   	retq   
+Disassembly of section .text:
 
-0+400109 <bar>:
-[ 	]*[a-f0-9]+:	c3                   	retq   
+0+4000c8 <__start>:
+ +[a-f0-9]+:	ff 15 2a 00 20 00    	callq  \*0x20002a\(%rip\)        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	ff 25 24 00 20 00    	jmpq   \*0x200024\(%rip\)        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	48 03 05 1d 00 20 00 	add    0x20001d\(%rip\),%rax        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	48 8b 05 16 00 20 00 	mov    0x200016\(%rip\),%rax        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	48 85 05 0f 00 20 00 	test   %rax,0x20000f\(%rip\)        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	48 c7 c0 f1 00 40 00 	mov    \$0x4000f1,%rax
+
+0+4000f0 <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+4000f1 <bar>:
+ +[a-f0-9]+:	c3                   	retq   
 #pass
diff --git a/ld/testsuite/ld-ifunc/ifunc-22-i386.d b/ld/testsuite/ld-ifunc/ifunc-22-i386.d
index e609dbe..d61ccd0 100644
--- a/ld/testsuite/ld-ifunc/ifunc-22-i386.d
+++ b/ld/testsuite/ld-ifunc/ifunc-22-i386.d
@@ -5,18 +5,20 @@
 
 .*: +file format .*
 
-#...
-0+8048090 <__start>:
-[ 	]*[a-f0-9]+:	ff 93 0c 00 00 00    	call   \*0xc\(%ebx\)
-[ 	]*[a-f0-9]+:	ff a3 0c 00 00 00    	jmp    \*0xc\(%ebx\)
-[ 	]*[a-f0-9]+:	03 83 0c 00 00 00    	add    0xc\(%ebx\),%eax
-[ 	]*[a-f0-9]+:	8b 83 0c 00 00 00    	mov    0xc\(%ebx\),%eax
-[ 	]*[a-f0-9]+:	85 83 0c 00 00 00    	test   %eax,0xc\(%ebx\)
-[ 	]*[a-f0-9]+:	c7 c0 b5 80 04 08    	mov    \$0x80480b5,%eax
 
-0+80480b4 <foo>:
-[ 	]*[a-f0-9]+:	c3                   	ret    
+Disassembly of section .text:
 
-0+80480b5 <bar>:
-[ 	]*[a-f0-9]+:	c3                   	ret    
+0+804807c <__start>:
+ +[a-f0-9]+:	ff 93 fc ff ff ff    	call   \*-0x4\(%ebx\)
+ +[a-f0-9]+:	ff a3 fc ff ff ff    	jmp    \*-0x4\(%ebx\)
+ +[a-f0-9]+:	03 83 fc ff ff ff    	add    -0x4\(%ebx\),%eax
+ +[a-f0-9]+:	8b 83 fc ff ff ff    	mov    -0x4\(%ebx\),%eax
+ +[a-f0-9]+:	85 83 fc ff ff ff    	test   %eax,-0x4\(%ebx\)
+ +[a-f0-9]+:	c7 c0 a1 80 04 08    	mov    \$0x80480a1,%eax
+
+0+80480a0 <foo>:
+ +[a-f0-9]+:	c3                   	ret    
+
+0+80480a1 <bar>:
+ +[a-f0-9]+:	c3                   	ret    
 #pass
diff --git a/ld/testsuite/ld-ifunc/ifunc-22-x86-64.d b/ld/testsuite/ld-ifunc/ifunc-22-x86-64.d
index e28734e..4e3582d 100644
--- a/ld/testsuite/ld-ifunc/ifunc-22-x86-64.d
+++ b/ld/testsuite/ld-ifunc/ifunc-22-x86-64.d
@@ -5,18 +5,20 @@
 
 .*: +file format .*
 
-#...
-0+4000e0 <__start>:
-[ 	]*[a-f0-9]+:	ff 15 42 00 20 00    	callq  \*0x200042\(%rip\)        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	ff 25 3c 00 20 00    	jmpq   \*0x20003c\(%rip\)        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	48 03 05 35 00 20 00 	add    0x200035\(%rip\),%rax        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	48 8b 05 2e 00 20 00 	mov    0x20002e\(%rip\),%rax        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	48 85 05 27 00 20 00 	test   %rax,0x200027\(%rip\)        # 600128 <_GLOBAL_OFFSET_TABLE_\+0x18>
-[ 	]*[a-f0-9]+:	48 c7 c0 09 01 40 00 	mov    \$0x400109,%rax
 
-0+400108 <foo>:
-[ 	]*[a-f0-9]+:	c3                   	retq   
+Disassembly of section .text:
 
-0+400109 <bar>:
-[ 	]*[a-f0-9]+:	c3                   	retq   
+0+4000c8 <__start>:
+ +[a-f0-9]+:	ff 15 2a 00 20 00    	callq  \*0x20002a\(%rip\)        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	ff 25 24 00 20 00    	jmpq   \*0x200024\(%rip\)        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	48 03 05 1d 00 20 00 	add    0x20001d\(%rip\),%rax        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	48 8b 05 16 00 20 00 	mov    0x200016\(%rip\),%rax        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	48 85 05 0f 00 20 00 	test   %rax,0x20000f\(%rip\)        # 6000f8 <bar\+0x200007>
+ +[a-f0-9]+:	48 c7 c0 f1 00 40 00 	mov    \$0x4000f1,%rax
+
+0+4000f0 <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+4000f1 <bar>:
+ +[a-f0-9]+:	c3                   	retq   
 #pass
diff --git a/ld/testsuite/ld-x86-64/no-plt.exp b/ld/testsuite/ld-x86-64/no-plt.exp
index d57ccb5..c10c533 100644
--- a/ld/testsuite/ld-x86-64/no-plt.exp
+++ b/ld/testsuite/ld-x86-64/no-plt.exp
@@ -199,3 +199,70 @@ run_ld_link_exec_tests [] [list \
 	"pass.out" \
     ] \
 ]
+
+# Run-time tests which require working IFUNC support.
+if { [check_ifunc_available] } {
+    run_cc_link_tests [list \
+	[list \
+	    "Build pr20253-2a.o pr20253-2b.o pr20253-2c.o pr20253-2d.o" \
+	    "" \
+	    "-fPIE -O2 -g" \
+	    { pr20253-2a.c pr20253-2b.S pr20253-2c.S pr20253-2d.S } \
+	] \
+	[list \
+	    "Build libpr20253-2a.so" \
+	    "-shared tmpdir/pr20253-2b.o \
+	     tmpdir/pr20253-2c.o tmpdir/pr20253-2d.o" \
+	    "" \
+	    { dummy.s } \
+	    {} \
+	    "libpr20253-2a.so" \
+	] \
+    ]
+
+    run_ld_link_exec_tests [] [list \
+	[list \
+	    "Run pr20253-2a" \
+	    "tmpdir/pr20253-2a.o tmpdir/pr20253-2b.o \
+	     tmpdir/pr20253-2c.o tmpdir/pr20253-2d.o" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-2a" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-2b" \
+	    "--static tmpdir/pr20253-2a.o tmpdir/pr20253-2b.o \
+	    tmpdir/pr20253-2c.o tmpdir/pr20253-2d.o" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-2b" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-2c" \
+	    "-pie tmpdir/pr20253-2a.o tmpdir/pr20253-2b.o \
+	    tmpdir/pr20253-2c.o tmpdir/pr20253-2d.o" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-2c" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-2d" \
+	    "tmpdir/pr20253-2a.o tmpdir/libpr20253-2a.so" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-2d" \
+	    "pass.out" \
+	] \
+	[list \
+	    "Run pr20253-2e" \
+	    "-pie tmpdir/pr20253-2a.o tmpdir/libpr20253-2a.so" \
+	    "" \
+	    { dummy.s } \
+	    "pr20253-2e" \
+	    "pass.out" \
+	] \
+    ]
+}
diff --git a/ld/testsuite/ld-x86-64/pr13082-5a.d b/ld/testsuite/ld-x86-64/pr13082-5a.d
index 191c29e..c132696 100644
--- a/ld/testsuite/ld-x86-64/pr13082-5a.d
+++ b/ld/testsuite/ld-x86-64/pr13082-5a.d
@@ -4,10 +4,7 @@
 #ld: -shared -melf32_x86_64
 #readelf: -r --wide
 
-Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 2 entries:
  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
 [0-9a-f]+ +[0-9a-f]+ +R_X86_64_32 +ifunc\(\)+ +ifunc \+ 0
-
-Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
- Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
-[0-9a-f]+ +[0-9a-f]+ +R_X86_64_JUMP_SLOT +ifunc\(\)+ +ifunc \+ 0
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_GLOB_DAT +ifunc\(\)+ +ifunc \+ 0
diff --git a/ld/testsuite/ld-x86-64/pr13082-5b.d b/ld/testsuite/ld-x86-64/pr13082-5b.d
index 1c5a5e7..18e4ddf 100644
--- a/ld/testsuite/ld-x86-64/pr13082-5b.d
+++ b/ld/testsuite/ld-x86-64/pr13082-5b.d
@@ -4,10 +4,7 @@
 #ld: -pie -melf32_x86_64
 #readelf: -r --wide
 
-Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 2 entries:
  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
 [0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
-
-Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
- Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
 [0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
diff --git a/ld/testsuite/ld-x86-64/pr13082-6a.d b/ld/testsuite/ld-x86-64/pr13082-6a.d
index 9a1a655..50ad9f3 100644
--- a/ld/testsuite/ld-x86-64/pr13082-6a.d
+++ b/ld/testsuite/ld-x86-64/pr13082-6a.d
@@ -4,10 +4,7 @@
 #ld: -shared -melf32_x86_64
 #readelf: -r --wide
 
-Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 2 entries:
  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
 [0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
-
-Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
- Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
 [0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
diff --git a/ld/testsuite/ld-x86-64/pr13082-6b.d b/ld/testsuite/ld-x86-64/pr13082-6b.d
index 792c348..1fb714d 100644
--- a/ld/testsuite/ld-x86-64/pr13082-6b.d
+++ b/ld/testsuite/ld-x86-64/pr13082-6b.d
@@ -4,10 +4,7 @@
 #ld: -pie -melf32_x86_64
 #readelf: -r --wide
 
-Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 2 entries:
  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
 [0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
-
-Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
- Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
 [0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
diff --git a/ld/testsuite/ld-x86-64/pr20253-1.s b/ld/testsuite/ld-x86-64/pr20253-1.s
new file mode 100644
index 0000000..4b9b7a4
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1.s
@@ -0,0 +1,18 @@
+	.text
+	.globl	foo
+	.type	foo, @gnu_indirect_function
+foo:
+	ret
+	.text
+	.type	bar, @gnu_indirect_function
+bar:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	call	*foo@GOTPCREL(%rip)
+	jmp	*bar@GOTPCREL(%rip)
+	movq	$0, bar@GOTPCREL(%rip)
+	cmpq	$0, foo@GOTPCREL(%rip)
+	cmpq	foo@GOTPCREL(%rip), %rcx
+	cmpq	bar@GOTPCREL(%rip), %rcx
diff --git a/ld/testsuite/ld-x86-64/pr20253-1a.d b/ld/testsuite/ld-x86-64/pr20253-1a.d
new file mode 100644
index 0000000..94c7c1d
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1a.d
@@ -0,0 +1,9 @@
+#source: pr20253-1.s
+#as: --64
+#ld: -melf_x86_64
+#readelf: -r --wide
+
+Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 2 entries:
+ +Offset +Info +Type +Sym.* Value +Symbol's Name \+ Addend
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
diff --git a/ld/testsuite/ld-x86-64/pr20253-1b.d b/ld/testsuite/ld-x86-64/pr20253-1b.d
new file mode 100644
index 0000000..247e042
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1b.d
@@ -0,0 +1,25 @@
+#source: pr20253-1.s
+#as: --64
+#ld: -melf_x86_64
+#objdump: -dw
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+0+4000e0 <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+4000e1 <bar>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+4000e2 <_start>:
+ +[a-f0-9]+:	ff 15 28 00 20 00    	callq  \*0x200028\(%rip\)        # 600110 <_start\+0x20002e>
+ +[a-f0-9]+:	ff 25 2a 00 20 00    	jmpq   \*0x20002a\(%rip\)        # 600118 <_start\+0x200036>
+ +[a-f0-9]+:	48 c7 05 1f 00 20 00 00 00 00 00 	movq   \$0x0,0x20001f\(%rip\)        # 600118 <_start\+0x200036>
+ +[a-f0-9]+:	48 83 3d 0f 00 20 00 00 	cmpq   \$0x0,0x20000f\(%rip\)        # 600110 <_start\+0x20002e>
+ +[a-f0-9]+:	48 3b 0d 08 00 20 00 	cmp    0x200008\(%rip\),%rcx        # 600110 <_start\+0x20002e>
+ +[a-f0-9]+:	48 3b 0d 09 00 20 00 	cmp    0x200009\(%rip\),%rcx        # 600118 <_start\+0x200036>
+#pass
diff --git a/ld/testsuite/ld-x86-64/pr20253-1c.d b/ld/testsuite/ld-x86-64/pr20253-1c.d
new file mode 100644
index 0000000..02c4542
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1c.d
@@ -0,0 +1,9 @@
+#source: pr20253-1.s
+#as: --64
+#ld: -pie -melf_x86_64
+#readelf: -r --wide
+
+Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 2 entries:
+ +Offset +Info +Type +Sym.* Value +Symbol's Name \+ Addend
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
diff --git a/ld/testsuite/ld-x86-64/pr20253-1d.d b/ld/testsuite/ld-x86-64/pr20253-1d.d
new file mode 100644
index 0000000..35c04f8
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1d.d
@@ -0,0 +1,25 @@
+#source: pr20253-1.s
+#as: --64
+#ld: -pie -melf_x86_64
+#objdump: -dw
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+0+1c8 <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+1c9 <bar>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+1ca <_start>:
+ +[a-f0-9]+:	ff 15 28 01 20 00    	callq  \*0x200128\(%rip\)        # 2002f8 <_DYNAMIC\+0x100>
+ +[a-f0-9]+:	ff 25 2a 01 20 00    	jmpq   \*0x20012a\(%rip\)        # 200300 <_DYNAMIC\+0x108>
+ +[a-f0-9]+:	48 c7 05 1f 01 20 00 00 00 00 00 	movq   \$0x0,0x20011f\(%rip\)        # 200300 <_DYNAMIC\+0x108>
+ +[a-f0-9]+:	48 83 3d 0f 01 20 00 00 	cmpq   \$0x0,0x20010f\(%rip\)        # 2002f8 <_DYNAMIC\+0x100>
+ +[a-f0-9]+:	48 3b 0d 08 01 20 00 	cmp    0x200108\(%rip\),%rcx        # 2002f8 <_DYNAMIC\+0x100>
+ +[a-f0-9]+:	48 3b 0d 09 01 20 00 	cmp    0x200109\(%rip\),%rcx        # 200300 <_DYNAMIC\+0x108>
+#pass
diff --git a/ld/testsuite/ld-x86-64/pr20253-1e.d b/ld/testsuite/ld-x86-64/pr20253-1e.d
new file mode 100644
index 0000000..722fdf7
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1e.d
@@ -0,0 +1,9 @@
+#source: pr20253-1.s
+#as: --64
+#ld: -shared -melf_x86_64
+#readelf: -r --wide
+
+Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 2 entries:
+ +Offset +Info +Type +Sym.* Value +Symbol's Name \+ Addend
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_GLOB_DAT +foo\(\)+ +foo \+ 0
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
diff --git a/ld/testsuite/ld-x86-64/pr20253-1f.d b/ld/testsuite/ld-x86-64/pr20253-1f.d
new file mode 100644
index 0000000..d84b60e
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1f.d
@@ -0,0 +1,25 @@
+#source: pr20253-1.s
+#as: --64
+#ld: -shared -melf_x86_64
+#objdump: -dw
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+0+1f8 <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+1f9 <bar>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+1fa <_start>:
+ +[a-f0-9]+:	ff 15 08 01 20 00    	callq  \*0x200108\(%rip\)        # 200308 <_DYNAMIC\+0xe0>
+ +[a-f0-9]+:	ff 25 0a 01 20 00    	jmpq   \*0x20010a\(%rip\)        # 200310 <_DYNAMIC\+0xe8>
+ +[a-f0-9]+:	48 c7 05 ff 00 20 00 00 00 00 00 	movq   \$0x0,0x2000ff\(%rip\)        # 200310 <_DYNAMIC\+0xe8>
+ +[a-f0-9]+:	48 83 3d ef 00 20 00 00 	cmpq   \$0x0,0x2000ef\(%rip\)        # 200308 <_DYNAMIC\+0xe0>
+ +[a-f0-9]+:	48 3b 0d e8 00 20 00 	cmp    0x2000e8\(%rip\),%rcx        # 200308 <_DYNAMIC\+0xe0>
+ +[a-f0-9]+:	48 3b 0d e9 00 20 00 	cmp    0x2000e9\(%rip\),%rcx        # 200310 <_DYNAMIC\+0xe8>
+#pass
diff --git a/ld/testsuite/ld-x86-64/pr20253-1g.d b/ld/testsuite/ld-x86-64/pr20253-1g.d
new file mode 100644
index 0000000..671a980
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1g.d
@@ -0,0 +1,9 @@
+#source: pr20253-1.s
+#as: --x32
+#ld: -melf32_x86_64
+#readelf: -r --wide
+
+Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 2 entries:
+ +Offset +Info +Type +Sym.* Value +Symbol's Name \+ Addend
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
diff --git a/ld/testsuite/ld-x86-64/pr20253-1h.d b/ld/testsuite/ld-x86-64/pr20253-1h.d
new file mode 100644
index 0000000..77ff100
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1h.d
@@ -0,0 +1,25 @@
+#source: pr20253-1.s
+#as: --x32
+#ld: -melf32_x86_64
+#objdump: -dw
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+0+40008c <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+40008d <bar>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+40008e <_start>:
+ +[a-f0-9]+:	ff 15 28 00 20 00    	callq  \*0x200028\(%rip\)        # 6000bc <_start\+0x20002e>
+ +[a-f0-9]+:	ff 25 2a 00 20 00    	jmpq   \*0x20002a\(%rip\)        # 6000c4 <_start\+0x200036>
+ +[a-f0-9]+:	48 c7 05 1f 00 20 00 00 00 00 00 	movq   \$0x0,0x20001f\(%rip\)        # 6000c4 <_start\+0x200036>
+ +[a-f0-9]+:	48 83 3d 0f 00 20 00 00 	cmpq   \$0x0,0x20000f\(%rip\)        # 6000bc <_start\+0x20002e>
+ +[a-f0-9]+:	48 3b 0d 08 00 20 00 	cmp    0x200008\(%rip\),%rcx        # 6000bc <_start\+0x20002e>
+ +[a-f0-9]+:	48 3b 0d 09 00 20 00 	cmp    0x200009\(%rip\),%rcx        # 6000c4 <_start\+0x200036>
+#pass
diff --git a/ld/testsuite/ld-x86-64/pr20253-1i.d b/ld/testsuite/ld-x86-64/pr20253-1i.d
new file mode 100644
index 0000000..bf42ed1
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1i.d
@@ -0,0 +1,9 @@
+#source: pr20253-1.s
+#as: --x32
+#ld: -pie -melf32_x86_64
+#readelf: -r --wide
+
+Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 2 entries:
+ +Offset +Info +Type +Sym.* Value +Symbol's Name \+ Addend
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
diff --git a/ld/testsuite/ld-x86-64/pr20253-1j.d b/ld/testsuite/ld-x86-64/pr20253-1j.d
new file mode 100644
index 0000000..6f5d666
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1j.d
@@ -0,0 +1,25 @@
+#source: pr20253-1.s
+#as: --x32
+#ld: -pie -melf32_x86_64
+#objdump: -dw
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+0+120 <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+121 <bar>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+122 <_start>:
+ +[a-f0-9]+:	ff 15 a8 00 20 00    	callq  \*0x2000a8\(%rip\)        # 2001d0 <_DYNAMIC\+0x80>
+ +[a-f0-9]+:	ff 25 aa 00 20 00    	jmpq   \*0x2000aa\(%rip\)        # 2001d8 <_DYNAMIC\+0x88>
+ +[a-f0-9]+:	48 c7 05 9f 00 20 00 00 00 00 00 	movq   \$0x0,0x20009f\(%rip\)        # 2001d8 <_DYNAMIC\+0x88>
+ +[a-f0-9]+:	48 83 3d 8f 00 20 00 00 	cmpq   \$0x0,0x20008f\(%rip\)        # 2001d0 <_DYNAMIC\+0x80>
+ +[a-f0-9]+:	48 3b 0d 88 00 20 00 	cmp    0x200088\(%rip\),%rcx        # 2001d0 <_DYNAMIC\+0x80>
+ +[a-f0-9]+:	48 3b 0d 89 00 20 00 	cmp    0x200089\(%rip\),%rcx        # 2001d8 <_DYNAMIC\+0x88>
+#pass
diff --git a/ld/testsuite/ld-x86-64/pr20253-1k.d b/ld/testsuite/ld-x86-64/pr20253-1k.d
new file mode 100644
index 0000000..1d55770
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1k.d
@@ -0,0 +1,9 @@
+#source: pr20253-1.s
+#as: --x32
+#ld: -shared -melf32_x86_64
+#readelf: -r --wide
+
+Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 2 entries:
+ +Offset +Info +Type +Sym.* Value +Symbol's Name \+ Addend
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_GLOB_DAT +foo\(\)+ +foo \+ 0
+[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
diff --git a/ld/testsuite/ld-x86-64/pr20253-1l.d b/ld/testsuite/ld-x86-64/pr20253-1l.d
new file mode 100644
index 0000000..0276558
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-1l.d
@@ -0,0 +1,25 @@
+#source: pr20253-1.s
+#as: --x32
+#ld: -shared -melf32_x86_64
+#objdump: -dw
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+0+158 <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+159 <bar>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+15a <_start>:
+ +[a-f0-9]+:	ff 15 98 00 20 00    	callq  \*0x200098\(%rip\)        # 2001f8 <_DYNAMIC\+0x70>
+ +[a-f0-9]+:	ff 25 9a 00 20 00    	jmpq   \*0x20009a\(%rip\)        # 200200 <_DYNAMIC\+0x78>
+ +[a-f0-9]+:	48 c7 05 8f 00 20 00 00 00 00 00 	movq   \$0x0,0x20008f\(%rip\)        # 200200 <_DYNAMIC\+0x78>
+ +[a-f0-9]+:	48 83 3d 7f 00 20 00 00 	cmpq   \$0x0,0x20007f\(%rip\)        # 2001f8 <_DYNAMIC\+0x70>
+ +[a-f0-9]+:	48 3b 0d 78 00 20 00 	cmp    0x200078\(%rip\),%rcx        # 2001f8 <_DYNAMIC\+0x70>
+ +[a-f0-9]+:	48 3b 0d 79 00 20 00 	cmp    0x200079\(%rip\),%rcx        # 200200 <_DYNAMIC\+0x78>
+#pass
diff --git a/ld/testsuite/ld-x86-64/pr20253-2a.c b/ld/testsuite/ld-x86-64/pr20253-2a.c
new file mode 100644
index 0000000..370275a
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-2a.c
@@ -0,0 +1,8 @@
+extern void check (void);
+
+int
+main ()
+{
+  check ();
+  return 0;
+}
diff --git a/ld/testsuite/ld-x86-64/pr20253-2b.S b/ld/testsuite/ld-x86-64/pr20253-2b.S
new file mode 100644
index 0000000..6f94ebe
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-2b.S
@@ -0,0 +1,42 @@
+	.section	.rodata.str1.1,"aMS",@progbits,1
+.LC0:
+	.string	"PASS"
+	.text
+	.globl	check
+	.type	check, @function
+check:
+	subq	$8, %rsp
+	call	*get_func1@GOTPCREL(%rip)
+	cmpq	func1@GOTPCREL(%rip), %rax
+	jne	.L3
+	movq	func1_p@GOTPCREL(%rip), %rdx
+#ifdef __LP64__
+	cmpq	%rax, (%rdx)
+#else
+	cmpl	%eax, (%rdx)
+#endif
+	jne	.L3
+	call	*func1@GOTPCREL(%rip)
+	cmpl	$1, %eax
+	jne	.L3
+	call	*call_func1@GOTPCREL(%rip)
+	cmpl	$1, %eax
+	jne	.L3
+	call	*get_func2@GOTPCREL(%rip)
+	movq	func2_p@GOTPCREL(%rip), %rdx
+#ifdef __LP64__
+	cmpq	%rax, (%rdx)
+#else
+	cmpl	%eax, (%rdx)
+#endif
+	jne	.L3
+	call	*call_func2@GOTPCREL(%rip)
+	cmpl	$2, %eax
+	jne	.L3
+	leaq	.LC0(%rip), %rdi
+	addq	$8, %rsp
+	jmp	*puts@GOTPCREL(%rip)
+.L3:
+	call	*abort@GOTPCREL(%rip)
+	.size	check, .-check
+	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-x86-64/pr20253-2c.S b/ld/testsuite/ld-x86-64/pr20253-2c.S
new file mode 100644
index 0000000..6d3abf0
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-2c.S
@@ -0,0 +1,25 @@
+	.text
+	.globl	get_func1
+	.type	get_func1, @function
+get_func1:
+	movq	func1@GOTPCREL(%rip), %rax
+	ret
+	.size	get_func1, .-get_func1
+	.globl	call_func1
+	.type	call_func1, @function
+call_func1:
+	jmp	*func1@GOTPCREL(%rip)
+	.size	call_func1, .-call_func1
+	.globl	func1_p
+	.section	.data.rel,"aw",@progbits
+#ifdef __LP64__
+	.align 8
+	.size	func1_p, 8
+#else
+	.align 4
+	.size	func1_p, 4
+#endif
+	.type	func1_p, @object
+func1_p:
+	.dc.a	func1
+	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-x86-64/pr20253-2d.S b/ld/testsuite/ld-x86-64/pr20253-2d.S
new file mode 100644
index 0000000..10aee94
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/pr20253-2d.S
@@ -0,0 +1,57 @@
+	.text
+	.type	implementation1, @function
+implementation1:
+	movl	$1, %eax
+	ret
+	.size	implementation1, .-implementation1
+	.type	implementation2, @function
+implementation2:
+	movl	$2, %eax
+	ret
+	.size	implementation2, .-implementation2
+	.type	resolver2, @function
+resolver2:
+	leaq	implementation2(%rip), %rax
+	ret
+	.size	resolver2, .-resolver2
+	.type	func2, @gnu_indirect_function
+	.set	func2,resolver2
+	.type	resolver1, @function
+resolver1:
+	leaq	implementation1(%rip), %rax
+	ret
+	.size	resolver1, .-resolver1
+	.globl	func1
+	.type	func1, @gnu_indirect_function
+	.set	func1,resolver1
+	.globl	get_func2
+	.type	get_func2, @function
+get_func2:
+	movq	func2@GOTPCREL(%rip), %rax
+	ret
+	.size	get_func2, .-get_func2
+	.globl	call_func2
+	.type	call_func2, @function
+call_func2:
+	subq	$8, %rsp
+	call	*get_func2@GOTPCREL(%rip)
+	cmpq	func2@GOTPCREL(%rip), %rax
+	jne	.L10
+	addq	$8, %rsp
+	jmp	*func2@GOTPCREL(%rip)
+.L10:
+	call	*abort@GOTPCREL(%rip)
+	.size	call_func2, .-call_func2
+	.globl	func2_p
+	.section	.data.rel,"aw",@progbits
+#ifdef __LP64__
+	.align 8
+	.size	func2_p, 8
+#else
+	.align 4
+	.size	func2_p, 4
+#endif
+	.type	func2_p, @object
+func2_p:
+	.dc.a	func2
+	.section	.note.GNU-stack,"",@progbits
diff --git a/ld/testsuite/ld-x86-64/x86-64.exp b/ld/testsuite/ld-x86-64/x86-64.exp
index 7fd953b..6f8e58b 100644
--- a/ld/testsuite/ld-x86-64/x86-64.exp
+++ b/ld/testsuite/ld-x86-64/x86-64.exp
@@ -503,6 +503,18 @@ run_dump_test "pr19609-7d"
 run_dump_test "pr19939a"
 run_dump_test "pr19939b"
 run_dump_test "pr19719"
+run_dump_test "pr20253-1a"
+run_dump_test "pr20253-1b"
+run_dump_test "pr20253-1c"
+run_dump_test "pr20253-1d"
+run_dump_test "pr20253-1e"
+run_dump_test "pr20253-1f"
+run_dump_test "pr20253-1g"
+run_dump_test "pr20253-1h"
+run_dump_test "pr20253-1i"
+run_dump_test "pr20253-1j"
+run_dump_test "pr20253-1k"
+run_dump_test "pr20253-1l"
 
 proc undefined_weak {cflags ldflags} {
     set testname "Undefined weak symbol"
-- 
2.5.5

