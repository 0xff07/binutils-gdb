From cecb969d47e0df46e03be254eb339c0afdef45f3 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Thu, 27 Apr 2017 09:01:09 -0700
Subject: [PATCH 2/2] Add elf_x86_64_lazy_plt_layout and
 elf_x86_64_non_lazy_plt_layout

Set plt.has_plt0 to 0 for -z now
Use non_lazy_plt for -z now
---
 bfd/elf64-x86-64.c                               | 724 ++++++++++++++---------
 ld/testsuite/ld-ifunc/ifunc-16-x86-64-now.d      |  14 +
 ld/testsuite/ld-ifunc/ifunc-2-local-x86-64-now.d |  26 +
 ld/testsuite/ld-ifunc/ifunc-2-x86-64-now.d       |  26 +
 ld/testsuite/ld-ifunc/pr17154-x86-64-now.d       |  40 ++
 ld/testsuite/ld-x86-64/plt2.dd                   |  28 +
 ld/testsuite/ld-x86-64/plt2.rd                   |   9 +
 ld/testsuite/ld-x86-64/plt2.s                    |   7 +
 ld/testsuite/ld-x86-64/x86-64.exp                |  12 +
 9 files changed, 601 insertions(+), 285 deletions(-)
 create mode 100644 ld/testsuite/ld-ifunc/ifunc-16-x86-64-now.d
 create mode 100644 ld/testsuite/ld-ifunc/ifunc-2-local-x86-64-now.d
 create mode 100644 ld/testsuite/ld-ifunc/ifunc-2-x86-64-now.d
 create mode 100644 ld/testsuite/ld-ifunc/pr17154-x86-64-now.d
 create mode 100644 ld/testsuite/ld-x86-64/plt2.dd
 create mode 100644 ld/testsuite/ld-x86-64/plt2.rd
 create mode 100644 ld/testsuite/ld-x86-64/plt2.s

diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index 7c455f2..db0b6aa 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -544,23 +544,29 @@ elf_x86_64_write_core_note (bfd *abfd, char *buf, int *bufsiz,
 
 #define GOT_ENTRY_SIZE 8
 
-/* The size in bytes of an entry in the procedure linkage table.  */
+/* The size in bytes of an entry in the lazy procedure linkage table.  */
 
-#define PLT_ENTRY_SIZE 16
+#define LAZY_PLT_ENTRY_SIZE 16
 
-/* The first entry in a procedure linkage table looks like this.  See the
-   SVR4 ABI i386 supplement and the x86-64 ABI to see how this works.  */
+/* The size in bytes of an entry in the non-lazy procedure linkage
+   table.  */
 
-static const bfd_byte elf_x86_64_plt0_entry[PLT_ENTRY_SIZE] =
+#define NON_LAZY_PLT_ENTRY_SIZE 8
+
+/* The first entry in a lazy procedure linkage table looks like this.
+   See the SVR4 ABI i386 supplement and the x86-64 ABI to see how this
+   works.  */
+
+static const bfd_byte elf_x86_64_lazy_plt0_entry[LAZY_PLT_ENTRY_SIZE] =
 {
   0xff, 0x35, 8, 0, 0, 0,	/* pushq GOT+8(%rip)  */
   0xff, 0x25, 16, 0, 0, 0,	/* jmpq *GOT+16(%rip) */
   0x0f, 0x1f, 0x40, 0x00	/* nopl 0(%rax)       */
 };
 
-/* Subsequent entries in a procedure linkage table look like this.  */
+/* Subsequent entries in a lazy procedure linkage table look like this.  */
 
-static const bfd_byte elf_x86_64_plt_entry[PLT_ENTRY_SIZE] =
+static const bfd_byte elf_x86_64_lazy_plt_entry[LAZY_PLT_ENTRY_SIZE] =
 {
   0xff, 0x25,	/* jmpq *name@GOTPC(%rip) */
   0, 0, 0, 0,	/* replaced with offset to this symbol in .got.	 */
@@ -570,59 +576,48 @@ static const bfd_byte elf_x86_64_plt_entry[PLT_ENTRY_SIZE] =
   0, 0, 0, 0	/* replaced with offset to start of .plt0.  */
 };
 
-/* The first entry in a procedure linkage table with BND relocations
+/* The first entry in a lazy procedure linkage table with BND prefix
    like this.  */
 
-static const bfd_byte elf_x86_64_bnd_plt0_entry[PLT_ENTRY_SIZE] =
+static const bfd_byte elf_x86_64_lazy_bnd_plt0_entry[LAZY_PLT_ENTRY_SIZE] =
 {
   0xff, 0x35, 8, 0, 0, 0,         /* pushq GOT+8(%rip)        */
   0xf2, 0xff, 0x25, 16, 0, 0, 0,  /* bnd jmpq *GOT+16(%rip)   */
   0x0f, 0x1f, 0                   /* nopl (%rax)              */
 };
 
-/* Subsequent entries for legacy branches in a procedure linkage table
-   with BND relocations look like this.  */
-
-static const bfd_byte elf_x86_64_legacy_plt_entry[PLT_ENTRY_SIZE] =
-{
-  0x68, 0, 0, 0, 0,             /* pushq immediate            */
-  0xe9, 0, 0, 0, 0,             /* jmpq relative              */
-  0x66, 0x0f, 0x1f, 0x44, 0, 0  /* nopw (%rax,%rax,1)         */
-};
-
-/* Subsequent entries for branches with BND prefx in a procedure linkage
-   table with BND relocations look like this.  */
+/* Subsequent entries for branches with BND prefx in a lazy procedure
+   linkage table look like this.  */
 
-static const bfd_byte elf_x86_64_bnd_plt_entry[PLT_ENTRY_SIZE] =
+static const bfd_byte elf_x86_64_lazy_bnd_plt_entry[LAZY_PLT_ENTRY_SIZE] =
 {
   0x68, 0, 0, 0, 0,             /* pushq immediate            */
   0xf2, 0xe9, 0, 0, 0, 0,       /* bnd jmpq relative          */
   0x0f, 0x1f, 0x44, 0, 0        /* nopl 0(%rax,%rax,1)        */
 };
 
-/* Entries for legacy branches in the second procedure linkage table
-   look like this.  */
+/* Entries in the non-lazey procedure linkage table look like this.  */
 
-static const bfd_byte elf_x86_64_legacy_plt2_entry[8] =
+static const bfd_byte elf_x86_64_non_lazy_plt_entry[NON_LAZY_PLT_ENTRY_SIZE] =
 {
-  0xff, 0x25,                    /* jmpq *name@GOTPC(%rip)      */
-  0, 0, 0, 0,  /* replaced with offset to this symbol in .got.  */
-  0x66, 0x90                     /* xchg %ax,%ax                */
+  0xff, 0x25,        /* jmpq *name@GOTPC(%rip)                        */
+  0, 0, 0, 0,        /* replaced with offset to this symbol in .got.  */
+  0x66, 0x90         /* xchg %ax,%ax                                  */
 };
 
-/* Entries for branches with BND prefix in the second procedure linkage
-   table look like this.  */
+/* Entries for branches with BND prefix in the non-lazey procedure
+   linkage table look like this.  */
 
-static const bfd_byte elf_x86_64_bnd_plt2_entry[8] =
+static const bfd_byte elf_x86_64_non_lazy_bnd_plt_entry[NON_LAZY_PLT_ENTRY_SIZE] =
 {
-  0xf2, 0xff, 0x25,              /* bnd jmpq *name@GOTPC(%rip)  */
-  0, 0, 0, 0,  /* replaced with offset to this symbol in .got.  */
-  0x90                           /* nop                         */
+  0xf2, 0xff, 0x25,  /* bnd jmpq *name@GOTPC(%rip)                    */
+  0, 0, 0, 0,        /* replaced with offset to this symbol in .got.  */
+  0x90               /* nop                                           */
 };
 
-/* .eh_frame covering the .plt section.  */
+/* .eh_frame covering the lazy .plt section.  */
 
-static const bfd_byte elf_x86_64_eh_frame_plt[] =
+static const bfd_byte elf_x86_64_eh_frame_lazy_plt[] =
 {
 #define PLT_CIE_LENGTH		20
 #define PLT_FDE_LENGTH		36
@@ -659,9 +654,9 @@ static const bfd_byte elf_x86_64_eh_frame_plt[] =
   DW_CFA_nop, DW_CFA_nop, DW_CFA_nop, DW_CFA_nop
 };
 
-/* .eh_frame covering the BND .plt section.  */
+/* .eh_frame covering the lazy BND .plt section.  */
 
-static const bfd_byte elf_x86_64_eh_frame_bnd_plt[] =
+static const bfd_byte elf_x86_64_eh_frame_lazy_bnd_plt[] =
 {
   PLT_CIE_LENGTH, 0, 0, 0,	/* CIE length */
   0, 0, 0, 0,			/* CIE ID */
@@ -694,9 +689,9 @@ static const bfd_byte elf_x86_64_eh_frame_bnd_plt[] =
   DW_CFA_nop, DW_CFA_nop, DW_CFA_nop, DW_CFA_nop
 };
 
-/* .eh_frame covering the .plt.got section.  */
+/* .eh_frame covering the non-lazy .plt section.  */
 
-static const bfd_byte elf_x86_64_eh_frame_plt_got[] =
+static const bfd_byte elf_x86_64_eh_frame_non_lazy_plt[] =
 {
 #define PLT_GOT_FDE_LENGTH		20
   PLT_CIE_LENGTH, 0, 0, 0,	/* CIE length */
@@ -714,16 +709,14 @@ static const bfd_byte elf_x86_64_eh_frame_plt_got[] =
 
   PLT_GOT_FDE_LENGTH, 0, 0, 0,	/* FDE length */
   PLT_CIE_LENGTH + 8, 0, 0, 0,	/* CIE pointer */
-  0, 0, 0, 0,			/* the start of .plt.got goes here */
-  0, 0, 0, 0,			/* .plt.got size goes here */
+  0, 0, 0, 0,			/* the start of non-lazy .plt goes here */
+  0, 0, 0, 0,			/* non-lazy .plt size goes here */
   0,				/* Augmentation size */
   DW_CFA_nop, DW_CFA_nop, DW_CFA_nop, DW_CFA_nop,
   DW_CFA_nop, DW_CFA_nop, DW_CFA_nop
 };
 
-/* Architecture-specific backend data for x86-64.  */
-
-struct elf_x86_64_backend_data
+struct elf_x86_64_lazy_plt_layout
 {
   /* Templates for the initial PLT entry and for subsequent entries.  */
   const bfd_byte *plt0_entry;
@@ -752,13 +745,58 @@ struct elf_x86_64_backend_data
   /* Offset into plt_entry where the initial value of the GOT entry points.  */
   unsigned int plt_lazy_offset;
 
+  /* .eh_frame covering the lazy .plt section.  */
+  const bfd_byte *eh_frame_plt;
+  unsigned int eh_frame_plt_size;
+};
+
+struct elf_x86_64_non_lazy_plt_layout
+{
+  /* Template for the lazy PLT entries.  */
+  const bfd_byte *plt_entry;
+  unsigned int plt_entry_size;          /* Size of each PLT entry.  */
+
+  /* Offsets into plt_entry that are to be replaced with...  */
+  unsigned int plt_got_offset;    /* ... address of this symbol in .got. */
+
+  /* Length of the PC-relative instruction containing plt_got_offset.  */
+  unsigned int plt_got_insn_size;
+
+  /* .eh_frame covering the non-lazy .plt section.  */
+  const bfd_byte *eh_frame_plt;
+  unsigned int eh_frame_plt_size;
+};
+
+struct elf_x86_64_plt_layout
+{
+  /* Template for the PLT entries.  */
+  const bfd_byte *plt_entry;
+  unsigned int plt_entry_size;          /* Size of each PLT entry.  */
+
+  /* 1 has PLT0.  */
+   unsigned int has_plt0;
+
+  /* Offsets into plt_entry that are to be replaced with...  */
+  unsigned int plt_got_offset;    /* ... address of this symbol in .got. */
+
+  /* Length of the PC-relative instruction containing plt_got_offset.  */
+  unsigned int plt_got_insn_size;
+
   /* .eh_frame covering the .plt section.  */
   const bfd_byte *eh_frame_plt;
   unsigned int eh_frame_plt_size;
+};
+
+/* Architecture-specific backend data for x86-64.  */
 
-  /* .eh_frame covering the .plt.got section.  */
-  const bfd_byte *eh_frame_plt_got;
-  unsigned int eh_frame_plt_got_size;
+struct elf_x86_64_backend_data
+{
+  /* Target system.  */
+  enum
+    {
+      is_normal,
+      is_nacl
+    } os;
 };
 
 #define get_elf_x86_64_arch_data(bed) \
@@ -767,15 +805,12 @@ struct elf_x86_64_backend_data
 #define get_elf_x86_64_backend_data(abfd) \
   get_elf_x86_64_arch_data (get_elf_backend_data (abfd))
 
-#define GET_PLT_ENTRY_SIZE(abfd) \
-  get_elf_x86_64_backend_data (abfd)->plt_entry_size
-
 /* These are the standard parameters.  */
-static const struct elf_x86_64_backend_data elf_x86_64_arch_bed =
+static const struct elf_x86_64_lazy_plt_layout elf_x86_64_lazy_plt =
   {
-    elf_x86_64_plt0_entry,              /* plt0_entry */
-    elf_x86_64_plt_entry,               /* plt_entry */
-    sizeof (elf_x86_64_plt_entry),      /* plt_entry_size */
+    elf_x86_64_lazy_plt0_entry,         /* plt0_entry */
+    elf_x86_64_lazy_plt_entry,          /* plt_entry */
+    LAZY_PLT_ENTRY_SIZE,                /* plt_entry_size */
     2,                                  /* plt0_got1_offset */
     8,                                  /* plt0_got2_offset */
     12,                                 /* plt0_got2_insn_end */
@@ -783,19 +818,27 @@ static const struct elf_x86_64_backend_data elf_x86_64_arch_bed =
     7,                                  /* plt_reloc_offset */
     12,                                 /* plt_plt_offset */
     6,                                  /* plt_got_insn_size */
-    PLT_ENTRY_SIZE,                     /* plt_plt_insn_end */
+    LAZY_PLT_ENTRY_SIZE,                /* plt_plt_insn_end */
     6,                                  /* plt_lazy_offset */
-    elf_x86_64_eh_frame_plt,            /* eh_frame_plt */
-    sizeof (elf_x86_64_eh_frame_plt),   /* eh_frame_plt_size */
-    elf_x86_64_eh_frame_plt_got,        /* eh_frame_plt_got */
-    sizeof (elf_x86_64_eh_frame_plt_got), /* eh_frame_plt_got_size */
+    elf_x86_64_eh_frame_lazy_plt,       /* eh_frame_plt */
+    sizeof (elf_x86_64_eh_frame_lazy_plt) /* eh_frame_plt_size */
   };
 
-static const struct elf_x86_64_backend_data elf_x86_64_bnd_arch_bed =
+static const struct elf_x86_64_non_lazy_plt_layout elf_x86_64_non_lazy_plt =
   {
-    elf_x86_64_bnd_plt0_entry,          /* plt0_entry */
-    elf_x86_64_bnd_plt_entry,           /* plt_entry */
-    sizeof (elf_x86_64_bnd_plt_entry),  /* plt_entry_size */
+    elf_x86_64_non_lazy_plt_entry,      /* plt_entry */
+    NON_LAZY_PLT_ENTRY_SIZE,            /* plt_entry_size */
+    2,                                  /* plt_got_offset */
+    6,                                  /* plt_got_insn_size */
+    elf_x86_64_eh_frame_non_lazy_plt,   /* eh_frame_plt */
+    sizeof (elf_x86_64_eh_frame_non_lazy_plt) /* eh_frame_plt_size */
+  };
+
+static const struct elf_x86_64_lazy_plt_layout elf_x86_64_lazy_bnd_plt =
+  {
+    elf_x86_64_lazy_bnd_plt0_entry,     /* plt0_entry */
+    elf_x86_64_lazy_bnd_plt_entry,      /* plt_entry */
+    LAZY_PLT_ENTRY_SIZE,                /* plt_entry_size */
     2,                                  /* plt0_got1_offset */
     1+8,                                /* plt0_got2_offset */
     1+12,                               /* plt0_got2_insn_end */
@@ -805,10 +848,23 @@ static const struct elf_x86_64_backend_data elf_x86_64_bnd_arch_bed =
     1+6,                                /* plt_got_insn_size */
     11,                                 /* plt_plt_insn_end */
     0,                                  /* plt_lazy_offset */
-    elf_x86_64_eh_frame_bnd_plt,        /* eh_frame_plt */
-    sizeof (elf_x86_64_eh_frame_bnd_plt), /* eh_frame_plt_size */
-    elf_x86_64_eh_frame_plt_got,        /* eh_frame_plt_got */
-    sizeof (elf_x86_64_eh_frame_plt_got), /* eh_frame_plt_got_size */
+    elf_x86_64_eh_frame_lazy_bnd_plt,   /* eh_frame_plt */
+    sizeof (elf_x86_64_eh_frame_lazy_bnd_plt) /* eh_frame_plt_size */
+  };
+
+static const struct elf_x86_64_non_lazy_plt_layout elf_x86_64_non_lazy_bnd_plt =
+  {
+    elf_x86_64_non_lazy_bnd_plt_entry,  /* plt_entry */
+    NON_LAZY_PLT_ENTRY_SIZE,            /* plt_entry_size */
+    1+2,                                /* plt_got_offset */
+    1+6,                                /* plt_got_insn_size */
+    elf_x86_64_eh_frame_non_lazy_plt,   /* eh_frame_plt */
+    sizeof (elf_x86_64_eh_frame_non_lazy_plt) /* eh_frame_plt_size */
+  };
+
+static const struct elf_x86_64_backend_data elf_x86_64_arch_bed =
+  {
+    is_normal                            /* os */
   };
 
 #define	elf_backend_arch_data	&elf_x86_64_arch_bed
@@ -938,6 +994,15 @@ struct elf_x86_64_link_hash_table
   asection *plt_got;
   asection *plt_got_eh_frame;
 
+  /* Parameters describing PLT generation, lazy or non-lazy.  */
+  struct elf_x86_64_plt_layout plt;
+
+  /* Parameters describing lazy PLT generation.  */
+  const struct elf_x86_64_lazy_plt_layout *lazy_plt;
+
+  /* Parameters describing non-lazy PLT generation.  */
+  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_plt;
+
   union
   {
     bfd_signed_vma refcount;
@@ -1207,25 +1272,18 @@ elf_x86_64_create_dynamic_sections (bfd *dynobj,
 			   | SEC_LOAD
 			   | SEC_READONLY);
 
+      /* Don't align PLT sections here since link_setup_gnu_properties
+	 will align PLT sections.  */
+
       if (htab->plt_got == NULL
-	  && get_elf_x86_64_backend_data (dynobj) == &elf_x86_64_arch_bed)
+	  && get_elf_x86_64_backend_data (dynobj)->os == is_normal)
 	{
 	  /* Create the GOT procedure linkage table.  */
-	  unsigned int plt_got_align;
-
-	  BFD_ASSERT (sizeof (elf_x86_64_legacy_plt2_entry) == 8
-		      && (sizeof (elf_x86_64_bnd_plt2_entry)
-			  == sizeof (elf_x86_64_legacy_plt2_entry)));
-	  plt_got_align = 3;
-
 	  htab->plt_got
 	    = bfd_make_section_anyway_with_flags (dynobj,
 						  ".plt.got",
 						  pltflags);
-	  if (htab->plt_got == NULL
-	      || !bfd_set_section_alignment (dynobj,
-					     htab->plt_got,
-					     plt_got_align))
+	  if (htab->plt_got == NULL)
 	    return FALSE;
 	}
 
@@ -1233,20 +1291,15 @@ elf_x86_64_create_dynamic_sections (bfd *dynobj,
 	 64-bit mode.  */
       if (ABI_64_P (dynobj)
 	  && info->bndplt
-	  && get_elf_x86_64_backend_data (dynobj) == &elf_x86_64_arch_bed
+	  && get_elf_x86_64_backend_data (dynobj)->os == is_normal
 	  && htab->plt_bnd == NULL)
 	{
 	  /* Create the second PLT for Intel MPX support.  */
-	  BFD_ASSERT (sizeof (elf_x86_64_bnd_plt2_entry) == 8
-		      && (sizeof (elf_x86_64_bnd_plt2_entry)
-			  == sizeof (elf_x86_64_legacy_plt2_entry)));
-
 	  htab->plt_bnd
 	    = bfd_make_section_anyway_with_flags (dynobj,
 						  ".plt.bnd",
 						  pltflags);
-	  if (htab->plt_bnd == NULL
-	      || !bfd_set_section_alignment (dynobj, htab->plt_bnd, 3))
+	  if (htab->plt_bnd == NULL)
 	    return FALSE;
 	}
 
@@ -2413,33 +2466,6 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 
       if (h != NULL)
 	{
-	  switch (r_type)
-	    {
-	    default:
-	      break;
-
-	    case R_X86_64_PC32_BND:
-	    case R_X86_64_PLT32_BND:
-	    case R_X86_64_PC32:
-	    case R_X86_64_PLT32:
-	    case R_X86_64_32:
-	    case R_X86_64_64:
-	    case R_X86_64_32S:
-	    case R_X86_64_PC64:
-	    case R_X86_64_GOTPCREL:
-	    case R_X86_64_GOTPCRELX:
-	    case R_X86_64_REX_GOTPCRELX:
-	    case R_X86_64_GOTPCREL64:
-	      if (htab->elf.dynobj == NULL)
-		htab->elf.dynobj = abfd;
-	      /* Create the ifunc sections for static executables.  */
-	      if (h->type == STT_GNU_IFUNC
-		  && !_bfd_elf_create_ifunc_sections (htab->elf.dynobj,
-						      info))
-		goto error_return;
-	      break;
-	    }
-
 	  /* It is referenced by a non-shared object. */
 	  h->ref_regular = 1;
 	  h->root.non_ir_ref = 1;
@@ -2578,8 +2604,6 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	    eh->has_got_reloc = 1;
 	  if (htab->elf.sgot == NULL)
 	    {
-	      if (htab->elf.dynobj == NULL)
-		htab->elf.dynobj = abfd;
 	      if (!_bfd_elf_create_got_section (htab->elf.dynobj,
 						info))
 		goto error_return;
@@ -2748,9 +2772,6 @@ do_size:
 		 this reloc.  */
 	      if (sreloc == NULL)
 		{
-		  if (htab->elf.dynobj == NULL)
-		    htab->elf.dynobj = abfd;
-
 		  sreloc = _bfd_elf_make_dynamic_reloc_section
 		    (sec, htab->elf.dynobj, ABI_64_P (abfd) ? 3 : 2,
 		     abfd, /*rela?*/ TRUE);
@@ -3110,7 +3131,7 @@ elf_x86_64_allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
   if (htab == NULL)
     return FALSE;
   bed = get_elf_backend_data (info->output_bfd);
-  plt_entry_size = GET_PLT_ENTRY_SIZE (info->output_bfd);
+  plt_entry_size = htab->plt.plt_entry_size;
 
   resolved_to_zero = UNDEFINED_WEAK_RESOLVED_TO_ZERO (info,
 						      eh->has_got_reloc,
@@ -3148,7 +3169,8 @@ elf_x86_64_allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
 					      &eh->dyn_relocs,
 					      &htab->readonly_dynrelocs_against_ifunc,
 					      plt_entry_size,
-					      plt_entry_size,
+					      (htab->plt.has_plt0
+					       * plt_entry_size),
 					      GOT_ENTRY_SIZE, TRUE))
 	{
 	  asection *s = htab->plt_bnd;
@@ -3158,7 +3180,7 @@ elf_x86_64_allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
 	      eh->plt_bnd.offset = s->size;
 
 	      /* Make room for this entry in the .plt.bnd section.  */
-	      s->size += sizeof (elf_x86_64_legacy_plt2_entry);
+	      s->size += htab->non_lazy_plt->plt_entry_size;
 	    }
 
 	  return TRUE;
@@ -3214,7 +3236,7 @@ elf_x86_64_allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
 	     first entry.  The .plt section is used by prelink to undo
 	     prelinking for dynamic relocations.  */
 	  if (s->size == 0)
-	    s->size = plt_entry_size;
+	    s->size = htab->plt.has_plt0 * plt_entry_size;
 
 	  if (use_plt_got)
 	    eh->plt_got.offset = got_s->size;
@@ -3259,12 +3281,12 @@ elf_x86_64_allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
 
 	  /* Make room for this entry.  */
 	  if (use_plt_got)
-	    got_s->size += sizeof (elf_x86_64_legacy_plt2_entry);
+	    got_s->size += htab->non_lazy_plt->plt_entry_size;
 	  else
 	    {
 	      s->size += plt_entry_size;
 	      if (bnd_s)
-		bnd_s->size += sizeof (elf_x86_64_legacy_plt2_entry);
+		bnd_s->size += htab->non_lazy_plt->plt_entry_size;
 
 	      /* We also need to make an entry in the .got.plt section,
 		 which will be placed in the .got section by the linker
@@ -3685,7 +3707,6 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
   bfd_boolean relocs;
   bfd *ibfd;
   const struct elf_backend_data *bed;
-  const struct elf_x86_64_backend_data *arch_data;
 
   htab = elf_x86_64_hash_table (info);
   if (htab == NULL)
@@ -3852,9 +3873,9 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
 	  /* Reserve room for the initial entry.
 	     FIXME: we could probably do away with it in this case.  */
 	  if (htab->elf.splt->size == 0)
-	    htab->elf.splt->size = GET_PLT_ENTRY_SIZE (output_bfd);
+	    htab->elf.splt->size = htab->plt.plt_entry_size;
 	  htab->tlsdesc_plt = htab->elf.splt->size;
-	  htab->elf.splt->size += GET_PLT_ENTRY_SIZE (output_bfd);
+	  htab->elf.splt->size += htab->plt.plt_entry_size;
 	}
     }
 
@@ -3877,23 +3898,20 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
 	htab->elf.sgotplt->size = 0;
     }
 
-  arch_data = (htab->plt_bnd != NULL
-	       ? &elf_x86_64_bnd_arch_bed
-	       : get_elf_x86_64_arch_data (bed));
-
   if (_bfd_elf_eh_frame_present (info))
     {
       if (htab->plt_eh_frame != NULL
 	  && htab->elf.splt != NULL
 	  && htab->elf.splt->size != 0
 	  && !bfd_is_abs_section (htab->elf.splt->output_section))
-	htab->plt_eh_frame->size = arch_data->eh_frame_plt_size;
+	htab->plt_eh_frame->size = htab->plt.eh_frame_plt_size;
 
       if (htab->plt_got_eh_frame != NULL
 	  && htab->plt_got != NULL
 	  && htab->plt_got->size != 0
 	  && !bfd_is_abs_section (htab->plt_got->output_section))
-	htab->plt_got_eh_frame->size = arch_data->eh_frame_plt_got_size;
+	htab->plt_got_eh_frame->size
+	  = htab->non_lazy_plt->eh_frame_plt_size;
 
       /* Unwind info for .plt.bnd and .plt.got sections are
 	 identical.  */
@@ -3901,7 +3919,8 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
 	  && htab->plt_bnd != NULL
 	  && htab->plt_bnd->size != 0
 	  && !bfd_is_abs_section (htab->plt_bnd->output_section))
-	htab->plt_bnd_eh_frame->size = arch_data->eh_frame_plt_got_size;
+	htab->plt_bnd_eh_frame->size
+	  = htab->non_lazy_plt->eh_frame_plt_size;
     }
 
   /* We now have determined the sizes of the various dynamic sections.
@@ -3977,7 +3996,7 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
       && htab->plt_eh_frame->contents != NULL)
     {
       memcpy (htab->plt_eh_frame->contents,
-	      arch_data->eh_frame_plt, htab->plt_eh_frame->size);
+	      htab->plt.eh_frame_plt, htab->plt_eh_frame->size);
       bfd_put_32 (dynobj, htab->elf.splt->size,
 		  htab->plt_eh_frame->contents + PLT_FDE_LEN_OFFSET);
     }
@@ -3986,7 +4005,7 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
       && htab->plt_got_eh_frame->contents != NULL)
     {
       memcpy (htab->plt_got_eh_frame->contents,
-	      arch_data->eh_frame_plt_got,
+	      htab->non_lazy_plt->eh_frame_plt,
 	      htab->plt_got_eh_frame->size);
       bfd_put_32 (dynobj, htab->plt_got->size,
 		  (htab->plt_got_eh_frame->contents
@@ -3997,7 +4016,7 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
       && htab->plt_bnd_eh_frame->contents != NULL)
     {
       memcpy (htab->plt_bnd_eh_frame->contents,
-	      arch_data->eh_frame_plt_got,
+	      htab->non_lazy_plt->eh_frame_plt,
 	      htab->plt_bnd_eh_frame->size);
       bfd_put_32 (dynobj, htab->plt_bnd->size,
 		  (htab->plt_bnd_eh_frame->contents
@@ -4214,7 +4233,7 @@ elf_x86_64_relocate_section (bfd *output_bfd,
   Elf_Internal_Rela *rel;
   Elf_Internal_Rela *wrel;
   Elf_Internal_Rela *relend;
-  const unsigned int plt_entry_size = GET_PLT_ENTRY_SIZE (info->output_bfd);
+  unsigned int plt_entry_size;
 
   BFD_ASSERT (is_x86_64_elf (input_bfd));
 
@@ -4225,6 +4244,7 @@ elf_x86_64_relocate_section (bfd *output_bfd,
   htab = elf_x86_64_hash_table (info);
   if (htab == NULL)
     return FALSE;
+  plt_entry_size = htab->plt.plt_entry_size;
   symtab_hdr = &elf_symtab_hdr (input_bfd);
   sym_hashes = elf_sym_hashes (input_bfd);
   local_got_offsets = elf_local_got_offsets (input_bfd);
@@ -4408,7 +4428,8 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 
 		  if (htab->elf.splt != NULL)
 		    {
-		      plt_index = h->plt.offset / plt_entry_size - 1;
+		      plt_index = (h->plt.offset / plt_entry_size
+				   - htab->plt.has_plt0);
 		      off = (plt_index + 3) * GOT_ENTRY_SIZE;
 		      base_got = htab->elf.sgotplt;
 		    }
@@ -4633,7 +4654,8 @@ do_ifunc_pointer:
 		     state, or even just remember the offset, as
 		     finish_dynamic_symbol would use that as offset into
 		     .got.  */
-		  bfd_vma plt_index = h->plt.offset / plt_entry_size - 1;
+		  bfd_vma plt_index = (h->plt.offset / plt_entry_size
+				       - htab->plt.has_plt0);
 		  off = (plt_index + 3) * GOT_ENTRY_SIZE;
 		  base_got = htab->elf.sgotplt;
 		}
@@ -5776,7 +5798,6 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 				  Elf_Internal_Sym *sym)
 {
   struct elf_x86_64_link_hash_table *htab;
-  const struct elf_x86_64_backend_data *abed;
   bfd_boolean use_plt_bnd;
   struct elf_x86_64_link_hash_entry *eh;
   bfd_boolean local_undefweak;
@@ -5788,9 +5809,6 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
   /* Use MPX backend data in case of BND relocation.  Use .plt_bnd
      section only if there is .plt section.  */
   use_plt_bnd = htab->elf.splt != NULL && htab->plt_bnd != NULL;
-  abed = (use_plt_bnd
-	  ? &elf_x86_64_bnd_arch_bed
-	  : get_elf_x86_64_backend_data (output_bfd));
 
   eh = (struct elf_x86_64_link_hash_entry *) h;
   if (eh->no_finish_dynamic_symbol)
@@ -5806,8 +5824,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
   if (h->plt.offset != (bfd_vma) -1)
     {
       bfd_vma plt_index;
-      bfd_vma got_offset, plt_offset, plt_plt_offset, plt_got_offset;
-      bfd_vma plt_plt_insn_end, plt_got_insn_size;
+      bfd_vma got_offset, plt_offset;
       Elf_Internal_Rela rela;
       bfd_byte *loc;
       asection *plt, *gotplt, *relplt, *resolved_plt;
@@ -5854,60 +5871,30 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 
       if (plt == htab->elf.splt)
 	{
-	  got_offset = h->plt.offset / abed->plt_entry_size - 1;
+	  got_offset = (h->plt.offset / htab->plt.plt_entry_size
+			- htab->plt.has_plt0);
 	  got_offset = (got_offset + 3) * GOT_ENTRY_SIZE;
 	}
       else
 	{
-	  got_offset = h->plt.offset / abed->plt_entry_size;
+	  got_offset = h->plt.offset / htab->plt.plt_entry_size;
 	  got_offset = got_offset * GOT_ENTRY_SIZE;
 	}
 
-      plt_plt_insn_end = abed->plt_plt_insn_end;
-      plt_plt_offset = abed->plt_plt_offset;
-      plt_got_insn_size = abed->plt_got_insn_size;
-      plt_got_offset = abed->plt_got_offset;
+      /* Fill in the entry in the procedure linkage table.  */
+      memcpy (plt->contents + h->plt.offset, htab->plt.plt_entry,
+	      htab->plt.plt_entry_size);
       if (use_plt_bnd)
 	{
-	  /* Use the second PLT with BND relocations.  */
-	  const bfd_byte *plt_entry, *plt2_entry;
-
-	  if (info->bndplt)
-	    {
-	      plt_entry = elf_x86_64_bnd_plt_entry;
-	      plt2_entry = elf_x86_64_bnd_plt2_entry;
-	    }
-	  else
-	    {
-	      plt_entry = elf_x86_64_legacy_plt_entry;
-	      plt2_entry = elf_x86_64_legacy_plt2_entry;
-
-	      /* Subtract 1 since there is no BND prefix.  */
-	      plt_plt_insn_end -= 1;
-	      plt_plt_offset -= 1;
-	      plt_got_insn_size -= 1;
-	      plt_got_offset -= 1;
-	    }
-
-	  BFD_ASSERT (sizeof (elf_x86_64_bnd_plt_entry)
-		      == sizeof (elf_x86_64_legacy_plt_entry));
-
-	  /* Fill in the entry in the procedure linkage table.  */
-	  memcpy (plt->contents + h->plt.offset,
-		  plt_entry, sizeof (elf_x86_64_legacy_plt_entry));
-	  /* Fill in the entry in the second PLT.  */
 	  memcpy (htab->plt_bnd->contents + eh->plt_bnd.offset,
-		  plt2_entry, sizeof (elf_x86_64_legacy_plt2_entry));
+		  htab->non_lazy_plt->plt_entry,
+		  htab->non_lazy_plt->plt_entry_size);
 
 	  resolved_plt = htab->plt_bnd;
 	  plt_offset = eh->plt_bnd.offset;
 	}
       else
 	{
-	  /* Fill in the entry in the procedure linkage table.  */
-	  memcpy (plt->contents + h->plt.offset, abed->plt_entry,
-		  abed->plt_entry_size);
-
 	  resolved_plt = plt;
 	  plt_offset = h->plt.offset;
 	}
@@ -5922,7 +5909,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 			      - resolved_plt->output_section->vma
 			      - resolved_plt->output_offset
 			      - plt_offset
-			      - plt_got_insn_size);
+			      - htab->plt.plt_got_insn_size);
 
       /* Check PC-relative offset overflow in PLT entry.  */
       if ((plt_got_pcrel_offset + 0x80000000) > 0xffffffff)
@@ -5931,7 +5918,8 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 				output_bfd, h->root.root.string);
 
       bfd_put_32 (output_bfd, plt_got_pcrel_offset,
-		  resolved_plt->contents + plt_offset + plt_got_offset);
+		  (resolved_plt->contents + plt_offset
+		   + htab->plt.plt_got_offset));
 
       /* Fill in the entry in the global offset table, initially this
 	 points to the second part of the PLT entry.  Leave the entry
@@ -5939,11 +5927,12 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 	 against undefined weak symbol in PIE.  */
       if (!local_undefweak)
 	{
-	  bfd_put_64 (output_bfd, (plt->output_section->vma
-				   + plt->output_offset
-				   + h->plt.offset
-				   + abed->plt_lazy_offset),
-		      gotplt->contents + got_offset);
+	  if (htab->plt.has_plt0)
+	    bfd_put_64 (output_bfd, (plt->output_section->vma
+				     + plt->output_offset
+				     + h->plt.offset
+				     + htab->lazy_plt->plt_lazy_offset),
+			gotplt->contents + got_offset);
 
 	  /* Fill in the entry in the .rela.plt section.  */
 	  rela.r_offset = (gotplt->output_section->vma
@@ -5971,15 +5960,17 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 	      plt_index = htab->next_jump_slot_index++;
 	    }
 
-	  /* Don't fill PLT entry for static executables.  */
-	  if (plt == htab->elf.splt)
+	  /* Don't fill PLT entry for static executables nor without
+	     PLT0.  */
+	  if (plt == htab->elf.splt && htab->plt.has_plt0)
 	    {
-	      bfd_vma plt0_offset = h->plt.offset + plt_plt_insn_end;
+	      bfd_vma plt0_offset
+		= h->plt.offset + htab->lazy_plt->plt_plt_insn_end;
 
 	      /* Put relocation index.  */
 	      bfd_put_32 (output_bfd, plt_index,
 			  (plt->contents + h->plt.offset
-			   + abed->plt_reloc_offset));
+			   + htab->lazy_plt->plt_reloc_offset));
 
 	      /* Put offset for jmp .PLT0 and check for overflow.  We don't
 		 check relocation index for overflow since branch displacement
@@ -5989,7 +5980,8 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 		info->callbacks->einfo (_("%F%B: branch displacement overflow in PLT entry for `%s'\n"),
 					output_bfd, h->root.root.string);
 	      bfd_put_32 (output_bfd, - plt0_offset,
-			  plt->contents + h->plt.offset + plt_plt_offset);
+			  (plt->contents + h->plt.offset
+			   + htab->lazy_plt->plt_plt_offset));
 	    }
 
 	  bed = get_elf_backend_data (output_bfd);
@@ -5999,11 +5991,10 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
     }
   else if (eh->plt_got.offset != (bfd_vma) -1)
     {
-      bfd_vma got_offset, plt_offset, plt_got_offset, plt_got_insn_size;
+      bfd_vma got_offset, plt_offset;
       asection *plt, *got;
       bfd_boolean got_after_plt;
       int32_t got_pcrel_offset;
-      const bfd_byte *got_plt_entry;
 
       /* Set the entry in the GOT procedure linkage table.  */
       plt = htab->plt_got;
@@ -6016,25 +6007,13 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 	  || got == NULL)
 	abort ();
 
-      /* Use the second PLT entry template for the GOT PLT since they
+      /* Use the non-lazy PLT entry template for the GOT PLT since they
 	 are the identical.  */
-      plt_got_insn_size = elf_x86_64_bnd_arch_bed.plt_got_insn_size;
-      plt_got_offset = elf_x86_64_bnd_arch_bed.plt_got_offset;
-      if (info->bndplt)
-	got_plt_entry = elf_x86_64_bnd_plt2_entry;
-      else
-	{
-	  got_plt_entry = elf_x86_64_legacy_plt2_entry;
-
-	  /* Subtract 1 since there is no BND prefix.  */
-	  plt_got_insn_size -= 1;
-	  plt_got_offset -= 1;
-	}
-
       /* Fill in the entry in the GOT procedure linkage table.  */
       plt_offset = eh->plt_got.offset;
       memcpy (plt->contents + plt_offset,
-	      got_plt_entry, sizeof (elf_x86_64_legacy_plt2_entry));
+	      htab->non_lazy_plt->plt_entry,
+	      htab->non_lazy_plt->plt_entry_size);
 
       /* Put offset the PC-relative instruction referring to the GOT
 	 entry, subtracting the size of that instruction.  */
@@ -6044,7 +6023,7 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 			  - plt->output_section->vma
 			  - plt->output_offset
 			  - plt_offset
-			  - plt_got_insn_size);
+			  - htab->non_lazy_plt->plt_got_insn_size);
 
       /* Check PC-relative offset overflow in GOT PLT entry.  */
       got_after_plt = got->output_section->vma > plt->output_section->vma;
@@ -6055,7 +6034,8 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
 				output_bfd, h->root.root.string);
 
       bfd_put_32 (output_bfd, got_pcrel_offset,
-		  plt->contents + plt_offset + plt_got_offset);
+		  (plt->contents + plt_offset
+		   + htab->non_lazy_plt->plt_got_offset));
     }
 
   if (!local_undefweak
@@ -6290,18 +6270,11 @@ elf_x86_64_finish_dynamic_sections (bfd *output_bfd,
   struct elf_x86_64_link_hash_table *htab;
   bfd *dynobj;
   asection *sdyn;
-  const struct elf_x86_64_backend_data *abed;
 
   htab = elf_x86_64_hash_table (info);
   if (htab == NULL)
     return FALSE;
 
-  /* Use MPX backend data in case of BND relocation.  Use .plt_bnd
-     section only if there is .plt section.  */
-  abed = (htab->elf.splt != NULL && htab->plt_bnd != NULL
-	  ? &elf_x86_64_bnd_arch_bed
-	  : get_elf_x86_64_backend_data (output_bfd));
-
   dynobj = htab->elf.dynobj;
   sdyn = bfd_get_linker_section (dynobj, ".dynamic");
 
@@ -6360,76 +6333,87 @@ elf_x86_64_finish_dynamic_sections (bfd *output_bfd,
 	  (*bed->s->swap_dyn_out) (output_bfd, &dyn, dyncon);
 	}
 
-      /* Fill in the special first entry in the procedure linkage table.  */
       if (htab->elf.splt && htab->elf.splt->size > 0)
 	{
-	  /* Fill in the first entry in the procedure linkage table.  */
-	  memcpy (htab->elf.splt->contents,
-		  abed->plt0_entry, abed->plt_entry_size);
-	  /* Add offset for pushq GOT+8(%rip), since the instruction
-	     uses 6 bytes subtract this value.  */
-	  bfd_put_32 (output_bfd,
-		      (htab->elf.sgotplt->output_section->vma
-		       + htab->elf.sgotplt->output_offset
-		       + 8
-		       - htab->elf.splt->output_section->vma
-		       - htab->elf.splt->output_offset
-		       - 6),
-		      htab->elf.splt->contents + abed->plt0_got1_offset);
-	  /* Add offset for the PC-relative instruction accessing GOT+16,
-	     subtracting the offset to the end of that instruction.  */
-	  bfd_put_32 (output_bfd,
-		      (htab->elf.sgotplt->output_section->vma
-		       + htab->elf.sgotplt->output_offset
-		       + 16
-		       - htab->elf.splt->output_section->vma
-		       - htab->elf.splt->output_offset
-		       - abed->plt0_got2_insn_end),
-		      htab->elf.splt->contents + abed->plt0_got2_offset);
-
 	  elf_section_data (htab->elf.splt->output_section)
-	    ->this_hdr.sh_entsize = abed->plt_entry_size;
+	    ->this_hdr.sh_entsize = htab->plt.plt_entry_size;
 
-	  if (htab->tlsdesc_plt)
+	  if (htab->plt.has_plt0)
 	    {
-	      bfd_put_64 (output_bfd, (bfd_vma) 0,
-			  htab->elf.sgot->contents + htab->tlsdesc_got);
-
-	      memcpy (htab->elf.splt->contents + htab->tlsdesc_plt,
-		      abed->plt0_entry, abed->plt_entry_size);
-
-	      /* Add offset for pushq GOT+8(%rip), since the
-		 instruction uses 6 bytes subtract this value.  */
+	      /* Fill in the special first entry in the procedure linkage
+		 table.  */
+	      memcpy (htab->elf.splt->contents,
+		      htab->lazy_plt->plt0_entry,
+		      htab->lazy_plt->plt_entry_size);
+	      /* Add offset for pushq GOT+8(%rip), since the instruction
+		 uses 6 bytes subtract this value.  */
 	      bfd_put_32 (output_bfd,
 			  (htab->elf.sgotplt->output_section->vma
 			   + htab->elf.sgotplt->output_offset
 			   + 8
 			   - htab->elf.splt->output_section->vma
 			   - htab->elf.splt->output_offset
-			   - htab->tlsdesc_plt
 			   - 6),
-			  htab->elf.splt->contents
-			  + htab->tlsdesc_plt + abed->plt0_got1_offset);
-	  /* Add offset for the PC-relative instruction accessing GOT+TDG,
-	     where TGD stands for htab->tlsdesc_got, subtracting the offset
-	     to the end of that instruction.  */
+			  (htab->elf.splt->contents
+			   + htab->lazy_plt->plt0_got1_offset));
+	      /* Add offset for the PC-relative instruction accessing
+		 GOT+16, subtracting the offset to the end of that
+		 instruction.  */
 	      bfd_put_32 (output_bfd,
-			  (htab->elf.sgot->output_section->vma
-			   + htab->elf.sgot->output_offset
-			   + htab->tlsdesc_got
+			  (htab->elf.sgotplt->output_section->vma
+			   + htab->elf.sgotplt->output_offset
+			   + 16
 			   - htab->elf.splt->output_section->vma
 			   - htab->elf.splt->output_offset
-			   - htab->tlsdesc_plt
-			   - abed->plt0_got2_insn_end),
-			  htab->elf.splt->contents
-			  + htab->tlsdesc_plt + abed->plt0_got2_offset);
+			   - htab->lazy_plt->plt0_got2_insn_end),
+			  (htab->elf.splt->contents
+			   + htab->lazy_plt->plt0_got2_offset));
+
+	      if (htab->tlsdesc_plt)
+		{
+		  bfd_put_64 (output_bfd, (bfd_vma) 0,
+			      htab->elf.sgot->contents + htab->tlsdesc_got);
+
+		  memcpy (htab->elf.splt->contents + htab->tlsdesc_plt,
+			  htab->lazy_plt->plt0_entry,
+			  htab->lazy_plt->plt_entry_size);
+
+		  /* Add offset for pushq GOT+8(%rip), since the
+		     instruction uses 6 bytes subtract this value.  */
+		  bfd_put_32 (output_bfd,
+			      (htab->elf.sgotplt->output_section->vma
+			       + htab->elf.sgotplt->output_offset
+			       + 8
+			       - htab->elf.splt->output_section->vma
+			       - htab->elf.splt->output_offset
+			       - htab->tlsdesc_plt
+			       - 6),
+			      (htab->elf.splt->contents
+			       + htab->tlsdesc_plt
+			       + htab->lazy_plt->plt0_got1_offset));
+		  /* Add offset for the PC-relative instruction accessing
+		     GOT+TDG, where TDG stands for htab->tlsdesc_got,
+		     subtracting the offset to the end of that
+		     instruction.  */
+		  bfd_put_32 (output_bfd,
+			      (htab->elf.sgot->output_section->vma
+			       + htab->elf.sgot->output_offset
+			       + htab->tlsdesc_got
+			       - htab->elf.splt->output_section->vma
+			       - htab->elf.splt->output_offset
+			       - htab->tlsdesc_plt
+			       - htab->lazy_plt->plt0_got2_insn_end),
+			      (htab->elf.splt->contents
+			       + htab->tlsdesc_plt
+			       + htab->lazy_plt->plt0_got2_offset));
+		}
 	    }
 	}
     }
 
   if (htab->plt_bnd != NULL)
     elf_section_data (htab->plt_bnd->output_section)
-      ->this_hdr.sh_entsize = sizeof (elf_x86_64_bnd_plt2_entry);
+      ->this_hdr.sh_entsize = htab->non_lazy_plt->plt_entry_size;
 
   if (htab->elf.sgotplt)
     {
@@ -6581,6 +6565,9 @@ elf_x86_64_output_arch_local_syms
   return TRUE;
 }
 
+/* Forward declaration.  */
+static const struct elf_x86_64_lazy_plt_layout elf_x86_64_nacl_plt;
+
 /* Return an array of PLT entry symbol values.  */
 
 static bfd_vma *
@@ -6593,7 +6580,8 @@ elf_x86_64_get_plt_sym_val (bfd *abfd, asymbol **dynsyms, asection *plt,
   bfd_vma *plt_sym_val;
   bfd_vma plt_offset;
   bfd_byte *plt_contents;
-  const struct elf_x86_64_backend_data *bed;
+  const struct elf_x86_64_lazy_plt_layout *lazy_plt;
+  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_plt;
   Elf_Internal_Shdr *hdr;
   asection *plt_bnd;
 
@@ -6608,10 +6596,7 @@ elf_x86_64_get_plt_sym_val (bfd *abfd, asymbol **dynsyms, asection *plt,
       plt = bfd_get_section_by_name (abfd, ".plt");
       if (plt == NULL)
 	abort ();
-      bed = &elf_x86_64_bnd_arch_bed;
     }
-  else
-    bed = get_elf_x86_64_backend_data (abfd);
 
   plt_contents = (bfd_byte *) bfd_malloc (plt->size);
   if (plt_contents == NULL)
@@ -6624,6 +6609,29 @@ bad_return:
       return NULL;
     }
 
+  non_lazy_plt = NULL;
+  if (get_elf_x86_64_backend_data (abfd)->os == is_nacl)
+    {
+      if (plt_bnd != NULL)
+	abort ();
+      lazy_plt = &elf_x86_64_nacl_plt;
+    }
+  else
+    {
+      if (plt_bnd)
+	{
+	  lazy_plt = &elf_x86_64_lazy_bnd_plt;
+	  non_lazy_plt = &elf_x86_64_non_lazy_bnd_plt;
+	}
+      else
+	lazy_plt = &elf_x86_64_lazy_plt;
+    }
+
+  /* Skip if the .plt section doesn't support lazy binding.  */
+  if (memcmp (plt_contents, lazy_plt->plt0_entry,
+	      lazy_plt->plt0_got1_offset) != 0)
+    goto bad_return;
+
   slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
   if (! (*slurp_relocs) (abfd, relplt, dynsyms, TRUE))
     goto bad_return;
@@ -6638,7 +6646,7 @@ bad_return:
   for (i = 0; i < count; i++)
     plt_sym_val[i] = -1;
 
-  plt_offset = bed->plt_entry_size;
+  plt_offset = lazy_plt->plt_entry_size;
   p = relplt->relocation;
   for (i = 0; i < count; i++, p++)
     {
@@ -6653,22 +6661,22 @@ bad_return:
 	continue;
 
       reloc_index = H_GET_32 (abfd, (plt_contents + plt_offset
-				     + bed->plt_reloc_offset));
+				     + lazy_plt->plt_reloc_offset));
       if (reloc_index < count)
 	{
 	  if (plt_bnd)
 	    {
 	      /* This is the index in .plt section.  */
-	      long plt_index = plt_offset / bed->plt_entry_size;
+	      long plt_index = plt_offset / lazy_plt->plt_entry_size;
 	      /* Store VMA + the offset in .plt.bnd section.  */
 	      plt_sym_val[reloc_index] =
 		(plt_bnd->vma
-		 + (plt_index - 1) * sizeof (elf_x86_64_legacy_plt2_entry));
+		 + (plt_index - 1) * non_lazy_plt->plt_entry_size);
 	    }
 	  else
 	    plt_sym_val[reloc_index] = plt->vma + plt_offset;
 	}
-      plt_offset += bed->plt_entry_size;
+      plt_offset += lazy_plt->plt_entry_size;
 
       /* PR binutils/18437: Skip extra relocations in the .rela.plt
 	 section.  */
@@ -6968,6 +6976,147 @@ elf_x86_64_merge_gnu_properties (bfd *abfd ATTRIBUTE_UNUSED,
   return updated;
 }
 
+/* Set up x86-64 GNU properties.  Return the first relocatable ELF input
+   with GNU properties if found.  Otherwise, return NULL.  */
+
+static bfd *
+elf_x86_64_link_setup_gnu_properties (struct bfd_link_info *info)
+{
+  if (!bfd_link_relocatable (info))
+    {
+      struct elf_x86_64_link_hash_table *htab
+	= elf_x86_64_hash_table (info);
+      if (htab != NULL)
+	{
+	  asection *pltsec = htab->elf.splt;
+
+	  if (htab->elf.dynobj == NULL)
+	    {
+	      bfd *abfd;
+
+	      /* Find a normal input file to hold linker created
+		 sections.  */
+	      for (abfd = info->input_bfds;
+		   abfd != NULL;
+		   abfd = abfd->link.next)
+		if ((abfd->flags
+		     & (DYNAMIC | BFD_LINKER_CREATED | BFD_PLUGIN)) == 0)
+		  {
+		    htab->elf.dynobj = abfd;
+		    break;
+		  }
+	    }
+
+	  /* Create the ifunc sections.  */
+	  if (htab->elf.dynobj != NULL
+	      && !_bfd_elf_create_ifunc_sections (htab->elf.dynobj,
+						   info))
+	    info->callbacks->einfo (_("%F: failed to create ifunc sections\n"));
+
+	  htab->plt.has_plt0 = 1;
+	  if (get_elf_x86_64_backend_data (info->output_bfd)->os
+	      == is_normal)
+	    {
+	      if (info->bndplt)
+		{
+		  htab->lazy_plt = &elf_x86_64_lazy_bnd_plt;
+		  htab->non_lazy_plt = &elf_x86_64_non_lazy_bnd_plt;
+		}
+	      else
+		{
+		  htab->lazy_plt = &elf_x86_64_lazy_plt;
+		  htab->non_lazy_plt = &elf_x86_64_non_lazy_plt;
+		}
+
+	      if ((info->flags & DF_BIND_NOW))
+		htab->plt.has_plt0 = 0;
+	    }
+	  else
+	    {
+	      htab->lazy_plt = &elf_x86_64_nacl_plt;
+	      htab->non_lazy_plt = NULL;
+	    }
+
+	  /* Use non-lazy PLT if there is no PLT0 or there is IPLT for
+	     IFUNC.  */
+	  if (htab->non_lazy_plt != NULL
+	      && (!htab->plt.has_plt0 || pltsec == NULL))
+	    {
+	      htab->plt.plt_entry
+		= htab->non_lazy_plt->plt_entry;
+	      htab->plt.plt_entry_size
+		= htab->non_lazy_plt->plt_entry_size;
+	      htab->plt.plt_got_offset
+		= htab->non_lazy_plt->plt_got_offset;
+	      htab->plt.plt_got_insn_size
+		= htab->non_lazy_plt->plt_got_insn_size;
+	      htab->plt.eh_frame_plt_size
+		= htab->non_lazy_plt->eh_frame_plt_size;
+	      htab->plt.eh_frame_plt
+		= htab->non_lazy_plt->eh_frame_plt;
+	    }
+	  else
+	    {
+	      htab->plt.plt_entry
+		= htab->lazy_plt->plt_entry;
+	      htab->plt.plt_entry_size
+		= htab->lazy_plt->plt_entry_size;
+	      htab->plt.plt_got_offset
+		= htab->lazy_plt->plt_got_offset;
+	      htab->plt.plt_got_insn_size
+		= htab->lazy_plt->plt_got_insn_size;
+	      htab->plt.eh_frame_plt_size
+		= htab->lazy_plt->eh_frame_plt_size;
+	      htab->plt.eh_frame_plt
+		= htab->lazy_plt->eh_frame_plt;
+	    }
+
+	  /* Don't change PLT section alignment for NaCl since it uses
+	     64-byte PLT entry and sets PLT section alignment to 32
+	     bytes.  */
+	  if (htab->non_lazy_plt != NULL)
+	    {
+	      if (pltsec != NULL)
+		{
+		  unsigned int plt_alignment
+		    = bfd_log2 (htab->non_lazy_plt->plt_entry_size);
+
+		  if (!bfd_set_section_alignment (pltsec->owner,
+						  pltsec,
+						  bfd_log2 (htab->plt.plt_entry_size)))
+		    {
+error_alignment:
+		      info->callbacks->einfo (_("%F%A: failed to align PLT section\n"),
+					      pltsec);
+		    }
+
+		  pltsec = htab->plt_got;
+		  if (!bfd_set_section_alignment (pltsec->owner,
+						  pltsec,
+						  plt_alignment))
+		    goto error_alignment;
+
+		  pltsec = htab->plt_bnd;
+		  if (pltsec != NULL
+		      && !bfd_set_section_alignment (pltsec->owner,
+						     pltsec,
+						     plt_alignment))
+		    goto error_alignment;
+		}
+
+	      pltsec = htab->elf.iplt;
+	      if (pltsec != NULL
+		  && !bfd_set_section_alignment (pltsec->owner,
+						 pltsec,
+						 bfd_log2 (htab->plt.plt_entry_size)))
+		goto error_alignment;
+	    }
+	}
+    }
+
+  return _bfd_elf_link_setup_gnu_properties (info);
+}
+
 static const struct bfd_elf_special_section
 elf_x86_64_special_sections[]=
 {
@@ -7064,6 +7213,8 @@ elf_x86_64_special_sections[]=
   elf_x86_64_parse_gnu_properties
 #define elf_backend_merge_gnu_properties \
  elf_x86_64_merge_gnu_properties
+#define elf_backend_setup_gnu_properties \
+ elf_x86_64_link_setup_gnu_properties
 
 #include "elf64-target.h"
 
@@ -7265,7 +7416,7 @@ static const bfd_byte elf_x86_64_nacl_eh_frame_plt[] =
     DW_CFA_nop, DW_CFA_nop
   };
 
-static const struct elf_x86_64_backend_data elf_x86_64_nacl_arch_bed =
+static const struct elf_x86_64_lazy_plt_layout elf_x86_64_nacl_plt =
   {
     elf_x86_64_nacl_plt0_entry,              /* plt0_entry */
     elf_x86_64_nacl_plt_entry,               /* plt_entry */
@@ -7280,9 +7431,12 @@ static const struct elf_x86_64_backend_data elf_x86_64_nacl_arch_bed =
     42,                                      /* plt_plt_insn_end */
     32,                                      /* plt_lazy_offset */
     elf_x86_64_nacl_eh_frame_plt,            /* eh_frame_plt */
-    sizeof (elf_x86_64_nacl_eh_frame_plt),   /* eh_frame_plt_size */
-    NULL,                                    /* eh_frame_plt_got */
-    0,                                       /* eh_frame_plt_got_size */
+    sizeof (elf_x86_64_nacl_eh_frame_plt)    /* eh_frame_plt_size */
+  };
+
+static const struct elf_x86_64_backend_data elf_x86_64_nacl_arch_bed =
+  {
+    is_nacl                                  /* os */
   };
 
 #undef	elf_backend_arch_data
diff --git a/ld/testsuite/ld-ifunc/ifunc-16-x86-64-now.d b/ld/testsuite/ld-ifunc/ifunc-16-x86-64-now.d
new file mode 100644
index 0000000..acc5093
--- /dev/null
+++ b/ld/testsuite/ld-ifunc/ifunc-16-x86-64-now.d
@@ -0,0 +1,14 @@
+#source: ifunc-16-x86.s
+#as: --64
+#ld: -z now -shared -melf_x86_64
+#readelf: -r --wide
+#target: x86_64-*-*
+#notarget: x86_64-*-nacl*
+
+Relocation section '.rela.dyn' at .*
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_GLOB_DAT[ ]+0+[ ]+ifunc \+ 0
+
+Relocation section '.rela.plt' at .*
+[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
diff --git a/ld/testsuite/ld-ifunc/ifunc-2-local-x86-64-now.d b/ld/testsuite/ld-ifunc/ifunc-2-local-x86-64-now.d
new file mode 100644
index 0000000..7bb4f1a
--- /dev/null
+++ b/ld/testsuite/ld-ifunc/ifunc-2-local-x86-64-now.d
@@ -0,0 +1,26 @@
+#source: ifunc-2-local-x86-64.s
+#as: --64
+#ld: -z now -shared -melf_x86_64
+#objdump: -dw
+#target: x86_64-*-*
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+
+Disassembly of section .plt:
+
+0+1e8 <.plt>:
+ +[a-f0-9]+:	ff 25 3a 01 20 00    	jmpq   \*0x20013a\(%rip\)        # 200328 <_GLOBAL_OFFSET_TABLE_\+0x18>
+ +[a-f0-9]+:	66 90                	xchg   %ax,%ax
+
+Disassembly of section .text:
+
+0+1f0 <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+1f1 <bar>:
+ +[a-f0-9]+:	e8 f2 ff ff ff       	callq  1e8 <.plt>
+ +[a-f0-9]+:	48 8d 05 eb ff ff ff 	lea    -0x15\(%rip\),%rax        # 1e8 <.plt>
+ +[a-f0-9]+:	c3                   	retq   
+#pass
diff --git a/ld/testsuite/ld-ifunc/ifunc-2-x86-64-now.d b/ld/testsuite/ld-ifunc/ifunc-2-x86-64-now.d
new file mode 100644
index 0000000..1fffc0a
--- /dev/null
+++ b/ld/testsuite/ld-ifunc/ifunc-2-x86-64-now.d
@@ -0,0 +1,26 @@
+#source: ifunc-2-x86-64.s
+#as: --64
+#ld: -z now -shared -melf_x86_64
+#objdump: -dw
+#target: x86_64-*-*
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+
+Disassembly of section .plt:
+
+0+1e8 <.plt>:
+ +[a-f0-9]+:	ff 25 3a 01 20 00    	jmpq   \*0x20013a\(%rip\)        # 200328 <_GLOBAL_OFFSET_TABLE_\+0x18>
+ +[a-f0-9]+:	66 90                	xchg   %ax,%ax
+
+Disassembly of section .text:
+
+0+1f0 <foo>:
+ +[a-f0-9]+:	c3                   	retq   
+
+0+1f1 <bar>:
+ +[a-f0-9]+:	e8 f2 ff ff ff       	callq  1e8 <.plt>
+ +[a-f0-9]+:	48 8d 05 eb ff ff ff 	lea    -0x15\(%rip\),%rax        # 1e8 <.plt>
+ +[a-f0-9]+:	c3                   	retq   
+#pass
diff --git a/ld/testsuite/ld-ifunc/pr17154-x86-64-now.d b/ld/testsuite/ld-ifunc/pr17154-x86-64-now.d
new file mode 100644
index 0000000..d9f78ed
--- /dev/null
+++ b/ld/testsuite/ld-ifunc/pr17154-x86-64-now.d
@@ -0,0 +1,40 @@
+#source: pr17154-x86.s
+#as: --64
+#ld: -z now -shared -melf_x86_64
+#objdump: -dw
+#target: x86_64-*-*
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+
+Disassembly of section .plt:
+
+0+2b0 <.plt>:
+ +[a-f0-9]+:	ff 25 9a 01 20 00    	jmpq   \*0x20019a\(%rip\)        # 200450 <_GLOBAL_OFFSET_TABLE_\+0x18>
+ +[a-f0-9]+:	66 90                	xchg   %ax,%ax
+ +[a-f0-9]+:	ff 25 9a 01 20 00    	jmpq   \*0x20019a\(%rip\)        # 200458 <_GLOBAL_OFFSET_TABLE_\+0x20>
+ +[a-f0-9]+:	66 90                	xchg   %ax,%ax
+
+Disassembly of section .plt.got:
+
+0+2c0 <.plt.got>:
+ +[a-f0-9]+:	ff 25 62 01 20 00    	jmpq   \*0x200162\(%rip\)        # 200428 <func1>
+ +[a-f0-9]+:	66 90                	xchg   %ax,%ax
+ +[a-f0-9]+:	ff 25 62 01 20 00    	jmpq   \*0x200162\(%rip\)        # 200430 <func2>
+ +[a-f0-9]+:	66 90                	xchg   %ax,%ax
+
+Disassembly of section .text:
+
+0+2d0 <resolve1>:
+ +[a-f0-9]+:	e8 eb ff ff ff       	callq  2c0 <.plt.got>
+
+0+2d5 <g1>:
+ +[a-f0-9]+:	e9 de ff ff ff       	jmpq   2b8 <.plt\+0x8>
+
+0+2da <resolve2>:
+ +[a-f0-9]+:	e8 e9 ff ff ff       	callq  2c8 <.plt.got\+0x8>
+
+0+2df <g2>:
+ +[a-f0-9]+:	e9 cc ff ff ff       	jmpq   2b0 <.plt>
+#pass
diff --git a/ld/testsuite/ld-x86-64/plt2.dd b/ld/testsuite/ld-x86-64/plt2.dd
new file mode 100644
index 0000000..5da1190
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/plt2.dd
@@ -0,0 +1,28 @@
+#source: plt2.s
+#as: --64
+#ld: -z now -melf_x86_64
+#objdump: -dwr
+#target: i?86-*-*
+
+.*: +file format .*
+
+
+Disassembly of section .plt:
+
+0+400290 <.plt>:
+ +[a-f0-9]+:	ff 25 a2 01 20 00    	jmpq   \*0x2001a2\(%rip\)        # 600438 <fn1>
+ +[a-f0-9]+:	66 90                	xchg   %ax,%ax
+
+Disassembly of section .plt.got:
+
+0+400298 <.plt.got>:
+ +[a-f0-9]+:	ff 25 7a 01 20 00    	jmpq   \*0x20017a\(%rip\)        # 600418 <fn2>
+ +[a-f0-9]+:	66 90                	xchg   %ax,%ax
+
+Disassembly of section .text:
+
+0+4002a0 <_start>:
+ +[a-f0-9]+:	e8 eb ff ff ff       	callq  400290 <.plt>
+ +[a-f0-9]+:	e8 ee ff ff ff       	callq  400298 <.plt.got>
+ +[a-f0-9]+:	81 7c 24 08 90 02 40 00 	cmpl   \$0x400290,0x8\(%rsp\)
+#pass
diff --git a/ld/testsuite/ld-x86-64/plt2.rd b/ld/testsuite/ld-x86-64/plt2.rd
new file mode 100644
index 0000000..ea822d7
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/plt2.rd
@@ -0,0 +1,9 @@
+#source: plt2.s
+#as: --64
+#ld: -z now -melf_x86_64
+#readelf: -SW
+#target: i?86-*-*
+
+#...
+ +\[ *[0-9]+\] \.plt +PROGBITS +[0-9a-f]+ +[0-9a-f]+ +0+8 +.* +AX +0 +0 +8
+#pass
diff --git a/ld/testsuite/ld-x86-64/plt2.s b/ld/testsuite/ld-x86-64/plt2.s
new file mode 100644
index 0000000..25859fa
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/plt2.s
@@ -0,0 +1,7 @@
+	.text
+	.globl _start
+	.type _start,@function
+_start:
+	call fn1
+	call fn2
+	cmpl $fn1, 8(%rsp)
diff --git a/ld/testsuite/ld-x86-64/x86-64.exp b/ld/testsuite/ld-x86-64/x86-64.exp
index 7127eca..f2dc335 100644
--- a/ld/testsuite/ld-x86-64/x86-64.exp
+++ b/ld/testsuite/ld-x86-64/x86-64.exp
@@ -1291,6 +1291,18 @@ if { ![istarget "x86_64-*-linux*"]} {
     return
 }
 
+run_ld_link_tests [list \
+    [list \
+	"basic PLT generation (-z now)" \
+	"-z now -melf_x86_64 tmpdir/libpltlib.so" \
+	"" \
+	"--64" \
+	{plt2.s} \
+	{{readelf -SW plt2.rd} {objdump -dwr plt2.dd}} \
+	"plt2" \
+    ] \
+]
+
 # Linux only tests
 run_dump_test "pr17618"
 run_dump_test "pltgot-1"
-- 
2.9.3

