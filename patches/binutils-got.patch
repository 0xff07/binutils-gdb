diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 60d7e45..9345e88 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -3177,6 +3177,7 @@ instruction.  */
   BFD_RELOC_386_TLS_DESC_CALL,
   BFD_RELOC_386_TLS_DESC,
   BFD_RELOC_386_IRELATIVE,
+  BFD_RELOC_386_GOT32X,
 
 /* x86-64/elf relocations  */
   BFD_RELOC_X86_64_GOT32,
@@ -3208,6 +3209,8 @@ instruction.  */
   BFD_RELOC_X86_64_IRELATIVE,
   BFD_RELOC_X86_64_PC32_BND,
   BFD_RELOC_X86_64_PLT32_BND,
+  BFD_RELOC_X86_64_GOTPCRELX,
+  BFD_RELOC_X86_64_REX_GOTPCRELX,
 
 /* ns32k relocations  */
   BFD_RELOC_NS32K_IMM_8,
diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
index 8c1dadb..60cd91a 100644
--- a/bfd/elf32-i386.c
+++ b/bfd/elf32-i386.c
@@ -29,6 +29,7 @@
 #include "objalloc.h"
 #include "hashtab.h"
 #include "dwarf2.h"
+#include "opcode/i386.h"
 
 /* 386 uses REL relocations instead of RELA.  */
 #define USE_REL	1
@@ -146,9 +147,12 @@ static reloc_howto_type elf_howto_table[]=
   HOWTO(R_386_IRELATIVE, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
 	bfd_elf_generic_reloc, "R_386_IRELATIVE",
 	TRUE, 0xffffffff, 0xffffffff, FALSE),
+  HOWTO(R_386_GOT32X, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
+	bfd_elf_generic_reloc, "R_386_GOT32X",
+	TRUE, 0xffffffff, 0xffffffff, FALSE),
 
   /* Another gap.  */
-#define R_386_ext2 (R_386_IRELATIVE + 1 - R_386_tls_offset)
+#define R_386_ext2 (R_386_GOT32X + 1 - R_386_tls_offset)
 #define R_386_vt_offset (R_386_GNU_VTINHERIT - R_386_ext2)
 
 /* GNU extension to record C++ vtable hierarchy.  */
@@ -332,6 +336,10 @@ elf_i386_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
       TRACE ("BFD_RELOC_386_IRELATIVE");
       return &elf_howto_table[R_386_IRELATIVE - R_386_tls_offset];
 
+    case BFD_RELOC_386_GOT32X:
+      TRACE ("BFD_RELOC_386_GOT32X");
+      return &elf_howto_table[R_386_GOT32X - R_386_tls_offset];
+
     case BFD_RELOC_VTABLE_INHERIT:
       TRACE ("BFD_RELOC_VTABLE_INHERIT");
       return &elf_howto_table[R_386_GNU_VTINHERIT - R_386_vt_offset];
@@ -1468,7 +1476,7 @@ elf_i386_tls_transition (struct bfd_link_info *info, bfd *abfd,
 
 /* Rename some of the generic section flags to better document how they
    are used here.  */
-#define need_convert_mov_to_lea sec_flg0
+#define need_convert_load sec_flg0
 
 /* Look through the relocs for a section during the first phase, and
    calculate needed space in the global offset table, procedure linkage
@@ -1580,6 +1588,7 @@ elf_i386_check_relocs (bfd *abfd,
 	    case R_386_PC32:
 	    case R_386_PLT32:
 	    case R_386_GOT32:
+	    case R_386_GOT32X:
 	      if (htab->elf.dynobj == NULL)
 		htab->elf.dynobj = abfd;
 	      if (!_bfd_elf_create_ifunc_sections (htab->elf.dynobj, info))
@@ -1637,6 +1646,7 @@ elf_i386_check_relocs (bfd *abfd,
 	  /* Fall through */
 
 	case R_386_GOT32:
+	case R_386_GOT32X:
 	case R_386_TLS_GD:
 	case R_386_TLS_GOTDESC:
 	case R_386_TLS_DESC_CALL:
@@ -1647,7 +1657,10 @@ elf_i386_check_relocs (bfd *abfd,
 	    switch (r_type)
 	      {
 	      default:
-	      case R_386_GOT32: tls_type = GOT_NORMAL; break;
+	      case R_386_GOT32:
+	      case R_386_GOT32X:
+		tls_type = GOT_NORMAL;
+		break;
 	      case R_386_TLS_GD: tls_type = GOT_TLS_GD; break;
 	      case R_386_TLS_GOTDESC:
 	      case R_386_TLS_DESC_CALL:
@@ -1948,9 +1961,9 @@ do_size:
 	    return FALSE;
 	}
 
-      if (r_type == R_386_GOT32
+      if ((r_type == R_386_GOT32 || r_type == R_386_GOT32X)
 	  && (h == NULL || h->type != STT_GNU_IFUNC))
-	sec->need_convert_mov_to_lea = 1;
+	sec->need_convert_load = 1;
     }
 
   return TRUE;
@@ -2074,6 +2087,7 @@ elf_i386_gc_sweep_hook (bfd *abfd,
 	case R_386_TLS_IE:
 	case R_386_TLS_GOTIE:
 	case R_386_GOT32:
+	case R_386_GOT32X:
 	  if (h != NULL)
 	    {
 	      if (h->got.refcount > 0)
@@ -2718,14 +2732,27 @@ elf_i386_readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
   return TRUE;
 }
 
-/* Convert
-   mov foo@GOT(%reg), %reg
+/* With the local symbol, foo, we convert
+   mov foo@GOT[(%reg1)], %reg2
+   to
+   lea foo[@GOTOFF(%reg1)], %reg2
+   and convert
+   call/jmp *foo@GOT[(%reg)]
    to
-   lea foo@GOTOFF(%reg), %reg
-   with the local symbol, foo.  */
+   nop call foo/jmp foo nop
+   When PIC is false, convert
+   test %reg1, foo@GOT[(%reg2)]
+   to
+   test $foo, %reg1
+   and convert
+   binop foo@GOT[(%reg1)], %reg2
+   to
+   binop $foo, %reg2
+   where binop is one of adc, add, and, cmp, or, sbb, sub, xor
+   instructions.  */
 
 static bfd_boolean
-elf_i386_convert_mov_to_lea (bfd *abfd, asection *sec,
+elf_i386_convert_load (bfd *abfd, asection *sec,
 			     struct bfd_link_info *link_info)
 {
   Elf_Internal_Shdr *symtab_hdr;
@@ -2743,7 +2770,7 @@ elf_i386_convert_mov_to_lea (bfd *abfd, asection *sec,
 
   /* Nothing to do if there is no need or no output.  */
   if ((sec->flags & (SEC_CODE | SEC_RELOC)) != (SEC_CODE | SEC_RELOC)
-      || sec->need_convert_mov_to_lea == 0
+      || sec->need_convert_load == 0
       || bfd_is_abs_section (sec->output_section))
     return TRUE;
 
@@ -2777,32 +2804,92 @@ elf_i386_convert_mov_to_lea (bfd *abfd, asection *sec,
       unsigned int r_symndx = ELF32_R_SYM (irel->r_info);
       unsigned int indx;
       struct elf_link_hash_entry *h;
+      unsigned int opcode;
+      unsigned int modrm;
+      bfd_vma roff;
+      bfd_boolean baseless;
+      Elf_Internal_Sym *isym;
+      unsigned int addend;
+      unsigned int nop;
+      bfd_vma nop_offset;
 
-      if (r_type != R_386_GOT32)
+      if (r_type != R_386_GOT32 && r_type != R_386_GOT32X)
 	continue;
 
-      /* Get the symbol referred to by the reloc.  */
-      if (r_symndx < symtab_hdr->sh_info)
+      roff = irel->r_offset;
+      if (roff < 2)
+	continue;
+
+      modrm = bfd_get_8 (abfd, contents + roff - 1);
+      baseless = (modrm & 0xc7) == 0x5;
+
+      if (r_type == R_386_GOT32X
+	  && baseless
+	  && bfd_link_pic (link_info))
 	{
-	  Elf_Internal_Sym *isym;
+	  /* For PIC, disallow R_386_GOT32X without a base register
+	     since we don't know what the GOT base is.   Allow
+	     R_386_GOT32 for existing object files.  */
+	  const char *name;
+
+	  if (r_symndx < symtab_hdr->sh_info)
+	    {
+	      isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd,
+					    r_symndx);
+	      name = bfd_elf_sym_name (abfd, symtab_hdr, isym, NULL);
+	    }
+	  else
+	    {
+	      indx = r_symndx - symtab_hdr->sh_info;
+	      h = elf_sym_hashes (abfd)[indx];
+	      BFD_ASSERT (h != NULL);
+	      name = h->root.root.string;
+	    }
+
+	  (*_bfd_error_handler)
+	    (_("%B: direct GOT relocation R_386_GOT32X against `%s' without base register can not be used when making a shared object"),
+	     abfd, name);
+	  goto error_return;
+	}
+
+      opcode = bfd_get_8 (abfd, contents + roff - 2);
+
+      /* It is OK to convert mov to lea.  */
+      if (opcode != 0x8b)
+	{
+	  /* Only convert R_386_GOT32X relocation for call, jmp or
+	     one of adc, add, and, cmp, or, sbb, sub, test, xor
+	     instructions.  */
+	  if (r_type != R_386_GOT32X)
+	    continue;
+
+	  /* It is OK to convert indirect branch to direct branch.  It
+	     is OK to convert adc, add, and, cmp, or, sbb, sub, test,
+	     xor only when PIC is false.   */
+	  if (opcode != 0xff && bfd_link_pic (link_info))
+	    continue;
+	}
 
+      /* Try to convert R_386_GOT32 and R_386_GOT32X.  Get the symbol
+	 referred to by the reloc.  */
+      if (r_symndx < symtab_hdr->sh_info)
+	{
 	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
 					abfd, r_symndx);
 
-	  /* STT_GNU_IFUNC must keep R_386_GOT32 relocation.  */
-	  if (ELF_ST_TYPE (isym->st_info) != STT_GNU_IFUNC
-	      && irel->r_offset >= 2
-	      && bfd_get_8 (abfd, contents + irel->r_offset - 2) == 0x8b)
-	    {
-	      bfd_put_8 (abfd, 0x8d, contents + irel->r_offset - 2);
-	      irel->r_info = ELF32_R_INFO (r_symndx, R_386_GOTOFF);
-	      if (local_got_refcounts != NULL
-		  && local_got_refcounts[r_symndx] > 0)
-		local_got_refcounts[r_symndx] -= 1;
-	      changed_contents = TRUE;
-	      changed_relocs = TRUE;
-	    }
-	  continue;
+	  /* STT_GNU_IFUNC must keep GOT32 relocations.  */
+	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
+	    continue;
+
+	  h = NULL;
+	  if (opcode == 0x0ff)
+	    /* Convert "call/jmp *foo@GOT[(%reg)]".  */
+	    goto convert_branch;
+	  else
+	    /* Convert "mov foo@GOT[(%reg1)], %reg2",
+	       "test %reg1, foo@GOT(%reg2)" and
+	       "binop foo@GOT[(%reg1)], %reg2". */
+	    goto convert_load;
 	}
 
       indx = r_symndx - symtab_hdr->sh_info;
@@ -2813,22 +2900,153 @@ elf_i386_convert_mov_to_lea (bfd *abfd, asection *sec,
 	     || h->root.type == bfd_link_hash_warning)
 	h = (struct elf_link_hash_entry *) h->root.u.i.link;
 
-      /* STT_GNU_IFUNC must keep R_386_GOT32 relocation.  We also avoid
-	 optimizing _DYNAMIC since ld.so may use its link-time address.  */
-      if ((h->root.type == bfd_link_hash_defined
-	   || h->root.type == bfd_link_hash_defweak)
-	  && h->type != STT_GNU_IFUNC
-	  && h != htab->elf.hdynamic
-	  && SYMBOL_REFERENCES_LOCAL (link_info, h)
-	  && irel->r_offset >= 2
-	  && bfd_get_8 (abfd, contents + irel->r_offset - 2) == 0x8b)
+      /* STT_GNU_IFUNC must keep GOT32 relocations.  */
+      if (h->type == STT_GNU_IFUNC)
+	continue;
+
+      if (opcode == 0xff)
 	{
-	  bfd_put_8 (abfd, 0x8d, contents + irel->r_offset - 2);
-	  irel->r_info = ELF32_R_INFO (r_symndx, R_386_GOTOFF);
-	  if (h->got.refcount > 0)
-	    h->got.refcount -= 1;
-	  changed_contents = TRUE;
-	  changed_relocs = TRUE;
+	  /* We have "call/jmp *foo@GOT[(%reg)]".  */
+	  if ((h->root.type == bfd_link_hash_defined
+	       || h->root.type == bfd_link_hash_defweak)
+	      && SYMBOL_REFERENCES_LOCAL (link_info, h))
+	    {
+	      /* The function is locally defined.   */
+convert_branch:
+	      addend = bfd_get_32 (abfd, contents + roff);
+	      /* Addend for R_386_GOT32X relocation must be 0.  */
+	      if (addend != 0)
+		continue;
+
+	      /* Convert R_386_GOT32X to R_386_PC32.  */
+	      if (modrm == 0x15 || (modrm & 0xf8) == 0x90)
+		{
+		  /* Convert to "nop call foo".  ADDR_PREFIX_OPCODE
+		     is a nop prefix.  */
+		  modrm = 0xe8;
+		  nop = link_info->call_nop_byte;
+		  if (link_info->call_nop_as_suffix)
+		    {
+		      nop_offset = roff + 3;
+		      irel->r_offset -= 1;
+		    }
+		  else
+		    nop_offset = roff - 2;
+		}
+	      else
+		{
+		  /* Convert to "jmp foo nop".  */
+		  modrm = 0xe9;
+		  nop = NOP_OPCODE;
+		  nop_offset = roff + 3;
+		  irel->r_offset -= 1;
+		}
+
+	      bfd_put_8 (abfd, nop, contents + nop_offset);
+	      bfd_put_8 (abfd, modrm, contents + irel->r_offset - 1);
+	      /* When converting to PC-relative relocation, we
+		 need to adjust addend by -4.  */
+	      bfd_put_32 (abfd, -4, contents + irel->r_offset);
+	      irel->r_info = ELF32_R_INFO (r_symndx, R_386_PC32);
+
+	      if (h)
+		{
+		  if (h->got.refcount > 0)
+		    h->got.refcount -= 1;
+		}
+	      else
+		{
+		  if (local_got_refcounts != NULL
+		      && local_got_refcounts[r_symndx] > 0)
+		    local_got_refcounts[r_symndx] -= 1;
+		}
+
+	      changed_contents = TRUE;
+	      changed_relocs = TRUE;
+	    }
+	}
+      else
+	{
+	  /* We have "mov foo@GOT[(%re1g)], %reg2",
+	     "test %reg1, foo@GOT(%reg2)" and
+	     "binop foo@GOT[(%reg1)], %reg2".
+
+	     Avoid optimizing _DYNAMIC since ld.so may use its
+	     link-time address.  */
+	  if (h == htab->elf.hdynamic)
+	    continue;
+
+	  if ((h->root.type == bfd_link_hash_defined
+	       || h->root.type == bfd_link_hash_defweak)
+	      && SYMBOL_REFERENCES_LOCAL (link_info, h))
+	    {
+convert_load:
+	      if (opcode == 0x8b)
+		{
+		  /* Convert "mov foo@GOT(%reg1), %reg2" to
+		     "lea foo@GOTOFF(%reg1), %reg2".  */
+		  if (r_type == R_386_GOT32X
+		      && (baseless || !bfd_link_pic (link_info)))
+		    {
+		      r_type = R_386_32;
+		      /* For R_386_32, convert
+			 "lea foo@GOTOFF(%reg1), %reg2" to
+			 "lea foo@GOT, %reg2".  */
+		      if (!baseless)
+			{
+			  modrm = 0x5 | (modrm & 0x38);
+			  bfd_put_8 (abfd, modrm, contents + roff - 1);
+			}
+		    }
+		  else
+		    r_type = R_386_GOTOFF;
+		  opcode = 0x8d;
+		}
+	      else
+		{
+		  /* Addend for R_386_GOT32X relocation must be 0.  */
+		  addend = bfd_get_32 (abfd, contents + roff);
+		  if (addend != 0)
+		    continue;
+
+		  if (opcode == 0x85)
+		    {
+		      /* Convert "test %reg1, foo@GOT(%reg2)" to
+			 "test $foo, %reg1".  */
+		      modrm = 0xc0 | (modrm & 0x38) >> 3;
+		      opcode = 0xf7;
+		    }
+		  else
+		    {
+		      /* Convert "binop foo@GOT(%reg1), %reg2" to
+			 "binop $foo, %reg2".  */
+		      modrm = (0xc0
+			       | (modrm & 0x38) >> 3
+			       | (opcode & 0x3c));
+		      opcode = 0x81;
+		    }
+		  bfd_put_8 (abfd, modrm, contents + roff - 1);
+		  r_type = R_386_32;
+		}
+
+	      bfd_put_8 (abfd, opcode, contents + roff - 2);
+	      irel->r_info = ELF32_R_INFO (r_symndx, r_type);
+
+	      if (h)
+		{
+		  if (h->got.refcount > 0)
+		    h->got.refcount -= 1;
+		}
+	      else
+		{
+		  if (local_got_refcounts != NULL
+		      && local_got_refcounts[r_symndx] > 0)
+		    local_got_refcounts[r_symndx] -= 1;
+		}
+
+	      changed_contents = TRUE;
+	      changed_relocs = TRUE;
+	    }
 	}
     }
 
@@ -2914,7 +3132,7 @@ elf_i386_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
 	{
 	  struct elf_dyn_relocs *p;
 
-	  if (!elf_i386_convert_mov_to_lea (ibfd, s, info))
+	  if (!elf_i386_convert_load (ibfd, s, info))
 	    return FALSE;
 
 	  for (p = ((struct elf_dyn_relocs *)
@@ -3664,6 +3882,7 @@ elf_i386_relocate_section (bfd *output_bfd,
 	      goto do_relocation;
 
 	    case R_386_GOT32:
+	    case R_386_GOT32X:
 	      base_got = htab->elf.sgot;
 	      off = h->got.offset;
 
@@ -3741,7 +3960,61 @@ elf_i386_relocate_section (bfd *output_bfd,
       eh = (struct elf_i386_link_hash_entry *) h;
       switch (r_type)
 	{
+	case R_386_GOT32X:
+	  /* Avoid optimizing _DYNAMIC since ld.so may use its
+	     link-time address.  */
+	  if (h == htab->elf.hdynamic)
+	    goto r_386_got32;
+
+	  if (bfd_link_pic (info))
+	    {
+	      /* It is OK to convert mov to lea and convert indirect
+		 branch to direct branch.  It is OK to convert adc,
+		 add, and, cmp, or, sbb, sub, test, xor only when PIC
+		 is false.   */
+	      unsigned int opcode;
+	      opcode = bfd_get_8 (abfd, contents + rel->r_offset - 2);
+	      if (opcode != 0x8b && opcode != 0xff)
+		goto r_386_got32;
+	    }
+
+	  /* Resolve "mov GOT[(%reg)], %reg",
+	     "call/jmp *GOT[(%reg)]", "test %reg, foo@GOT[(%reg)]"
+	     and "binop foo@GOT[(%reg)], %reg".  */
+	  if (h == NULL
+	      || (h->plt.offset == (bfd_vma) -1
+		  && h->got.offset == (bfd_vma) -1)
+	      || htab->elf.sgotplt == NULL)
+	    abort ();
+
+	  offplt = (htab->elf.sgotplt->output_section->vma
+		    + htab->elf.sgotplt->output_offset);
+
+	  /* It is relative to .got.plt section.  */
+	  if (h->got.offset != (bfd_vma) -1)
+	    /* Use GOT entry.  */
+	    relocation = (htab->elf.sgot->output_section->vma
+			  + htab->elf.sgot->output_offset
+			  + h->got.offset - offplt);
+	  else
+	    /* Use GOTPLT entry.  */
+	    relocation = (h->plt.offset / plt_entry_size - 1 + 3) * 4;
+
+	  if (!bfd_link_pic (info))
+	    {
+	      /* If not PIC, add the .got.plt section address for
+		 baseless adressing.  */
+	      unsigned int modrm;
+	      modrm = bfd_get_8 (abfd, contents + rel->r_offset - 1);
+	      if ((modrm & 0xc7) == 0x5)
+		relocation += offplt;
+	    }
+
+	  unresolved_reloc = FALSE;
+	  break;
+
 	case R_386_GOT32:
+r_386_got32:
 	  /* Relocation is to the entry for this symbol in the global
 	     offset table.  */
 	  if (htab->elf.sgot == NULL)
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index dc5fd0d..f864834 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -31,6 +31,7 @@
 #include "dwarf2.h"
 #include "libiberty.h"
 
+#include "opcode/i386.h"
 #include "elf/x86-64.h"
 
 #ifdef CORE_HEADER
@@ -176,12 +177,18 @@ static reloc_howto_type x86_64_elf_howto_table[] =
   HOWTO(R_X86_64_PLT32_BND, 0, 2, 32, TRUE, 0, complain_overflow_signed,
 	bfd_elf_generic_reloc, "R_X86_64_PLT32_BND", FALSE, 0xffffffff, 0xffffffff,
 	TRUE),
+  HOWTO(R_X86_64_GOTPCRELX, 0, 2, 32, TRUE, 0, complain_overflow_signed,
+	bfd_elf_generic_reloc, "R_X86_64_GOTPCRELX", FALSE, 0xffffffff,
+	0xffffffff, TRUE),
+  HOWTO(R_X86_64_REX_GOTPCRELX, 0, 2, 32, TRUE, 0, complain_overflow_signed,
+	bfd_elf_generic_reloc, "R_X86_64_REX_GOTPCRELX", FALSE, 0xffffffff,
+	0xffffffff, TRUE),
 
   /* We have a gap in the reloc numbers here.
      R_X86_64_standard counts the number up to this point, and
      R_X86_64_vt_offset is the value to subtract from a reloc type of
      R_X86_64_GNU_VT* to form an index into this table.  */
-#define R_X86_64_standard (R_X86_64_PLT32_BND + 1)
+#define R_X86_64_standard (R_X86_64_REX_GOTPCRELX + 1)
 #define R_X86_64_vt_offset (R_X86_64_GNU_VTINHERIT - R_X86_64_standard)
 
 /* GNU extension to record C++ vtable hierarchy.  */
@@ -253,8 +260,10 @@ static const struct elf_reloc_map x86_64_reloc_map[] =
   { BFD_RELOC_X86_64_TLSDESC_CALL, R_X86_64_TLSDESC_CALL, },
   { BFD_RELOC_X86_64_TLSDESC,	R_X86_64_TLSDESC, },
   { BFD_RELOC_X86_64_IRELATIVE,	R_X86_64_IRELATIVE, },
-  { BFD_RELOC_X86_64_PC32_BND,	R_X86_64_PC32_BND,},
-  { BFD_RELOC_X86_64_PLT32_BND,	R_X86_64_PLT32_BND,},
+  { BFD_RELOC_X86_64_PC32_BND,	R_X86_64_PC32_BND, },
+  { BFD_RELOC_X86_64_PLT32_BND,	R_X86_64_PLT32_BND, },
+  { BFD_RELOC_X86_64_GOTPCRELX, R_X86_64_GOTPCRELX, },
+  { BFD_RELOC_X86_64_REX_GOTPCRELX, R_X86_64_REX_GOTPCRELX, },
   { BFD_RELOC_VTABLE_INHERIT,	R_X86_64_GNU_VTINHERIT, },
   { BFD_RELOC_VTABLE_ENTRY,	R_X86_64_GNU_VTENTRY, },
 };
@@ -1545,7 +1554,7 @@ elf_x86_64_tls_transition (struct bfd_link_info *info, bfd *abfd,
 
 /* Rename some of the generic section flags to better document how they
    are used here.  */
-#define need_convert_mov_to_lea sec_flg0
+#define need_convert_load sec_flg0
 
 /* Look through the relocs for a section during the first phase, and
    calculate needed space in the global offset table, procedure
@@ -1726,6 +1735,8 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	    case R_X86_64_32S:
 	    case R_X86_64_PC64:
 	    case R_X86_64_GOTPCREL:
+	    case R_X86_64_GOTPCRELX:
+	    case R_X86_64_REX_GOTPCRELX:
 	    case R_X86_64_GOTPCREL64:
 	      if (htab->elf.dynobj == NULL)
 		htab->elf.dynobj = abfd;
@@ -1779,6 +1790,8 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,
 
 	case R_X86_64_GOT32:
 	case R_X86_64_GOTPCREL:
+	case R_X86_64_GOTPCRELX:
+	case R_X86_64_REX_GOTPCRELX:
 	case R_X86_64_TLSGD:
 	case R_X86_64_GOT64:
 	case R_X86_64_GOTPCREL64:
@@ -2151,9 +2164,11 @@ do_size:
 	    return FALSE;
 	}
 
-      if (r_type == R_X86_64_GOTPCREL
+      if ((r_type == R_X86_64_GOTPCREL
+	   || r_type == R_X86_64_GOTPCRELX
+	   || r_type == R_X86_64_REX_GOTPCRELX)
 	  && (h == NULL || h->type != STT_GNU_IFUNC))
-	sec->need_convert_mov_to_lea = 1;
+	sec->need_convert_load = 1;
     }
 
   return TRUE;
@@ -2279,6 +2294,8 @@ elf_x86_64_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
 	case R_X86_64_GOTTPOFF:
 	case R_X86_64_GOT32:
 	case R_X86_64_GOTPCREL:
+	case R_X86_64_GOTPCRELX:
+	case R_X86_64_REX_GOTPCRELX:
 	case R_X86_64_GOT64:
 	case R_X86_64_GOTPCREL64:
 	case R_X86_64_GOTPLT64:
@@ -2953,15 +2970,28 @@ elf_x86_64_readonly_dynrelocs (struct elf_link_hash_entry *h,
   return TRUE;
 }
 
-/* Convert
+/* With the local symbol, foo, we convert
    mov foo@GOTPCREL(%rip), %reg
    to
    lea foo(%rip), %reg
-   with the local symbol, foo.  */
+   and convert
+   call/jmp *foo@GOTPCREL(%rip)
+   to
+   nop call foo/jmp foo nop
+   When PIC is false, convert
+   test %reg, foo@GOTPCREL(%rip)
+   to
+   test $foo, %reg
+   and convert
+   binop foo@GOTPCREL(%rip), %reg
+   to
+   binop $foo, %reg
+   where binop is one of adc, add, and, cmp, or, sbb, sub, xor
+   instructions.  */
 
 static bfd_boolean
-elf_x86_64_convert_mov_to_lea (bfd *abfd, asection *sec,
-			       struct bfd_link_info *link_info)
+elf_x86_64_convert_load (bfd *abfd, asection *sec,
+			 struct bfd_link_info *link_info)
 {
   Elf_Internal_Shdr *symtab_hdr;
   Elf_Internal_Rela *internal_relocs;
@@ -2979,7 +3009,7 @@ elf_x86_64_convert_mov_to_lea (bfd *abfd, asection *sec,
 
   /* Nothing to do if there is no need or no output.  */
   if ((sec->flags & (SEC_CODE | SEC_RELOC)) != (SEC_CODE | SEC_RELOC)
-      || sec->need_convert_mov_to_lea == 0
+      || sec->need_convert_load == 0
       || bfd_is_abs_section (sec->output_section))
     return TRUE;
 
@@ -3017,22 +3047,45 @@ elf_x86_64_convert_mov_to_lea (bfd *abfd, asection *sec,
       asection *tsec;
       char symtype;
       bfd_vma toff, roff;
+      bfd_signed_vma raddend;
       unsigned int opcode;
+      unsigned int modrm;
 
-      if (r_type != R_X86_64_GOTPCREL)
+      if (r_type != R_X86_64_GOTPCREL
+	  && r_type != R_X86_64_GOTPCRELX
+	  && r_type != R_X86_64_REX_GOTPCRELX)
 	continue;
 
       roff = irel->r_offset;
+      if (roff < (r_type == R_X86_64_REX_GOTPCRELX ? 3 : 2))
+	continue;
 
-      if (roff < 2)
+      raddend = irel->r_addend;
+      /* Addend for 32-bit PC-relative relocation must be -4.  */
+      if (raddend != -4)
 	continue;
 
       opcode = bfd_get_8 (abfd, contents + roff - 2);
 
-      /* PR ld/18591: Don't convert R_X86_64_GOTPCREL relocation if it
-         isn't for mov instruction.  */
+      /* It is OK to convert mov to lea.  */
       if (opcode != 0x8b)
-	continue;
+	{
+	  /* Only convert R_X86_64_GOTPCRELX and R_X86_64_REX_GOTPCRELX
+	     for mov call, jmp or one of adc, add, and, cmp, or, sbb,
+	     sub, test, xor instructions.  */
+	  if (r_type != R_X86_64_GOTPCRELX
+	      && r_type != R_X86_64_REX_GOTPCRELX)
+	    continue;
+
+	  /* It is OK to convert indirect branch to direct branch.  */
+	  if (opcode != 0xff)
+	    {
+	      /* It is OK to convert adc, add, and, cmp, or, sbb, sub,
+		 test, xor only when PIC is false.   */
+	      if (bfd_link_pic (link_info))
+		continue;
+	    }
+	}
 
       /* Get the symbol referred to by the reloc.  */
       if (r_symndx < symtab_hdr->sh_info)
@@ -3044,8 +3097,8 @@ elf_x86_64_convert_mov_to_lea (bfd *abfd, asection *sec,
 
 	  symtype = ELF_ST_TYPE (isym->st_info);
 
-	  /* STT_GNU_IFUNC must keep R_X86_64_GOTPCREL relocation and
-	     skip relocation against undefined symbols.  */
+	  /* STT_GNU_IFUNC must keep GOTPCREL relocations and skip
+	     relocation against undefined symbols.  */
 	  if (symtype == STT_GNU_IFUNC || isym->st_shndx == SHN_UNDEF)
 	    continue;
 
@@ -3071,9 +3124,9 @@ elf_x86_64_convert_mov_to_lea (bfd *abfd, asection *sec,
 		 || h->root.type == bfd_link_hash_warning)
 	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
 
-	  /* STT_GNU_IFUNC must keep R_X86_64_GOTPCREL relocation.  We also
-	     avoid optimizing _DYNAMIC since ld.so may use its link-time
-	     address.  */
+	  /* STT_GNU_IFUNC must keep GOTPCREL relocations.  We also
+	     avoid optimizing GOTPCREL relocations againt _DYNAMIC
+	     since ld.so may use its link-time address.  */
 	  if ((h->root.type == bfd_link_hash_defined
 	       || h->root.type == bfd_link_hash_defweak)
 	      && h->type != STT_GNU_IFUNC
@@ -3107,17 +3160,17 @@ elf_x86_64_convert_mov_to_lea (bfd *abfd, asection *sec,
 	     access is presumed to be an offset from "sym";  The
 	     location of interest is just "sym".  */
 	   if (symtype == STT_SECTION)
-	     toff += irel->r_addend;
+	     toff += raddend;
 
 	   toff = _bfd_merged_section_offset (abfd, &tsec,
 					      elf_section_data (tsec)->sec_info,
 					      toff);
 
 	   if (symtype != STT_SECTION)
-	     toff += irel->r_addend;
+	     toff += raddend;
 	}
       else
-	toff += irel->r_addend;
+	toff += raddend;
 
       /* Don't convert if R_X86_64_PC32 relocation overflows.  */
       if (tsec->output_section == sec->output_section)
@@ -3148,8 +3201,8 @@ elf_x86_64_convert_mov_to_lea (bfd *abfd, asection *sec,
 		}
 	    }
 
-	  /* Don't convert R_X86_64_GOTPCREL if TSEC isn't placed after
-	     SEC.  */
+	  /* Don't convert GOTPCREL relocations if TSEC isn't placed
+	     after SEC.  */
 	  if (asect == NULL)
 	    continue;
 
@@ -3160,8 +3213,90 @@ elf_x86_64_convert_mov_to_lea (bfd *abfd, asection *sec,
 	    continue;
 	}
 
-      bfd_put_8 (abfd, 0x8d, contents + roff - 2);
-      irel->r_info = htab->r_info (r_symndx, R_X86_64_PC32);
+      if (opcode == 0xff)
+	{
+	  /* We have "call/jmp *foo@GOTPCREL(%rip)".  */
+	  unsigned int nop;
+	  unsigned int disp;
+	  bfd_vma nop_offset;
+
+	  /* Convert R_X86_64_GOTPCRELX and R_X86_64_REX_GOTPCRELX to
+	     R_X86_64_PC32.  */
+	  modrm = bfd_get_8 (abfd, contents + roff - 1);
+	  if (modrm == 0x25)
+	    {
+	      /* Convert to "jmp foo nop".  */
+	      modrm = 0xe9;
+	      nop = NOP_OPCODE;
+	      nop_offset = irel->r_offset + 3;
+	      disp = bfd_get_32 (abfd, contents + irel->r_offset);
+	      irel->r_offset -= 1;
+	      bfd_put_32 (abfd, disp, contents + irel->r_offset);
+	    }
+	  else
+	    {
+	      /* Convert to "nop call foo".  ADDR_PREFIX_OPCODE
+		 is a nop prefix.  */
+	      modrm = 0xe8;
+	      nop = link_info->call_nop_byte;
+	      if (link_info->call_nop_as_suffix)
+		{
+		  nop_offset = irel->r_offset + 3;
+		  disp = bfd_get_32 (abfd, contents + irel->r_offset);
+		  irel->r_offset -= 1;
+		  bfd_put_32 (abfd, disp, contents + irel->r_offset);
+		}
+	      else
+		nop_offset = irel->r_offset - 2;
+	    }
+	  bfd_put_8 (abfd, nop, contents + nop_offset);
+	  bfd_put_8 (abfd, modrm, contents + irel->r_offset - 1);
+	  r_type = R_X86_64_PC32;
+	}
+      else
+	{
+	  if (opcode == 0x8b)
+	    {
+	      /* Convert "mov foo@GOTPCREL(%rip), %reg" to
+		 "lea foo(%rip), %reg".  */
+	      opcode = 0x8d;
+	      r_type = R_X86_64_PC32;
+	    }
+	  else
+	    {
+	      modrm = bfd_get_8 (abfd, contents + roff - 1);
+	      if (opcode == 0x85)
+		{
+		  /* Convert "test %reg, foo@GOTPCREL(%rip)" to
+		     "test $foo, %reg".  */
+		  modrm = 0xc0 | (modrm & 0x38) >> 3;
+		  opcode = 0xf7;
+		}
+	      else
+		{
+		  /* Convert "binop foo@GOTPCREL(%rip), %reg" to
+		     "binop $foo, %reg".  */
+		  modrm = 0xc0 | (modrm & 0x38) >> 3 | (opcode & 0x3c);
+		  opcode = 0x81;
+		}
+	      bfd_put_8 (abfd, modrm, contents + roff - 1);
+
+	      if (r_type == R_X86_64_REX_GOTPCRELX)
+		{
+		  /* Move the R bit to the B bit in REX byte.  */
+		  unsigned int rex = bfd_get_8 (abfd, contents + roff - 3);
+		  rex = (rex & ~REX_R) | (rex & REX_R) >> 2;
+		  bfd_put_8 (abfd, rex, contents + roff - 3);
+		}
+	      /* No addend for R_X86_64_32S relocation.  */
+	      irel->r_addend = 0;
+	      r_type = R_X86_64_32S;
+	    }
+
+	  bfd_put_8 (abfd, opcode, contents + roff - 2);
+	}
+
+      irel->r_info = htab->r_info (r_symndx, r_type);
       changed_contents = TRUE;
       changed_relocs = TRUE;
 
@@ -3264,7 +3399,7 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
 	{
 	  struct elf_dyn_relocs *p;
 
-	  if (!elf_x86_64_convert_mov_to_lea (ibfd, s, info))
+	  if (!elf_x86_64_convert_load (ibfd, s, info))
 	    return FALSE;
 
 	  for (p = (struct elf_dyn_relocs *)
@@ -3985,6 +4120,8 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 	      goto do_relocation;
 
 	    case R_X86_64_GOTPCREL:
+	    case R_X86_64_GOTPCRELX:
+	    case R_X86_64_REX_GOTPCRELX:
 	    case R_X86_64_GOTPCREL64:
 	      base_got = htab->elf.sgot;
 	      off = h->got.offset;
@@ -4053,6 +4190,8 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 	  /* Relocation is to the entry for this symbol in the global
 	     offset table.  */
 	case R_X86_64_GOTPCREL:
+	case R_X86_64_GOTPCRELX:
+	case R_X86_64_REX_GOTPCRELX:
 	case R_X86_64_GOTPCREL64:
 	  /* Use global offset table entry as symbol value.  */
 	case R_X86_64_GOTPLT64:
@@ -4158,7 +4297,10 @@ elf_x86_64_relocate_section (bfd *output_bfd,
 
 	  relocation = base_got->output_section->vma
 		       + base_got->output_offset + off;
-	  if (r_type != R_X86_64_GOTPCREL && r_type != R_X86_64_GOTPCREL64)
+	  if (r_type != R_X86_64_GOTPCREL
+	      && r_type != R_X86_64_GOTPCRELX
+	      && r_type != R_X86_64_REX_GOTPCRELX
+	      && r_type != R_X86_64_GOTPCREL64)
 	    relocation -= htab->elf.sgotplt->output_section->vma
 			  - htab->elf.sgotplt->output_offset;
 
diff --git a/bfd/libbfd.h b/bfd/libbfd.h
index 9ae9ba2..57300e9 100644
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -1292,6 +1292,7 @@ static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
   "BFD_RELOC_386_TLS_DESC_CALL",
   "BFD_RELOC_386_TLS_DESC",
   "BFD_RELOC_386_IRELATIVE",
+  "BFD_RELOC_386_GOT32X",
   "BFD_RELOC_X86_64_GOT32",
   "BFD_RELOC_X86_64_PLT32",
   "BFD_RELOC_X86_64_COPY",
@@ -1321,6 +1322,8 @@ static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
   "BFD_RELOC_X86_64_IRELATIVE",
   "BFD_RELOC_X86_64_PC32_BND",
   "BFD_RELOC_X86_64_PLT32_BND",
+  "BFD_RELOC_X86_64_GOTPCRELX",
+  "BFD_RELOC_X86_64_REX_GOTPCRELX",
   "BFD_RELOC_NS32K_IMM_8",
   "BFD_RELOC_NS32K_IMM_16",
   "BFD_RELOC_NS32K_IMM_32",
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 886c63e..aa3d24f 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -2676,6 +2676,8 @@ ENUMX
   BFD_RELOC_386_TLS_DESC
 ENUMX
   BFD_RELOC_386_IRELATIVE
+ENUMX
+  BFD_RELOC_386_GOT32X
 ENUMDOC
   i386/elf relocations
 
@@ -2737,6 +2739,10 @@ ENUMX
   BFD_RELOC_X86_64_PC32_BND
 ENUMX
   BFD_RELOC_X86_64_PLT32_BND
+ENUMX
+  BFD_RELOC_X86_64_GOTPCRELX
+ENUMX
+  BFD_RELOC_X86_64_REX_GOTPCRELX
 ENUMDOC
   x86-64/elf relocations
 
diff --git a/elfcpp/i386.h b/elfcpp/i386.h
index 16fdef8..9d57a0f 100644
--- a/elfcpp/i386.h
+++ b/elfcpp/i386.h
@@ -86,6 +86,7 @@ enum
   R_386_TLS_DESC = 41,      // TLS descriptor containing pointer to code and
                             // to argument, returning TLS offset for symbol
   R_386_IRELATIVE = 42,     // Adjust indirectly by program base
+  R_386_GOT32X = 43,        // 32 bit GOT entry, relaxable
   // Used by Intel.
   R_386_USED_BY_INTEL_200 = 200,
   // GNU vtable garbage collection extensions.
diff --git a/elfcpp/x86_64.h b/elfcpp/x86_64.h
index e97ff52..52cb9ae 100644
--- a/elfcpp/x86_64.h
+++ b/elfcpp/x86_64.h
@@ -94,6 +94,10 @@ enum
   R_X86_64_RELATIVE64 = 38,      // 64-bit adjust by program base
   R_X86_64_PC32_BND = 39,  // PC relative 32 bit signed with BND prefix
   R_X86_64_PLT32_BND = 40, // 32 bit PLT address with BND prefix
+  R_X86_64_GOTPCRELX = 41, // 32 bit signed PC relative offset to GOT
+			   // without REX prefix, relaxable.
+  R_X86_64_REX_GOTPCRELX = 42, // 32 bit signed PC relative offset to GOT
+			       // with REX prefix, relaxable.
   // GNU vtable garbage collection extensions.
   R_X86_64_GNU_VTINHERIT = 250,
   R_X86_64_GNU_VTENTRY = 251
diff --git a/gas/config/tc-i386.c b/gas/config/tc-i386.c
index 13f1d27..ed49ab8 100644
--- a/gas/config/tc-i386.c
+++ b/gas/config/tc-i386.c
@@ -2934,6 +2934,7 @@ tc_i386_fix_adjustable (fixS *fixP ATTRIBUTE_UNUSED)
       || fixP->fx_r_type == BFD_RELOC_386_GOTOFF
       || fixP->fx_r_type == BFD_RELOC_386_PLT32
       || fixP->fx_r_type == BFD_RELOC_386_GOT32
+      || fixP->fx_r_type == BFD_RELOC_386_GOT32X
       || fixP->fx_r_type == BFD_RELOC_386_TLS_GD
       || fixP->fx_r_type == BFD_RELOC_386_TLS_LDM
       || fixP->fx_r_type == BFD_RELOC_386_TLS_LDO_32
@@ -2947,6 +2948,8 @@ tc_i386_fix_adjustable (fixS *fixP ATTRIBUTE_UNUSED)
       || fixP->fx_r_type == BFD_RELOC_X86_64_PLT32
       || fixP->fx_r_type == BFD_RELOC_X86_64_GOT32
       || fixP->fx_r_type == BFD_RELOC_X86_64_GOTPCREL
+      || fixP->fx_r_type == BFD_RELOC_X86_64_GOTPCRELX
+      || fixP->fx_r_type == BFD_RELOC_X86_64_REX_GOTPCRELX
       || fixP->fx_r_type == BFD_RELOC_X86_64_TLSGD
       || fixP->fx_r_type == BFD_RELOC_X86_64_TLSLD
       || fixP->fx_r_type == BFD_RELOC_X86_64_DTPOFF32
@@ -4797,6 +4800,10 @@ match_template (void)
 	    }
 	  }
 
+      /* Force 0x8b encoding for "mov foo@GOT, %eax".  */
+      if (i.reloc[0] == BFD_RELOC_386_GOT32 && t->base_opcode == 0xa0)
+	continue;
+
       /* We check register size if needed.  */
       check_register = t->opcode_modifier.checkregsize;
       overlap0 = operand_type_and (i.types[0], operand_types[0]);
@@ -7163,6 +7170,7 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)
 	      int size = disp_size (n);
 	      int sign = i.types[n].bitfield.disp32s;
 	      int pcrel = (i.flags[n] & Operand_PCrel) != 0;
+	      fixS *fixP;
 
 	      /* We can't have 8 bit displacement here.  */
 	      gas_assert (!i.types[n].bitfield.disp8);
@@ -7231,8 +7239,34 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)
 		       insn, and that is taken care of in other code.  */
 		    reloc_type = BFD_RELOC_X86_64_GOTPC32;
 		}
-	      fix_new_exp (frag_now, p - frag_now->fr_literal, size,
-			   i.op[n].disps, pcrel, reloc_type);
+	      fixP = fix_new_exp (frag_now, p - frag_now->fr_literal,
+				  size, i.op[n].disps, pcrel,
+				  reloc_type);
+	      /* Check for "call/jmp *mem", "mov mem, %reg",
+		 "test %reg, mem" and "binop mem, %reg" where binop
+		 is one of adc, add, and, cmp, or, sbb, sub, xor
+		 instructions.  */
+	      if ((i.rm.mode == 2
+		   || (i.rm.mode == 0 && i.rm.regmem == 5))
+		  && ((i.operands == 1
+		       && i.tm.base_opcode == 0xff
+		       && (i.rm.reg == 2 || i.rm.reg == 4))
+		      || (i.operands == 2
+			  && (i.tm.base_opcode == 0x8b
+			      || i.tm.base_opcode == 0x85
+			      || (i.tm.base_opcode & 0xc7) == 0x03))))
+		{
+		  if (object_64bit)
+		    {
+		      fixP->fx_tcbit = i.rex != 0;
+		      if (i.base_reg
+			  && (i.base_reg->reg_num == RegRip
+			      || i.base_reg->reg_num == RegEip))
+		      fixP->fx_tcbit2 = 1;
+		    }
+		  else
+		    fixP->fx_tcbit2 = 1;
+		}
 	    }
 	}
     }
@@ -10327,23 +10361,41 @@ s_bss (int ignore ATTRIBUTE_UNUSED)
 void
 i386_validate_fix (fixS *fixp)
 {
-  if (fixp->fx_subsy && fixp->fx_subsy == GOT_symbol)
+  if (fixp->fx_subsy)
     {
-      if (fixp->fx_r_type == BFD_RELOC_32_PCREL)
-	{
-	  if (!object_64bit)
-	    abort ();
-	  fixp->fx_r_type = BFD_RELOC_X86_64_GOTPCREL;
-	}
-      else
+      if (fixp->fx_subsy == GOT_symbol)
 	{
-	  if (!object_64bit)
-	    fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
+	  if (fixp->fx_r_type == BFD_RELOC_32_PCREL)
+	    {
+	      if (!object_64bit)
+		abort ();
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+	      if (fixp->fx_tcbit2)
+		fixp->fx_r_type = (fixp->fx_tcbit
+				   ? BFD_RELOC_X86_64_REX_GOTPCRELX
+				   : BFD_RELOC_X86_64_GOTPCRELX);
+	      else
+#endif
+		fixp->fx_r_type = BFD_RELOC_X86_64_GOTPCREL;
+	    }
 	  else
-	    fixp->fx_r_type = BFD_RELOC_X86_64_GOTOFF64;
+	    {
+	      if (!object_64bit)
+		fixp->fx_r_type = BFD_RELOC_386_GOTOFF;
+	      else
+		fixp->fx_r_type = BFD_RELOC_X86_64_GOTOFF64;
+	    }
+	  fixp->fx_subsy = 0;
 	}
-      fixp->fx_subsy = 0;
     }
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
+  else if (!object_64bit)
+    {
+      if (fixp->fx_r_type == BFD_RELOC_386_GOT32
+	  && fixp->fx_tcbit2)
+	fixp->fx_r_type = BFD_RELOC_386_GOT32X;
+    }
+#endif
 }
 
 arelent *
@@ -10377,8 +10429,11 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
     case BFD_RELOC_X86_64_PLT32:
     case BFD_RELOC_X86_64_GOT32:
     case BFD_RELOC_X86_64_GOTPCREL:
+    case BFD_RELOC_X86_64_GOTPCRELX:
+    case BFD_RELOC_X86_64_REX_GOTPCRELX:
     case BFD_RELOC_386_PLT32:
     case BFD_RELOC_386_GOT32:
+    case BFD_RELOC_386_GOT32X:
     case BFD_RELOC_386_GOTOFF:
     case BFD_RELOC_386_GOTPC:
     case BFD_RELOC_386_TLS_GD:
@@ -10530,6 +10585,8 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
 	  case BFD_RELOC_X86_64_PLT32:
 	  case BFD_RELOC_X86_64_GOT32:
 	  case BFD_RELOC_X86_64_GOTPCREL:
+	  case BFD_RELOC_X86_64_GOTPCRELX:
+	  case BFD_RELOC_X86_64_REX_GOTPCRELX:
 	  case BFD_RELOC_X86_64_TLSGD:
 	  case BFD_RELOC_X86_64_TLSLD:
 	  case BFD_RELOC_X86_64_GOTTPOFF:
diff --git a/gas/config/tc-i386.h b/gas/config/tc-i386.h
index 40483a1..2c43044 100644
--- a/gas/config/tc-i386.h
+++ b/gas/config/tc-i386.h
@@ -170,11 +170,12 @@ extern int tc_i386_fix_adjustable (struct fix *);
    the .o file.  GOTOFF and GOT32 do not need to be checked here because
    they are not pcrel.  .*/
 
-#define TC_FORCE_RELOCATION_LOCAL(FIX)			\
-  (!(FIX)->fx_pcrel					\
-   || (FIX)->fx_r_type == BFD_RELOC_386_PLT32		\
-   || (FIX)->fx_r_type == BFD_RELOC_386_GOTPC		\
-   || (FIX)->fx_r_type == BFD_RELOC_X86_64_GOTPCREL	\
+#define TC_FORCE_RELOCATION_LOCAL(FIX)				\
+  (!(FIX)->fx_pcrel						\
+   || (FIX)->fx_r_type == BFD_RELOC_386_PLT32			\
+   || (FIX)->fx_r_type == BFD_RELOC_386_GOTPC			\
+   || (FIX)->fx_r_type == BFD_RELOC_X86_64_GOTPCRELX		\
+   || (FIX)->fx_r_type == BFD_RELOC_X86_64_REX_GOTPCRELX	\
    || TC_FORCE_RELOCATION (FIX))
 
 extern int i386_parse_name (char *, expressionS *, char *);
diff --git a/gas/testsuite/gas/i386/got.d b/gas/testsuite/gas/i386/got.d
new file mode 100644
index 0000000..f76ca47
--- /dev/null
+++ b/gas/testsuite/gas/i386/got.d
@@ -0,0 +1,29 @@
+#objdump: -dwr
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+0+ <_start>:
+[ 	]*[a-f0-9]+:	b8 00 00 00 00       	mov    \$0x0,%eax	1: R_386_GOT32	foo
+[ 	]*[a-f0-9]+:	8b 05 00 00 00 00    	mov    0x0,%eax	7: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	8b 80 00 00 00 00    	mov    0x0\(%eax\),%eax	d: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	05 00 00 00 00       	add    \$0x0,%eax	12: R_386_GOT32	foo
+[ 	]*[a-f0-9]+:	03 05 00 00 00 00    	add    0x0,%eax	18: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	03 80 00 00 00 00    	add    0x0\(%eax\),%eax	1e: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	ff 15 00 00 00 00    	call   \*0x0	24: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	ff 90 00 00 00 00    	call   \*0x0\(%eax\)	2a: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	ff 25 00 00 00 00    	jmp    \*0x0	30: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	ff a0 00 00 00 00    	jmp    \*0x0\(%eax\)	36: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	b8 00 00 00 00       	mov    \$0x0,%eax	3b: R_386_GOT32	foo
+[ 	]*[a-f0-9]+:	8b 05 00 00 00 00    	mov    0x0,%eax	41: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	8b 80 00 00 00 00    	mov    0x0\(%eax\),%eax	47: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	05 00 00 00 00       	add    \$0x0,%eax	4c: R_386_GOT32	foo
+[ 	]*[a-f0-9]+:	03 05 00 00 00 00    	add    0x0,%eax	52: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	03 80 00 00 00 00    	add    0x0\(%eax\),%eax	58: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	ff 90 00 00 00 00    	call   \*0x0\(%eax\)	5e: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	ff 15 00 00 00 00    	call   \*0x0	64: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	ff a0 00 00 00 00    	jmp    \*0x0\(%eax\)	6a: R_386_GOT32X	foo
+[ 	]*[a-f0-9]+:	ff 25 00 00 00 00    	jmp    \*0x0	70: R_386_GOT32X	foo
+#pass
diff --git a/gas/testsuite/gas/i386/got.s b/gas/testsuite/gas/i386/got.s
new file mode 100644
index 0000000..10fa881
--- /dev/null
+++ b/gas/testsuite/gas/i386/got.s
@@ -0,0 +1,29 @@
+	.text
+_start:
+	movl	$foo@GOT, %eax
+	movl	foo@GOT, %eax
+	movl	foo@GOT(%eax), %eax
+
+	addl	$foo@GOT, %eax
+	addl	foo@GOT, %eax
+	addl	foo@GOT(%eax), %eax
+
+	call	*foo@GOT
+	call	*foo@GOT(%eax)
+	jmp	*foo@GOT
+	jmp	*foo@GOT(%eax)
+
+	.intel_syntax noprefix
+
+	mov	eax, offset foo@got
+	mov	eax, DWORD PTR [foo@GOT]
+	mov	eax, DWORD PTR [eax + foo@GOT]
+
+	add	eax, offset foo@got
+	add	eax, DWORD PTR [foo@GOT]
+	add	eax, DWORD PTR [eax + foo@GOT]
+
+	call	DWORD PTR [eax + foo@GOT]
+	call	DWORD PTR [foo@GOT]
+	jmp	DWORD PTR [eax + foo@GOT]
+	jmp	DWORD PTR [foo@GOT]
diff --git a/gas/testsuite/gas/i386/i386.exp b/gas/testsuite/gas/i386/i386.exp
index f59b598..1739ba9 100644
--- a/gas/testsuite/gas/i386/i386.exp
+++ b/gas/testsuite/gas/i386/i386.exp
@@ -404,6 +404,8 @@ if [expr ([istarget "i*86-*-*"] ||  [istarget "x86_64-*-*"]) && [gas_32_check]]
 	run_dump_test "relax-3"
 	run_dump_test "relax-4"
 
+	run_dump_test "got"
+
 	if {![istarget "*-*-nacl*"]} then {
 	    run_dump_test "iamcu-1"
 	    run_dump_test "iamcu-2"
@@ -778,6 +780,8 @@ if [expr ([istarget "i*86-*-*"] || [istarget "x86_64-*-*"]) && [gas_64_check]] t
 	run_dump_test "x86-64-jump"
 	run_dump_test "x86-64-branch-2"
 	run_list_test "x86-64-branch-3" "-al -mintel64"
+
+	run_dump_test "x86-64-gotpcrel"
     }
 
     set ASFLAGS "$old_ASFLAGS"
diff --git a/gas/testsuite/gas/i386/ilp32/x86-64-gotpcrel.d b/gas/testsuite/gas/i386/ilp32/x86-64-gotpcrel.d
new file mode 100644
index 0000000..e5a3b1c
--- /dev/null
+++ b/gas/testsuite/gas/i386/ilp32/x86-64-gotpcrel.d
@@ -0,0 +1,27 @@
+#source: ../x86-64-gotpcrel.s
+#objdump: -dwr
+#name: x86-64 (ILP32) gotpcrel
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+0+ <_start>:
+[ 	]*[a-f0-9]+:	48 c7 c0 00 00 00 00 	mov    \$0x0,%rax	3: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 8b 04 25 00 00 00 00 	mov    0x0,%rax	b: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 8b 05 00 00 00 00 	mov    0x0\(%rip\),%rax        # 16 <_start\+0x16>	12: R_X86_64_REX_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	48 8b 81 00 00 00 00 	mov    0x0\(%rcx\),%rax	19: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	ff 15 00 00 00 00    	callq  \*0x0\(%rip\)        # 23 <_start\+0x23>	1f: R_X86_64_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	ff 90 00 00 00 00    	callq  \*0x0\(%rax\)	25: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	ff 25 00 00 00 00    	jmpq   \*0x0\(%rip\)        # 2f <_start\+0x2f>	2b: R_X86_64_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	ff a1 00 00 00 00    	jmpq   \*0x0\(%rcx\)	31: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 c7 c0 00 00 00 00 	mov    \$0x0,%rax	38: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 8b 04 25 00 00 00 00 	mov    0x0,%rax	40: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 8b 05 00 00 00 00 	mov    0x0\(%rip\),%rax        # 4b <_start\+0x4b>	47: R_X86_64_REX_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	48 8b 81 00 00 00 00 	mov    0x0\(%rcx\),%rax	4e: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	ff 15 00 00 00 00    	callq  \*0x0\(%rip\)        # 58 <_start\+0x58>	54: R_X86_64_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	ff 90 00 00 00 00    	callq  \*0x0\(%rax\)	5a: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	ff 25 00 00 00 00    	jmpq   \*0x0\(%rip\)        # 64 <_start\+0x64>	60: R_X86_64_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	ff a1 00 00 00 00    	jmpq   \*0x0\(%rcx\)	66: R_X86_64_GOTPCREL	foo
+#pass
diff --git a/gas/testsuite/gas/i386/ilp32/x86-64-localpic.d b/gas/testsuite/gas/i386/ilp32/x86-64-localpic.d
index 9efd341..0ca69c7 100644
--- a/gas/testsuite/gas/i386/ilp32/x86-64-localpic.d
+++ b/gas/testsuite/gas/i386/ilp32/x86-64-localpic.d
@@ -1,10 +1,10 @@
 #source: ../x86-64-localpic.s
-#readelf: -rs
+#readelf: -rsW
 #name: x86-64 (ILP32) local PIC
 
 Relocation section '.rela.text' at offset 0x[0-9a-f]+ contains 1 entries:
- Offset     Info    Type            Sym.Value  Sym. Name \+ Addend
-[0-9a-f]+ +[0-9a-f]+ R_X86_64_GOTPCREL +[0-9a-f]+ +foo - 4
+ +Offset +Info +Type +Sym. Value +Symbol's Name \+ Addend
+[0-9a-f]+ +[0-9a-f]+ R_X86_64_REX_GOTPCRELX +[0-9a-f]+ +foo - 4
 #...
  +[0-9]+: +[0-9a-f]+ +[0-9a-f]+ +NOTYPE +LOCAL +DEFAULT +[0-9]+ +foo
 #pass
diff --git a/gas/testsuite/gas/i386/localpic.d b/gas/testsuite/gas/i386/localpic.d
index 93ac871..04fb5ce 100644
--- a/gas/testsuite/gas/i386/localpic.d
+++ b/gas/testsuite/gas/i386/localpic.d
@@ -3,7 +3,7 @@
 
 Relocation section '.rel.text' at offset 0x[0-9a-f]+ contains 1 entries:
  Offset     Info    Type            Sym.Value  Sym. Name
-[0-9a-f]+ +[0-9a-f]+ R_386_GOT32 +[0-9a-f]+ +foo
+[0-9a-f]+ +[0-9a-f]+ R_386_GOT32X +[0-9a-f]+ +foo
 #...
  +[0-9]+: +[0-9a-f]+ +[0-9a-f]+ +NOTYPE +LOCAL +DEFAULT +[0-9]+ +foo
 #pass
diff --git a/gas/testsuite/gas/i386/mixed-mode-reloc32.d b/gas/testsuite/gas/i386/mixed-mode-reloc32.d
index 6bc52f7..9affc36 100644
--- a/gas/testsuite/gas/i386/mixed-mode-reloc32.d
+++ b/gas/testsuite/gas/i386/mixed-mode-reloc32.d
@@ -6,9 +6,9 @@
 
 RELOCATION RECORDS FOR \[.text\]:
 OFFSET[ 	]+TYPE[ 	]+VALUE[ 	]*
-[0-9a-f]+[ 	]+R_386_GOT32[ 	]+xtrn[ 	]*
+[0-9a-f]+[ 	]+R_386_GOT32X[ 	]+xtrn[ 	]*
 [0-9a-f]+[ 	]+R_386_PLT32[ 	]+xtrn[ 	]*
-[0-9a-f]+[ 	]+R_386_GOT32[ 	]+xtrn[ 	]*
+[0-9a-f]+[ 	]+R_386_GOT32X[ 	]+xtrn[ 	]*
 [0-9a-f]+[ 	]+R_386_PLT32[ 	]+xtrn[ 	]*
-[0-9a-f]+[ 	]+R_386_GOT32[ 	]+xtrn[ 	]*
+[0-9a-f]+[ 	]+R_386_GOT32X[ 	]+xtrn[ 	]*
 [0-9a-f]+[ 	]+R_386_PLT32[ 	]+xtrn[ 	]*
diff --git a/gas/testsuite/gas/i386/reloc32.d b/gas/testsuite/gas/i386/reloc32.d
index cbd71d6..45c9cd2 100644
--- a/gas/testsuite/gas/i386/reloc32.d
+++ b/gas/testsuite/gas/i386/reloc32.d
@@ -18,7 +18,7 @@ Disassembly of section \.text:
 .*[ 	]+R_386_PC32[ 	]+xtrn
 .*[ 	]+R_386_PC8[ 	]+xtrn
 .*[ 	]+R_386_GOT32[ 	]+xtrn
-.*[ 	]+R_386_GOT32[ 	]+xtrn
+.*[ 	]+R_386_GOT32X[ 	]+xtrn
 .*[ 	]+R_386_GOTOFF[ 	]+xtrn
 .*[ 	]+R_386_GOTOFF[ 	]+xtrn
 .*[ 	]+R_386_GOTPC[ 	]+_GLOBAL_OFFSET_TABLE_
diff --git a/gas/testsuite/gas/i386/x86-64-gotpcrel.d b/gas/testsuite/gas/i386/x86-64-gotpcrel.d
new file mode 100644
index 0000000..6ca3fc7
--- /dev/null
+++ b/gas/testsuite/gas/i386/x86-64-gotpcrel.d
@@ -0,0 +1,25 @@
+#objdump: -dwr
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+0+ <_start>:
+[ 	]*[a-f0-9]+:	48 c7 c0 00 00 00 00 	mov    \$0x0,%rax	3: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 8b 04 25 00 00 00 00 	mov    0x0,%rax	b: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 8b 05 00 00 00 00 	mov    0x0\(%rip\),%rax        # 16 <_start\+0x16>	12: R_X86_64_REX_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	48 8b 81 00 00 00 00 	mov    0x0\(%rcx\),%rax	19: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	ff 15 00 00 00 00    	callq  \*0x0\(%rip\)        # 23 <_start\+0x23>	1f: R_X86_64_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	ff 90 00 00 00 00    	callq  \*0x0\(%rax\)	25: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	ff 25 00 00 00 00    	jmpq   \*0x0\(%rip\)        # 2f <_start\+0x2f>	2b: R_X86_64_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	ff a1 00 00 00 00    	jmpq   \*0x0\(%rcx\)	31: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 c7 c0 00 00 00 00 	mov    \$0x0,%rax	38: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 8b 04 25 00 00 00 00 	mov    0x0,%rax	40: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	48 8b 05 00 00 00 00 	mov    0x0\(%rip\),%rax        # 4b <_start\+0x4b>	47: R_X86_64_REX_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	48 8b 81 00 00 00 00 	mov    0x0\(%rcx\),%rax	4e: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	ff 15 00 00 00 00    	callq  \*0x0\(%rip\)        # 58 <_start\+0x58>	54: R_X86_64_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	ff 90 00 00 00 00    	callq  \*0x0\(%rax\)	5a: R_X86_64_GOTPCREL	foo
+[ 	]*[a-f0-9]+:	ff 25 00 00 00 00    	jmpq   \*0x0\(%rip\)        # 64 <_start\+0x64>	60: R_X86_64_GOTPCRELX	foo-0x4
+[ 	]*[a-f0-9]+:	ff a1 00 00 00 00    	jmpq   \*0x0\(%rcx\)	66: R_X86_64_GOTPCREL	foo
+#pass
diff --git a/gas/testsuite/gas/i386/x86-64-gotpcrel.s b/gas/testsuite/gas/i386/x86-64-gotpcrel.s
new file mode 100644
index 0000000..981b14f
--- /dev/null
+++ b/gas/testsuite/gas/i386/x86-64-gotpcrel.s
@@ -0,0 +1,23 @@
+	.text
+_start:
+	movq	$foo@GOTPCREL, %rax
+	movq	foo@GOTPCREL, %rax
+	movq	foo@GOTPCREL(%rip), %rax
+	movq	foo@GOTPCREL(%rcx), %rax
+
+	call	*foo@GOTPCREL(%rip)
+	call	*foo@GOTPCREL(%rax)
+	jmp	*foo@GOTPCREL(%rip)
+	jmp	*foo@GOTPCREL(%rcx)
+
+	.intel_syntax noprefix
+
+	mov	rax, offset foo@gotpcrel
+	mov	rax, QWORD PTR [foo@GOTPCREL]
+	mov	rax, QWORD PTR [rip + foo@GOTPCREL]
+	mov	rax, QWORD PTR [rcx + foo@GOTPCREL]
+
+	call	QWORD PTR [rip + foo@GOTPCREL]
+	call	QWORD PTR [rax + foo@GOTPCREL]
+	jmp	QWORD PTR [rip + foo@GOTPCREL]
+	jmp	QWORD PTR [rcx + foo@GOTPCREL]
diff --git a/gas/testsuite/gas/i386/x86-64-localpic.d b/gas/testsuite/gas/i386/x86-64-localpic.d
index f400adb..0a07149 100644
--- a/gas/testsuite/gas/i386/x86-64-localpic.d
+++ b/gas/testsuite/gas/i386/x86-64-localpic.d
@@ -1,9 +1,9 @@
-#readelf: -rs
+#readelf: -rsW
 #name: x86-64 local PIC
 
 Relocation section '.rela.text' at offset 0x[0-9a-f]+ contains 1 entries:
-  Offset          Info           Type           Sym. Value    Sym. Name \+ Addend
-[0-9a-f]+ +[0-9a-f]+ R_X86_64_GOTPCREL +[0-9a-f]+ +foo - 4
+ +Offset +Info +Type +Symbol's Value +Symbol's Name \+ Addend
+[0-9a-f]+ +[0-9a-f]+ R_X86_64_REX_GOTPCRELX +[0-9a-f]+ +foo - 4
 #...
  +[0-9]+: +[0-9a-f]+ +[0-9a-f]+ +NOTYPE +LOCAL +DEFAULT +[0-9]+ +foo
 #pass
diff --git a/gold/i386.cc b/gold/i386.cc
index 202f518..36c5724 100644
--- a/gold/i386.cc
+++ b/gold/i386.cc
@@ -1690,6 +1690,7 @@ Target_i386::Scan::get_reference_flags(unsigned int r_type)
       return Symbol::FUNCTION_CALL | Symbol::RELATIVE_REF;
 
     case elfcpp::R_386_GOT32:
+    case elfcpp::R_386_GOT32X:
       // Absolute in GOT.
       return Symbol::ABSOLUTE_REF;
 
@@ -1854,6 +1855,7 @@ Target_i386::Scan::local(Symbol_table* symtab,
       break;
 
     case elfcpp::R_386_GOT32:
+    case elfcpp::R_386_GOT32X:
       {
 	// We need GOT section.
 	Output_data_got<32, false>* got = target->got_section(symtab, layout);
@@ -2105,6 +2107,7 @@ Target_i386::Scan::possible_function_pointer_reloc(unsigned int r_type)
     case elfcpp::R_386_8:
     case elfcpp::R_386_GOTOFF:
     case elfcpp::R_386_GOT32:
+    case elfcpp::R_386_GOT32X:
       {
 	return true;
       }
@@ -2266,6 +2269,7 @@ Target_i386::Scan::global(Symbol_table* symtab,
       break;
 
     case elfcpp::R_386_GOT32:
+    case elfcpp::R_386_GOT32X:
       {
 	// The symbol requires a GOT section.
 	Output_data_got<32, false>* got = target->got_section(symtab, layout);
@@ -2834,6 +2838,7 @@ Target_i386::Relocate::relocate(const Relocate_info<32, false>* relinfo,
       break;
 
     case elfcpp::R_386_GOT32:
+    case elfcpp::R_386_GOT32X:
       // Convert
       // mov foo@GOT(%reg), %reg
       // to
@@ -3617,6 +3622,7 @@ Target_i386::Relocatable_size_for_reloc::get_size_for_reloc(
     case elfcpp::R_386_32:
     case elfcpp::R_386_PC32:
     case elfcpp::R_386_GOT32:
+    case elfcpp::R_386_GOT32X:
     case elfcpp::R_386_PLT32:
     case elfcpp::R_386_GOTOFF:
     case elfcpp::R_386_GOTPC:
diff --git a/gold/x86_64.cc b/gold/x86_64.cc
index 007af1d..c728a00 100644
--- a/gold/x86_64.cc
+++ b/gold/x86_64.cc
@@ -2191,6 +2191,8 @@ Target_x86_64<size>::Scan::get_reference_flags(unsigned int r_type)
     case elfcpp::R_X86_64_GOT32:
     case elfcpp::R_X86_64_GOTPCREL64:
     case elfcpp::R_X86_64_GOTPCREL:
+    case elfcpp::R_X86_64_GOTPCRELX:
+    case elfcpp::R_X86_64_REX_GOTPCRELX:
     case elfcpp::R_X86_64_GOTPLT64:
       // Absolute in GOT.
       return Symbol::ABSOLUTE_REF;
@@ -2475,6 +2477,8 @@ Target_x86_64<size>::Scan::local(Symbol_table* symtab,
     case elfcpp::R_X86_64_GOT32:
     case elfcpp::R_X86_64_GOTPCREL64:
     case elfcpp::R_X86_64_GOTPCREL:
+    case elfcpp::R_X86_64_GOTPCRELX:
+    case elfcpp::R_X86_64_REX_GOTPCRELX:
     case elfcpp::R_X86_64_GOTPLT64:
       {
 	// The symbol requires a GOT section.
@@ -2485,7 +2489,9 @@ Target_x86_64<size>::Scan::local(Symbol_table* symtab,
 	// mov foo@GOTPCREL(%rip), %reg
 	// to lea foo(%rip), %reg.
 	// in Relocate::relocate.
-	if (r_type == elfcpp::R_X86_64_GOTPCREL
+	if ((r_type == elfcpp::R_X86_64_GOTPCREL
+	     || r_type == elfcpp::R_X86_64_GOTPCRELX
+	     || r_type == elfcpp::R_X86_64_REX_GOTPCRELX)
 	    && reloc.get_r_offset() >= 2
 	    && !is_ifunc)
 	  {
@@ -2713,6 +2719,8 @@ Target_x86_64<size>::Scan::possible_function_pointer_reloc(unsigned int r_type)
     case elfcpp::R_X86_64_GOT32:
     case elfcpp::R_X86_64_GOTPCREL64:
     case elfcpp::R_X86_64_GOTPCREL:
+    case elfcpp::R_X86_64_GOTPCRELX:
+    case elfcpp::R_X86_64_REX_GOTPCRELX:
     case elfcpp::R_X86_64_GOTPLT64:
       {
 	return true;
@@ -2901,6 +2909,8 @@ Target_x86_64<size>::Scan::global(Symbol_table* symtab,
     case elfcpp::R_X86_64_GOT32:
     case elfcpp::R_X86_64_GOTPCREL64:
     case elfcpp::R_X86_64_GOTPCREL:
+    case elfcpp::R_X86_64_GOTPCRELX:
+    case elfcpp::R_X86_64_REX_GOTPCRELX:
     case elfcpp::R_X86_64_GOTPLT64:
       {
 	// The symbol requires a GOT entry.
@@ -2910,7 +2920,9 @@ Target_x86_64<size>::Scan::global(Symbol_table* symtab,
 	// mov foo@GOTPCREL(%rip), %reg
 	// to lea foo(%rip), %reg.
 	// in Relocate::relocate, then there is nothing to do here.
-	if (r_type == elfcpp::R_X86_64_GOTPCREL
+	if ((r_type == elfcpp::R_X86_64_GOTPCREL
+	     || r_type == elfcpp::R_X86_64_GOTPCRELX
+	     || r_type == elfcpp::R_X86_64_REX_GOTPCRELX)
 	    && reloc.get_r_offset() >= 2
 	    && Target_x86_64<size>::can_convert_mov_to_lea(gsym))
 	  {
@@ -3538,6 +3550,8 @@ Target_x86_64<size>::Relocate::relocate(
       break;
 
     case elfcpp::R_X86_64_GOTPCREL:
+    case elfcpp::R_X86_64_GOTPCRELX:
+    case elfcpp::R_X86_64_REX_GOTPCRELX:
       {
       // Convert
       // mov foo@GOTPCREL(%rip), %reg
@@ -4320,6 +4334,8 @@ Target_x86_64<size>::Relocatable_size_for_reloc::get_size_for_reloc(
     case elfcpp::R_X86_64_GOT64:
     case elfcpp::R_X86_64_GOTPCREL64:
     case elfcpp::R_X86_64_GOTPCREL:
+    case elfcpp::R_X86_64_GOTPCRELX:
+    case elfcpp::R_X86_64_REX_GOTPCRELX:
     case elfcpp::R_X86_64_GOTPLT64:
       return 8;
 
diff --git a/include/bfdlink.h b/include/bfdlink.h
index 2ffb3d1..93abab1 100644
--- a/include/bfdlink.h
+++ b/include/bfdlink.h
@@ -434,6 +434,12 @@ struct bfd_link_info
   /* TRUE if generation of .interp/PT_INTERP should be suppressed.  */
   unsigned int nointerp: 1;
 
+  /* TRUE if generate a 1-byte NOP as suffix for x86 call instruction.  */
+  unsigned int call_nop_as_suffix : 1;
+
+  /* The 1-byte NOP for x86 call instruction.  */
+  char call_nop_byte;
+
   /* Char that may appear as the first char of a symbol, but should be
      skipped (like symbol_leading_char) when looking up symbols in
      wrap_hash.  Used by PowerPC Linux for 'dot' symbols.  */
diff --git a/include/elf/i386.h b/include/elf/i386.h
index 08c9455..dea65f4 100644
--- a/include/elf/i386.h
+++ b/include/elf/i386.h
@@ -66,6 +66,8 @@ START_RELOC_NUMBERS (elf_i386_reloc_type)
      RELOC_NUMBER (R_386_TLS_DESC_CALL,40)
      RELOC_NUMBER (R_386_TLS_DESC,     41)
      RELOC_NUMBER (R_386_IRELATIVE,    42) /* Adjust indirectly by program base */
+     /* Load from 32 bit GOT entry, relaxable.  */
+     RELOC_NUMBER (R_386_GOT32X,       43)
 
      /* Used by Intel.  */
      RELOC_NUMBER (R_386_USED_BY_INTEL_200, 200)
diff --git a/include/elf/x86-64.h b/include/elf/x86-64.h
index f18ec66..7b98f65 100644
--- a/include/elf/x86-64.h
+++ b/include/elf/x86-64.h
@@ -72,10 +72,16 @@ START_RELOC_NUMBERS (elf_x86_64_reloc_type)
      RELOC_NUMBER (R_X86_64_TLSDESC, 36)      /* 2x64-bit TLS descriptor.  */
      RELOC_NUMBER (R_X86_64_IRELATIVE, 37)    /* Adjust indirectly by program base */
      RELOC_NUMBER (R_X86_64_RELATIVE64, 38)   /* 64bit adjust by program base */
-     RELOC_NUMBER (R_X86_64_PC32_BND, 39)      /* PC relative 32 bit
-						  signed with BND prefix  */
-     RELOC_NUMBER (R_X86_64_PLT32_BND, 40)     /* 32 bit PLT address with
-						  BND prefix */
+     RELOC_NUMBER (R_X86_64_PC32_BND, 39)     /* PC relative 32 bit
+						 signed with BND prefix  */
+     RELOC_NUMBER (R_X86_64_PLT32_BND, 40)    /* 32 bit PLT address with
+						 BND prefix */
+     /* Load from 32 bit signed pc relative offset to GOT entry without
+	REX prefix, relaxable.  */
+     RELOC_NUMBER (R_X86_64_GOTPCRELX, 41)
+     /* Load from 32 bit signed pc relative offset to GOT entry with
+	REX prefix, relaxable.  */
+     RELOC_NUMBER (R_X86_64_REX_GOTPCRELX, 42)
      RELOC_NUMBER (R_X86_64_GNU_VTINHERIT, 250)       /* GNU C++ hack  */
      RELOC_NUMBER (R_X86_64_GNU_VTENTRY, 251)         /* GNU C++ hack  */
 END_RELOC_NUMBERS (R_X86_64_max)
diff --git a/ld/emulparams/call_nop.sh b/ld/emulparams/call_nop.sh
new file mode 100644
index 0000000..fee4a81
--- /dev/null
+++ b/ld/emulparams/call_nop.sh
@@ -0,0 +1,48 @@
+PARSE_AND_LIST_OPTIONS_CALL_NOP='
+  fprintf (file, _("\
+  -z call-nop=PADDING         Use PADDING as 1-byte NOP for branch\n"));
+'
+PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP='
+      else if (strncmp (optarg, "call-nop=", 9) == 0)
+	{
+	  if (strcmp (optarg + 9, "prefix-addr") == 0)
+	    {
+	      link_info.call_nop_as_suffix = FALSE;
+	      link_info.call_nop_byte = 0x67;
+	    }
+	  else if (strcmp (optarg + 9, "prefix-nop") == 0)
+	    {
+	      link_info.call_nop_as_suffix = FALSE;
+	      link_info.call_nop_byte = 0x90;
+	    }
+	  else if (strcmp (optarg + 9, "suffix-nop") == 0)
+	    {
+	      link_info.call_nop_as_suffix = TRUE;
+	      link_info.call_nop_byte = 0x90;
+	    }
+	  else if (strncmp (optarg + 9, "prefix-", 7) == 0)
+	    {
+	      char *end;
+	      link_info.call_nop_byte = strtoul (optarg + 16 , &end, 0);
+	      if (*end)
+	        einfo (_("%P%F: invalid number for -z call-nop=prefix-: %s\n"),
+		       optarg + 16);
+	      link_info.call_nop_as_suffix = FALSE;
+	    }
+	  else if (strncmp (optarg + 9, "suffix-", 7) == 0)
+	    {
+	      char *end;
+	      link_info.call_nop_byte = strtoul (optarg + 16, &end, 0);
+	      if (*end)
+	        einfo (_("%P%F: invalid number for -z call-nop=suffix-: %s\n"),
+		       optarg + 16);
+	      link_info.call_nop_as_suffix = TRUE;
+	    }
+	  else
+	    einfo (_("%P%F: unsupported option: -z %s\n"), optarg);
+	}
+'
+
+PARSE_AND_LIST_OPTIONS="$PARSE_AND_LIST_OPTIONS $PARSE_AND_LIST_OPTIONS_CALL_NOP"
+PARSE_AND_LIST_ARGS_CASE_Z="$PARSE_AND_LIST_ARGS_CASE_Z $PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP"
+CALL_NOP_BYTE=0x67
diff --git a/ld/emulparams/elf32_x86_64.sh b/ld/emulparams/elf32_x86_64.sh
index 8fd96fb..0a03548 100644
--- a/ld/emulparams/elf32_x86_64.sh
+++ b/ld/emulparams/elf32_x86_64.sh
@@ -1,5 +1,6 @@
 . ${srcdir}/emulparams/plt_unwind.sh
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
 SCRIPT_NAME=elf
 ELFSIZE=32
 OUTPUT_FORMAT="elf32-x86-64"
diff --git a/ld/emulparams/elf_i386.sh b/ld/emulparams/elf_i386.sh
index ae87f6b..7dceea9 100644
--- a/ld/emulparams/elf_i386.sh
+++ b/ld/emulparams/elf_i386.sh
@@ -1,5 +1,6 @@
 . ${srcdir}/emulparams/plt_unwind.sh
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
 SCRIPT_NAME=elf
 OUTPUT_FORMAT="elf32-i386"
 NO_RELA_RELOCS=yes
diff --git a/ld/emulparams/elf_i386_be.sh b/ld/emulparams/elf_i386_be.sh
index 06a80c7..40ed8c6 100644
--- a/ld/emulparams/elf_i386_be.sh
+++ b/ld/emulparams/elf_i386_be.sh
@@ -1,4 +1,5 @@
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
 SCRIPT_NAME=elf
 OUTPUT_FORMAT="elf32-i386"
 NO_RELA_RELOCS=yes
diff --git a/ld/emulparams/elf_i386_chaos.sh b/ld/emulparams/elf_i386_chaos.sh
index c59dbce..33757bf 100644
--- a/ld/emulparams/elf_i386_chaos.sh
+++ b/ld/emulparams/elf_i386_chaos.sh
@@ -1,5 +1,6 @@
 . ${srcdir}/emulparams/plt_unwind.sh
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
 SCRIPT_NAME=elf_chaos
 OUTPUT_FORMAT="elf32-i386"
 TEXT_START_ADDR=0x40000000
diff --git a/ld/emulparams/elf_i386_ldso.sh b/ld/emulparams/elf_i386_ldso.sh
index 7fd08fe..f780581 100644
--- a/ld/emulparams/elf_i386_ldso.sh
+++ b/ld/emulparams/elf_i386_ldso.sh
@@ -1,5 +1,6 @@
 . ${srcdir}/emulparams/plt_unwind.sh
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
 SCRIPT_NAME=elf
 OUTPUT_FORMAT="elf32-i386"
 NO_RELA_RELOCS=yes
diff --git a/ld/emulparams/elf_i386_vxworks.sh b/ld/emulparams/elf_i386_vxworks.sh
index 306e8d3..cb289e6 100644
--- a/ld/emulparams/elf_i386_vxworks.sh
+++ b/ld/emulparams/elf_i386_vxworks.sh
@@ -12,3 +12,4 @@ GENERATE_PIE_SCRIPT=yes
 NO_SMALL_DATA=yes
 . ${srcdir}/emulparams/vxworks.sh
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
diff --git a/ld/emulparams/elf_iamcu.sh b/ld/emulparams/elf_iamcu.sh
index 39c7a57..5fae651 100644
--- a/ld/emulparams/elf_iamcu.sh
+++ b/ld/emulparams/elf_iamcu.sh
@@ -1,5 +1,6 @@
 . ${srcdir}/emulparams/plt_unwind.sh
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
 SCRIPT_NAME=elf
 OUTPUT_FORMAT="elf32-iamcu"
 NO_RELA_RELOCS=yes
diff --git a/ld/emulparams/elf_k1om.sh b/ld/emulparams/elf_k1om.sh
index 0cd606a..289274d 100644
--- a/ld/emulparams/elf_k1om.sh
+++ b/ld/emulparams/elf_k1om.sh
@@ -1,5 +1,6 @@
 . ${srcdir}/emulparams/plt_unwind.sh
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
 SCRIPT_NAME=elf
 ELFSIZE=64
 OUTPUT_FORMAT="elf64-k1om"
diff --git a/ld/emulparams/elf_l1om.sh b/ld/emulparams/elf_l1om.sh
index 1964e85..17fa8e2 100644
--- a/ld/emulparams/elf_l1om.sh
+++ b/ld/emulparams/elf_l1om.sh
@@ -1,5 +1,6 @@
 . ${srcdir}/emulparams/plt_unwind.sh
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
 SCRIPT_NAME=elf
 ELFSIZE=64
 OUTPUT_FORMAT="elf64-l1om"
diff --git a/ld/emulparams/elf_x86_64.sh b/ld/emulparams/elf_x86_64.sh
index a304771..5d31da1 100644
--- a/ld/emulparams/elf_x86_64.sh
+++ b/ld/emulparams/elf_x86_64.sh
@@ -1,5 +1,6 @@
 . ${srcdir}/emulparams/plt_unwind.sh
 . ${srcdir}/emulparams/extern_protected_data.sh
+. ${srcdir}/emulparams/call_nop.sh
 SCRIPT_NAME=elf
 ELFSIZE=64
 OUTPUT_FORMAT="elf64-x86-64"
diff --git a/ld/emultempl/elf32.em b/ld/emultempl/elf32.em
index 8ff5fe0..1dc215f 100644
--- a/ld/emultempl/elf32.em
+++ b/ld/emultempl/elf32.em
@@ -103,6 +103,7 @@ gld${EMULATION_NAME}_before_parse (void)
   input_flags.dynamic = ${DYNAMIC_LINK-TRUE};
   config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo TRUE ; else echo FALSE ; fi`;
   config.separate_code = `if test "x${SEPARATE_CODE}" = xyes ; then echo TRUE ; else echo FALSE ; fi`;
+  `if test -n "$CALL_NOP_BYTE" ; then echo link_info.call_nop_byte = $CALL_NOP_BYTE; fi`;
 }
 
 EOF
diff --git a/ld/ld.texinfo b/ld/ld.texinfo
index 17cd479..f3ea581 100644
--- a/ld/ld.texinfo
+++ b/ld/ld.texinfo
@@ -1199,6 +1199,20 @@ generated by compiler.  Updates on protected data symbols by another
 module aren't visible to the resulting shared library.  Supported for
 i386 and x86-64.
 
+@item call-nop=prefix-addr
+@itemx call-nop=prefix-nop
+@itemx call-nop=suffix-nop
+@itemx call-nop=prefix-@var{byte}
+@itemx call-nop=suffix-@var{byte}
+Specify the 1-byte @code{NOP} padding when transforming indirect call
+to a locally defined function, foo, via its GOT slot.
+@option{call-nop=prefix-addr} generates @code{0x67 call foo}.
+@option{call-nop=prefix-nop} generates @code{0x90 call foo}.
+@option{call-nop=suffix-nop} generates @code{call foo 0x90}.
+@option{call-nop=prefix-@var{byte}} generates @code{@var{byte} call foo}.
+@option{call-nop=suffix-@var{byte}} generates @code{call foo @var{byte}}.
+Supported for i386 and x86_64.
+
 @end table
 
 Other keywords are ignored for Solaris compatibility.
diff --git a/ld/testsuite/ld-i386/branch1.d b/ld/testsuite/ld-i386/branch1.d
new file mode 100644
index 0000000..a078f1d
--- /dev/null
+++ b/ld/testsuite/ld-i386/branch1.d
@@ -0,0 +1,17 @@
+#as: --32
+#ld: -melf_i386
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	67 e8 ([0-9a-f]{2} ){4} *	addr16 call +[a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	67 e8 ([0-9a-f]{2} ){4} *	addr16 call +[a-f0-9]+ <bar>
+[ 	]*[a-f0-9]+:	e9 ([0-9a-f]{2} ){4} *	jmp +[a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	90                   	nop
+[ 	]*[a-f0-9]+:	e9 ([0-9a-f]{2} ){4} *	jmp +[a-f0-9]+ <bar>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-i386/branch1.s b/ld/testsuite/ld-i386/branch1.s
new file mode 100644
index 0000000..0ccf5cf
--- /dev/null
+++ b/ld/testsuite/ld-i386/branch1.s
@@ -0,0 +1,15 @@
+	.text
+	.type	bar, @function
+bar:
+	ret
+	.globl	foo
+	.type	foo, @function
+foo:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	call	*foo@GOT
+	call	*bar@GOT
+	jmp	*foo@GOT
+	jmp	*bar@GOT
diff --git a/ld/testsuite/ld-i386/call1.d b/ld/testsuite/ld-i386/call1.d
new file mode 100644
index 0000000..69383b2
--- /dev/null
+++ b/ld/testsuite/ld-i386/call1.d
@@ -0,0 +1,3 @@
+#as: --32
+#ld: -shared -melf_i386
+#error: direct GOT relocation R_386_GOT32X against `foo' without base register can not be used when making a shared object
diff --git a/ld/testsuite/ld-i386/call1.s b/ld/testsuite/ld-i386/call1.s
new file mode 100644
index 0000000..ce003c8
--- /dev/null
+++ b/ld/testsuite/ld-i386/call1.s
@@ -0,0 +1,9 @@
+	.text
+	.globl	foo
+	.type	foo, @function
+foo:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	call	*foo@GOT
diff --git a/ld/testsuite/ld-i386/call2.d b/ld/testsuite/ld-i386/call2.d
new file mode 100644
index 0000000..69383b2
--- /dev/null
+++ b/ld/testsuite/ld-i386/call2.d
@@ -0,0 +1,3 @@
+#as: --32
+#ld: -shared -melf_i386
+#error: direct GOT relocation R_386_GOT32X against `foo' without base register can not be used when making a shared object
diff --git a/ld/testsuite/ld-i386/call2.s b/ld/testsuite/ld-i386/call2.s
new file mode 100644
index 0000000..57cd88f
--- /dev/null
+++ b/ld/testsuite/ld-i386/call2.s
@@ -0,0 +1,8 @@
+	.text
+	.type	foo, @function
+foo:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	call	*foo@GOT
diff --git a/ld/testsuite/ld-i386/call3.s b/ld/testsuite/ld-i386/call3.s
new file mode 100644
index 0000000..ce003c8
--- /dev/null
+++ b/ld/testsuite/ld-i386/call3.s
@@ -0,0 +1,9 @@
+	.text
+	.globl	foo
+	.type	foo, @function
+foo:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	call	*foo@GOT
diff --git a/ld/testsuite/ld-i386/call3a.d b/ld/testsuite/ld-i386/call3a.d
new file mode 100644
index 0000000..a8ff27f
--- /dev/null
+++ b/ld/testsuite/ld-i386/call3a.d
@@ -0,0 +1,13 @@
+#source: call3.s
+#as: --32
+#ld: -melf_i386
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	67 e8 ([0-9a-f]{2} ){4} *	addr16 call +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-i386/call3b.d b/ld/testsuite/ld-i386/call3b.d
new file mode 100644
index 0000000..06af6f5
--- /dev/null
+++ b/ld/testsuite/ld-i386/call3b.d
@@ -0,0 +1,13 @@
+#source: call3.s
+#as: --32
+#ld: -melf_i386 -z call-nop=prefix-addr
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	67 e8 ([0-9a-f]{2} ){4} *	addr16 call +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-i386/call3c.d b/ld/testsuite/ld-i386/call3c.d
new file mode 100644
index 0000000..64e8372
--- /dev/null
+++ b/ld/testsuite/ld-i386/call3c.d
@@ -0,0 +1,14 @@
+#source: call3.s
+#as: --32
+#ld: -melf_i386 -z call-nop=prefix-nop
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	90                   	nop
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	call +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-i386/call3d.d b/ld/testsuite/ld-i386/call3d.d
new file mode 100644
index 0000000..a9274c8
--- /dev/null
+++ b/ld/testsuite/ld-i386/call3d.d
@@ -0,0 +1,14 @@
+#source: call3.s
+#as: --32
+#ld: -melf_i386 -z call-nop=suffix-nop
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	call +[a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-i386/call3e.d b/ld/testsuite/ld-i386/call3e.d
new file mode 100644
index 0000000..2876b49
--- /dev/null
+++ b/ld/testsuite/ld-i386/call3e.d
@@ -0,0 +1,13 @@
+#source: call3.s
+#as: --32
+#ld: -melf_i386 -z call-nop=prefix-0x67
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	67 e8 ([0-9a-f]{2} ){4} *	addr16 call +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-i386/call3f.d b/ld/testsuite/ld-i386/call3f.d
new file mode 100644
index 0000000..5ab0cf1
--- /dev/null
+++ b/ld/testsuite/ld-i386/call3f.d
@@ -0,0 +1,14 @@
+#source: call3.s
+#as: --32
+#ld: -melf_i386 -z call-nop=prefix-0x90
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	90                   	nop
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	call +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-i386/call3g.d b/ld/testsuite/ld-i386/call3g.d
new file mode 100644
index 0000000..8287770
--- /dev/null
+++ b/ld/testsuite/ld-i386/call3g.d
@@ -0,0 +1,14 @@
+#source: call3.s
+#as: --32
+#ld: -melf_i386 -z call-nop=suffix-0x90
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	call +[a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-i386/call3h.d b/ld/testsuite/ld-i386/call3h.d
new file mode 100644
index 0000000..83f371a
--- /dev/null
+++ b/ld/testsuite/ld-i386/call3h.d
@@ -0,0 +1,14 @@
+#source: call3.s
+#as: --32
+#ld: -melf_i386 -z call-nop=suffix-144
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	call +[a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-i386/got1.dd b/ld/testsuite/ld-i386/got1.dd
new file mode 100644
index 0000000..e46153d
--- /dev/null
+++ b/ld/testsuite/ld-i386/got1.dd
@@ -0,0 +1,20 @@
+#...
+[a-f0-9]+ <main>:
+[ 	]*[a-f0-9]+:	83 ec 0c             	sub    \$0xc,%esp
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	addr16 call [a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	call   \*0x[a-f0-9]+
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	call   \*0x[a-f0-9]+
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	lea   *0x[a-f0-9]+,%eax
+[ 	]*[a-f0-9]+:	ff d0                	call   \*%eax
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	mov   *0x[a-f0-9]+,%eax
+[ 	]*[a-f0-9]+:	ff d0                	call   \*%eax
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	mov   *0x[a-f0-9]+,%eax
+[ 	]*[a-f0-9]+:	ff d0                	call   \*%eax
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	lea   *0x[a-f0-9]+,%ecx
+[ 	]*[a-f0-9]+:	ff d1                	call   \*%ecx
+[ 	]*[a-f0-9]+:	83 ec 0c             	sub    \$0xc,%esp
+[ 	]*[a-f0-9]+:	6a 00                	push   \$0x0
+[ 	]*[a-f0-9]+:	6a 00                	push   \$0x0
+[ 	]*[a-f0-9]+:	[ a-f0-9]+       	jmp    [a-f0-9]+ <myexit>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-i386/got1.out b/ld/testsuite/ld-i386/got1.out
new file mode 100644
index 0000000..99d4f7f
--- /dev/null
+++ b/ld/testsuite/ld-i386/got1.out
@@ -0,0 +1,7 @@
+foo
+bar
+plt
+foo
+bar
+plt
+foo
diff --git a/ld/testsuite/ld-i386/got1a.S b/ld/testsuite/ld-i386/got1a.S
new file mode 100644
index 0000000..f3d5330
--- /dev/null
+++ b/ld/testsuite/ld-i386/got1a.S
@@ -0,0 +1,21 @@
+	.text
+	.globl	main
+	.type	main, @function
+main:
+	subl	$12, %esp
+	call	*foo@GOT
+	call	*bar@GOT
+	call	*plt@GOT
+	movl	foo@GOT, %eax
+	call	*%eax
+	movl	bar@GOT, %eax
+	call	*%eax
+	movl	plt@GOT, %eax
+	call	*%eax
+	movl	foo@GOT(%ebx), %ecx
+	call	*%ecx
+	subl	$12, %esp
+	pushl	$0
+	pushl	$0	# Push a dummy return address onto stack.
+	jmp	*myexit@GOT
+	.size	main, .-main
diff --git a/ld/testsuite/ld-i386/got1b.c b/ld/testsuite/ld-i386/got1b.c
new file mode 100644
index 0000000..cf0c78e
--- /dev/null
+++ b/ld/testsuite/ld-i386/got1b.c
@@ -0,0 +1,7 @@
+#include <stdio.h>
+
+void
+foo (void)
+{
+  printf ("%s\n", __FUNCTION__);
+}
diff --git a/ld/testsuite/ld-i386/got1c.c b/ld/testsuite/ld-i386/got1c.c
new file mode 100644
index 0000000..05f5fc2
--- /dev/null
+++ b/ld/testsuite/ld-i386/got1c.c
@@ -0,0 +1,7 @@
+#include <stdlib.h>
+
+void
+myexit (int status)
+{
+  exit (status);
+}
diff --git a/ld/testsuite/ld-i386/got1d.S b/ld/testsuite/ld-i386/got1d.S
new file mode 100644
index 0000000..a6d51c6
--- /dev/null
+++ b/ld/testsuite/ld-i386/got1d.S
@@ -0,0 +1,54 @@
+	.globl	bar
+	.type	bar, @function
+bar:
+	pushl	%ebx
+	call	__x86.get_pc_thunk.cx
+	addl	$_GLOBAL_OFFSET_TABLE_, %ecx
+	subl	$24, %esp
+	leal	__FUNCTION__.1862@GOTOFF(%ecx), %eax
+	movl	%eax, (%esp)
+	call	*puts@GOT(%ecx)
+	addl	$24, %esp
+	popl	%ebx
+	ret
+	.size	bar, .-bar
+
+	.globl	plt
+	.type	plt, @function
+plt:
+	pushl	%esi
+	pushl	%ebx
+	call	__x86.get_pc_thunk.bx
+1:
+	addl	$_GLOBAL_OFFSET_TABLE_, %ebx
+	subl	$20, %esp
+	leal	__FUNCTION__.1866@GOTOFF(%ebx), %esi
+	movl	%esi, (%esp)
+	call	*puts@GOT(%ebx)
+	addl	$20, %esp
+	popl	%ebx
+	popl	%esi
+	ret
+	.section	.rodata
+	.type	__FUNCTION__.1866, @object
+	.size	__FUNCTION__.1866, 4
+__FUNCTION__.1866:
+	.string	"plt"
+	.type	__FUNCTION__.1862, @object
+	.size	__FUNCTION__.1862, 4
+__FUNCTION__.1862:
+	.string	"bar"
+	.section	.text.__x86.get_pc_thunk.bx,"axG",@progbits,__x86.get_pc_thunk.bx,comdat
+	.globl	__x86.get_pc_thunk.bx
+	.hidden	__x86.get_pc_thunk.bx
+	.type	__x86.get_pc_thunk.bx, @function
+__x86.get_pc_thunk.bx:
+	movl	(%esp), %ebx
+	ret
+	.section	.text.__x86.get_pc_thunk.cx,"axG",@progbits,__x86.get_pc_thunk.cx,comdat
+	.globl	__x86.get_pc_thunk.cx
+	.hidden	__x86.get_pc_thunk.cx
+	.type	__x86.get_pc_thunk.cx, @function
+__x86.get_pc_thunk.cx:
+	movl	(%esp), %ecx
+	ret
diff --git a/ld/testsuite/ld-i386/i386.exp b/ld/testsuite/ld-i386/i386.exp
index 8cddfce..9bf08da 100644
--- a/ld/testsuite/ld-i386/i386.exp
+++ b/ld/testsuite/ld-i386/i386.exp
@@ -293,6 +293,28 @@ run_dump_test "lea1e"
 run_dump_test "lea1f"
 run_dump_test "mov1a"
 run_dump_test "mov1b"
+run_dump_test "branch1"
+run_dump_test "call1"
+run_dump_test "call2"
+run_dump_test "call3a"
+run_dump_test "call3b"
+run_dump_test "call3c"
+run_dump_test "call3d"
+run_dump_test "call3e"
+run_dump_test "call3f"
+run_dump_test "call3g"
+run_dump_test "call3h"
+run_dump_test "jmp1"
+run_dump_test "jmp2"
+run_dump_test "load1"
+run_dump_test "load1-nacl"
+run_dump_test "load2"
+run_dump_test "load3"
+run_dump_test "load4a"
+run_dump_test "load4b"
+run_dump_test "load5a"
+run_dump_test "load5b"
+run_dump_test "load6"
 
 if { !([istarget "i?86-*-linux*"]
        || [istarget "i?86-*-gnu*"]
@@ -498,6 +520,22 @@ if { [isnative]
 	    "" \
 	    "pr19031.so" \
 	] \
+	[list \
+	    "Build got1d.so" \
+	    "-shared" \
+	    "" \
+	    { got1d.S } \
+	    "" \
+	    "got1d.so" \
+	] \
+	[list \
+	    "Build gotpc1" \
+	    "tmpdir/got1d.so" \
+	    "" \
+	    { got1a.S got1b.c got1c.c } \
+	    {{objdump {-dw} got1.dd}} \
+	    "got1" \
+	] \
     ]
 
     run_ld_link_exec_tests [] [list \
@@ -568,6 +606,14 @@ if { [isnative]
 	    "pr19031" \
 	    "pr19031.out" \
 	] \
+	[list \
+	    "Run got1" \
+	    "tmpdir/got1d.so" \
+	    "" \
+	    { got1a.S got1b.c got1c.c } \
+	    "got1" \
+	    "got1.out" \
+	] \
     ]
 }
 
diff --git a/ld/testsuite/ld-i386/jmp1.d b/ld/testsuite/ld-i386/jmp1.d
new file mode 100644
index 0000000..69383b2
--- /dev/null
+++ b/ld/testsuite/ld-i386/jmp1.d
@@ -0,0 +1,3 @@
+#as: --32
+#ld: -shared -melf_i386
+#error: direct GOT relocation R_386_GOT32X against `foo' without base register can not be used when making a shared object
diff --git a/ld/testsuite/ld-i386/jmp1.s b/ld/testsuite/ld-i386/jmp1.s
new file mode 100644
index 0000000..8c80696
--- /dev/null
+++ b/ld/testsuite/ld-i386/jmp1.s
@@ -0,0 +1,9 @@
+	.text
+	.globl	foo
+	.type	foo, @function
+foo:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	jmp	*foo@GOT
diff --git a/ld/testsuite/ld-i386/jmp2.d b/ld/testsuite/ld-i386/jmp2.d
new file mode 100644
index 0000000..69383b2
--- /dev/null
+++ b/ld/testsuite/ld-i386/jmp2.d
@@ -0,0 +1,3 @@
+#as: --32
+#ld: -shared -melf_i386
+#error: direct GOT relocation R_386_GOT32X against `foo' without base register can not be used when making a shared object
diff --git a/ld/testsuite/ld-i386/jmp2.s b/ld/testsuite/ld-i386/jmp2.s
new file mode 100644
index 0000000..b4bc38d
--- /dev/null
+++ b/ld/testsuite/ld-i386/jmp2.s
@@ -0,0 +1,8 @@
+	.text
+	.type	foo, @function
+foo:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	jmp	*foo@GOT
diff --git a/ld/testsuite/ld-i386/lea1c.d b/ld/testsuite/ld-i386/lea1c.d
index c84f413..54ec0de 100644
--- a/ld/testsuite/ld-i386/lea1c.d
+++ b/ld/testsuite/ld-i386/lea1c.d
@@ -9,6 +9,6 @@
 Disassembly of section .text:
 
 #...
-[ 	]*[a-f0-9]+:	8d 81 ([0-9a-f]{2} ){4} *	lea    -0x[a-f0-9]+\(%ecx\),%eax
-[ 	]*[a-f0-9]+:	8d 81 ([0-9a-f]{2} ){4} *	lea    0x[a-f0-9]+\(%ecx\),%eax
+[ 	]*[a-f0-9]+:	8d 05 ([0-9a-f]{2} ){4} *	lea    0x[a-f0-9]+,%eax
+[ 	]*[a-f0-9]+:	8d 05 ([0-9a-f]{2} ){4} *	lea    0x[a-f0-9]+,%eax
 #pass
diff --git a/ld/testsuite/ld-i386/load1-nacl.d b/ld/testsuite/ld-i386/load1-nacl.d
new file mode 100644
index 0000000..1245639
--- /dev/null
+++ b/ld/testsuite/ld-i386/load1-nacl.d
@@ -0,0 +1,59 @@
+#source: load1.s
+#as: --32
+#ld: -melf_i386
+#objdump: -dw --sym
+#target: i?86-*-nacl* x86_64-*-nacl*
+
+.*: +file format .*
+
+SYMBOL TABLE:
+#...
+10030080 l     O .data	0+1 bar
+#...
+10030081 g     O .data	0+1 foo
+#...
+
+Disassembly of section .text:
+
+0+20000 <_start>:
+[ 	]*[a-f0-9]+:	8d 05 80 00 03 10    	lea    0x10030080,%eax
+[ 	]*[a-f0-9]+:	81 d0 80 00 03 10    	adc    \$0x10030080,%eax
+[ 	]*[a-f0-9]+:	81 c3 80 00 03 10    	add    \$0x10030080,%ebx
+[ 	]*[a-f0-9]+:	81 e1 80 00 03 10    	and    \$0x10030080,%ecx
+[ 	]*[a-f0-9]+:	81 fa 80 00 03 10    	cmp    \$0x10030080,%edx
+[ 	]*[a-f0-9]+:	81 cf 80 00 03 10    	or     \$0x10030080,%edi
+[ 	]*[a-f0-9]+:	81 de 80 00 03 10    	sbb    \$0x10030080,%esi
+[ 	]*[a-f0-9]+:	81 ed 80 00 03 10    	sub    \$0x10030080,%ebp
+[ 	]*[a-f0-9]+:	81 f4 80 00 03 10    	xor    \$0x10030080,%esp
+[ 	]*[a-f0-9]+:	f7 c1 80 00 03 10    	test   \$0x10030080,%ecx
+[ 	]*[a-f0-9]+:	8d 05 80 00 03 10    	lea    0x10030080,%eax
+[ 	]*[a-f0-9]+:	81 d0 80 00 03 10    	adc    \$0x10030080,%eax
+[ 	]*[a-f0-9]+:	81 c3 80 00 03 10    	add    \$0x10030080,%ebx
+[ 	]*[a-f0-9]+:	81 e1 80 00 03 10    	and    \$0x10030080,%ecx
+[ 	]*[a-f0-9]+:	81 fa 80 00 03 10    	cmp    \$0x10030080,%edx
+[ 	]*[a-f0-9]+:	81 cf 80 00 03 10    	or     \$0x10030080,%edi
+[ 	]*[a-f0-9]+:	81 de 80 00 03 10    	sbb    \$0x10030080,%esi
+[ 	]*[a-f0-9]+:	81 ed 80 00 03 10    	sub    \$0x10030080,%ebp
+[ 	]*[a-f0-9]+:	81 f4 80 00 03 10    	xor    \$0x10030080,%esp
+[ 	]*[a-f0-9]+:	f7 c1 80 00 03 10    	test   \$0x10030080,%ecx
+[ 	]*[a-f0-9]+:	8d 05 81 00 03 10    	lea    0x10030081,%eax
+[ 	]*[a-f0-9]+:	81 d0 81 00 03 10    	adc    \$0x10030081,%eax
+[ 	]*[a-f0-9]+:	81 c3 81 00 03 10    	add    \$0x10030081,%ebx
+[ 	]*[a-f0-9]+:	81 e1 81 00 03 10    	and    \$0x10030081,%ecx
+[ 	]*[a-f0-9]+:	81 fa 81 00 03 10    	cmp    \$0x10030081,%edx
+[ 	]*[a-f0-9]+:	81 cf 81 00 03 10    	or     \$0x10030081,%edi
+[ 	]*[a-f0-9]+:	81 de 81 00 03 10    	sbb    \$0x10030081,%esi
+[ 	]*[a-f0-9]+:	81 ed 81 00 03 10    	sub    \$0x10030081,%ebp
+[ 	]*[a-f0-9]+:	81 f4 81 00 03 10    	xor    \$0x10030081,%esp
+[ 	]*[a-f0-9]+:	f7 c1 81 00 03 10    	test   \$0x10030081,%ecx
+[ 	]*[a-f0-9]+:	8d 05 81 00 03 10    	lea    0x10030081,%eax
+[ 	]*[a-f0-9]+:	81 d0 81 00 03 10    	adc    \$0x10030081,%eax
+[ 	]*[a-f0-9]+:	81 c3 81 00 03 10    	add    \$0x10030081,%ebx
+[ 	]*[a-f0-9]+:	81 e1 81 00 03 10    	and    \$0x10030081,%ecx
+[ 	]*[a-f0-9]+:	81 fa 81 00 03 10    	cmp    \$0x10030081,%edx
+[ 	]*[a-f0-9]+:	81 cf 81 00 03 10    	or     \$0x10030081,%edi
+[ 	]*[a-f0-9]+:	81 de 81 00 03 10    	sbb    \$0x10030081,%esi
+[ 	]*[a-f0-9]+:	81 ed 81 00 03 10    	sub    \$0x10030081,%ebp
+[ 	]*[a-f0-9]+:	81 f4 81 00 03 10    	xor    \$0x10030081,%esp
+[ 	]*[a-f0-9]+:	f7 c1 81 00 03 10    	test   \$0x10030081,%ecx
+#pass
diff --git a/ld/testsuite/ld-i386/load1.d b/ld/testsuite/ld-i386/load1.d
new file mode 100644
index 0000000..062ea18
--- /dev/null
+++ b/ld/testsuite/ld-i386/load1.d
@@ -0,0 +1,58 @@
+#as: --32
+#ld: -melf_i386
+#objdump: -dw --sym
+#notarget: i?86-*-nacl* x86_64-*-nacl*
+
+.*: +file format .*
+
+SYMBOL TABLE:
+#...
+0+8049170 l     O .data	0+1 bar
+#...
+0+8049171 g     O .data	0+1 foo
+#...
+
+Disassembly of section .text:
+
+0+8048074 <_start>:
+[ 	]*[a-f0-9]+:	8d 05 70 91 04 08    	lea    0x8049170,%eax
+[ 	]*[a-f0-9]+:	81 d0 70 91 04 08    	adc    \$0x8049170,%eax
+[ 	]*[a-f0-9]+:	81 c3 70 91 04 08    	add    \$0x8049170,%ebx
+[ 	]*[a-f0-9]+:	81 e1 70 91 04 08    	and    \$0x8049170,%ecx
+[ 	]*[a-f0-9]+:	81 fa 70 91 04 08    	cmp    \$0x8049170,%edx
+[ 	]*[a-f0-9]+:	81 cf 70 91 04 08    	or     \$0x8049170,%edi
+[ 	]*[a-f0-9]+:	81 de 70 91 04 08    	sbb    \$0x8049170,%esi
+[ 	]*[a-f0-9]+:	81 ed 70 91 04 08    	sub    \$0x8049170,%ebp
+[ 	]*[a-f0-9]+:	81 f4 70 91 04 08    	xor    \$0x8049170,%esp
+[ 	]*[a-f0-9]+:	f7 c1 70 91 04 08    	test   \$0x8049170,%ecx
+[ 	]*[a-f0-9]+:	8d 05 70 91 04 08    	lea    0x8049170,%eax
+[ 	]*[a-f0-9]+:	81 d0 70 91 04 08    	adc    \$0x8049170,%eax
+[ 	]*[a-f0-9]+:	81 c3 70 91 04 08    	add    \$0x8049170,%ebx
+[ 	]*[a-f0-9]+:	81 e1 70 91 04 08    	and    \$0x8049170,%ecx
+[ 	]*[a-f0-9]+:	81 fa 70 91 04 08    	cmp    \$0x8049170,%edx
+[ 	]*[a-f0-9]+:	81 cf 70 91 04 08    	or     \$0x8049170,%edi
+[ 	]*[a-f0-9]+:	81 de 70 91 04 08    	sbb    \$0x8049170,%esi
+[ 	]*[a-f0-9]+:	81 ed 70 91 04 08    	sub    \$0x8049170,%ebp
+[ 	]*[a-f0-9]+:	81 f4 70 91 04 08    	xor    \$0x8049170,%esp
+[ 	]*[a-f0-9]+:	f7 c1 70 91 04 08    	test   \$0x8049170,%ecx
+[ 	]*[a-f0-9]+:	8d 05 71 91 04 08    	lea    0x8049171,%eax
+[ 	]*[a-f0-9]+:	81 d0 71 91 04 08    	adc    \$0x8049171,%eax
+[ 	]*[a-f0-9]+:	81 c3 71 91 04 08    	add    \$0x8049171,%ebx
+[ 	]*[a-f0-9]+:	81 e1 71 91 04 08    	and    \$0x8049171,%ecx
+[ 	]*[a-f0-9]+:	81 fa 71 91 04 08    	cmp    \$0x8049171,%edx
+[ 	]*[a-f0-9]+:	81 cf 71 91 04 08    	or     \$0x8049171,%edi
+[ 	]*[a-f0-9]+:	81 de 71 91 04 08    	sbb    \$0x8049171,%esi
+[ 	]*[a-f0-9]+:	81 ed 71 91 04 08    	sub    \$0x8049171,%ebp
+[ 	]*[a-f0-9]+:	81 f4 71 91 04 08    	xor    \$0x8049171,%esp
+[ 	]*[a-f0-9]+:	f7 c1 71 91 04 08    	test   \$0x8049171,%ecx
+[ 	]*[a-f0-9]+:	8d 05 71 91 04 08    	lea    0x8049171,%eax
+[ 	]*[a-f0-9]+:	81 d0 71 91 04 08    	adc    \$0x8049171,%eax
+[ 	]*[a-f0-9]+:	81 c3 71 91 04 08    	add    \$0x8049171,%ebx
+[ 	]*[a-f0-9]+:	81 e1 71 91 04 08    	and    \$0x8049171,%ecx
+[ 	]*[a-f0-9]+:	81 fa 71 91 04 08    	cmp    \$0x8049171,%edx
+[ 	]*[a-f0-9]+:	81 cf 71 91 04 08    	or     \$0x8049171,%edi
+[ 	]*[a-f0-9]+:	81 de 71 91 04 08    	sbb    \$0x8049171,%esi
+[ 	]*[a-f0-9]+:	81 ed 71 91 04 08    	sub    \$0x8049171,%ebp
+[ 	]*[a-f0-9]+:	81 f4 71 91 04 08    	xor    \$0x8049171,%esp
+[ 	]*[a-f0-9]+:	f7 c1 71 91 04 08    	test   \$0x8049171,%ecx
+#pass
diff --git a/ld/testsuite/ld-i386/load1.s b/ld/testsuite/ld-i386/load1.s
new file mode 100644
index 0000000..a9f8460
--- /dev/null
+++ b/ld/testsuite/ld-i386/load1.s
@@ -0,0 +1,55 @@
+	.data
+	.type	bar, @object
+bar:
+	.byte	1
+	.size	bar, .-bar
+	.globl	foo
+	.type	foo, @object
+foo:
+	.byte	1
+	.size	foo, .-foo
+	.text
+	.globl	_start
+	.type	_start, @function
+_start:
+	movl	bar@GOT(%ecx), %eax
+	adcl	bar@GOT(%ecx), %eax
+	addl	bar@GOT(%ecx), %ebx
+	andl	bar@GOT(%ecx), %ecx
+	cmpl	bar@GOT(%ecx), %edx
+	orl	bar@GOT(%ecx), %edi
+	sbbl	bar@GOT(%ecx), %esi
+	subl	bar@GOT(%ecx), %ebp
+	xorl	bar@GOT(%ecx), %esp
+	testl	%ecx, bar@GOT(%ecx)
+	movl	bar@GOT, %eax
+	adcl	bar@GOT, %eax
+	addl	bar@GOT, %ebx
+	andl	bar@GOT, %ecx
+	cmpl	bar@GOT, %edx
+	orl	bar@GOT, %edi
+	sbbl	bar@GOT, %esi
+	subl	bar@GOT, %ebp
+	xorl	bar@GOT, %esp
+	testl	%ecx, bar@GOT
+	movl	foo@GOT(%ecx), %eax
+	adcl	foo@GOT(%ecx), %eax
+	addl	foo@GOT(%ecx), %ebx
+	andl	foo@GOT(%ecx), %ecx
+	cmpl	foo@GOT(%ecx), %edx
+	orl	foo@GOT(%ecx), %edi
+	sbbl	foo@GOT(%ecx), %esi
+	subl	foo@GOT(%ecx), %ebp
+	xorl	foo@GOT(%ecx), %esp
+	testl	%ecx, foo@GOT(%ecx)
+	movl	foo@GOT, %eax
+	adcl	foo@GOT, %eax
+	addl	foo@GOT, %ebx
+	andl	foo@GOT, %ecx
+	cmpl	foo@GOT, %edx
+	orl	foo@GOT, %edi
+	sbbl	foo@GOT, %esi
+	subl	foo@GOT, %ebp
+	xorl	foo@GOT, %esp
+	testl	%ecx, foo@GOT
+	.size	_start, .-_start
diff --git a/ld/testsuite/ld-i386/load2.d b/ld/testsuite/ld-i386/load2.d
new file mode 100644
index 0000000..87c2509
--- /dev/null
+++ b/ld/testsuite/ld-i386/load2.d
@@ -0,0 +1,3 @@
+#as: --32
+#ld: -melf_i386 -shared
+#error: direct GOT relocation R_386_GOT32X against `foo' without base register can not be used when making a shared object
diff --git a/ld/testsuite/ld-i386/load2.s b/ld/testsuite/ld-i386/load2.s
new file mode 100644
index 0000000..7aad5d0
--- /dev/null
+++ b/ld/testsuite/ld-i386/load2.s
@@ -0,0 +1,8 @@
+	.data
+	.type	foo, @object
+foo:
+	.text
+	.globl	_start
+	.type	_start, @function
+_start:
+	addl	foo@GOT, %ebx
diff --git a/ld/testsuite/ld-i386/load3.d b/ld/testsuite/ld-i386/load3.d
new file mode 100644
index 0000000..87c2509
--- /dev/null
+++ b/ld/testsuite/ld-i386/load3.d
@@ -0,0 +1,3 @@
+#as: --32
+#ld: -melf_i386 -shared
+#error: direct GOT relocation R_386_GOT32X against `foo' without base register can not be used when making a shared object
diff --git a/ld/testsuite/ld-i386/load3.s b/ld/testsuite/ld-i386/load3.s
new file mode 100644
index 0000000..d9b7083
--- /dev/null
+++ b/ld/testsuite/ld-i386/load3.s
@@ -0,0 +1,9 @@
+	.data
+	.globl	foo
+	.type	foo, @object
+foo:
+	.text
+	.globl	_start
+	.type	_start, @function
+_start:
+	addl	foo@GOT, %ebx
diff --git a/ld/testsuite/ld-i386/load4.s b/ld/testsuite/ld-i386/load4.s
new file mode 100644
index 0000000..fe2c4cd
--- /dev/null
+++ b/ld/testsuite/ld-i386/load4.s
@@ -0,0 +1,9 @@
+	.text
+	.globl	foo
+	.type	foo, @function
+foo:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	movl	foo@GOT, %eax
diff --git a/ld/testsuite/ld-i386/load4a.d b/ld/testsuite/ld-i386/load4a.d
new file mode 100644
index 0000000..3aa56bd
--- /dev/null
+++ b/ld/testsuite/ld-i386/load4a.d
@@ -0,0 +1,4 @@
+#source: load4.s
+#as: --32
+#ld: -Bsymbolic -shared -melf_i386
+#error: direct GOT relocation R_386_GOT32X against `foo' without base register can not be used when making a shared object
diff --git a/ld/testsuite/ld-i386/load4b.d b/ld/testsuite/ld-i386/load4b.d
new file mode 100644
index 0000000..0f6f4e2
--- /dev/null
+++ b/ld/testsuite/ld-i386/load4b.d
@@ -0,0 +1,13 @@
+#source: load4.s
+#as: --32
+#ld: -melf_i386
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	8d 05 ([0-9a-f]{2} ){4} *	lea    0x[a-f0-9]+,%eax
+#pass
diff --git a/ld/testsuite/ld-i386/load5.s b/ld/testsuite/ld-i386/load5.s
new file mode 100644
index 0000000..1ecd50c
--- /dev/null
+++ b/ld/testsuite/ld-i386/load5.s
@@ -0,0 +1,8 @@
+	.text
+	.type	foo, @function
+foo:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	movl	foo@GOT, %eax
diff --git a/ld/testsuite/ld-i386/load5a.d b/ld/testsuite/ld-i386/load5a.d
new file mode 100644
index 0000000..88c225a
--- /dev/null
+++ b/ld/testsuite/ld-i386/load5a.d
@@ -0,0 +1,4 @@
+#source: load5.s
+#as: --32
+#ld: -Bsymbolic -shared -melf_i386
+#error: direct GOT relocation R_386_GOT32X against `foo' without base register can not be used when making a shared object
diff --git a/ld/testsuite/ld-i386/load5b.d b/ld/testsuite/ld-i386/load5b.d
new file mode 100644
index 0000000..6db0b28
--- /dev/null
+++ b/ld/testsuite/ld-i386/load5b.d
@@ -0,0 +1,13 @@
+#source: load5.s
+#as: --32
+#ld: -melf_i386
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	8d 05 ([0-9a-f]{2} ){4} *	lea    0x[a-f0-9]+,%eax
+#pass
diff --git a/ld/testsuite/ld-i386/load6.d b/ld/testsuite/ld-i386/load6.d
new file mode 100644
index 0000000..69319cf
--- /dev/null
+++ b/ld/testsuite/ld-i386/load6.d
@@ -0,0 +1,28 @@
+#as: --32
+#ld: -shared -melf_i386
+#objdump: -dw
+
+.*: +file format .*
+
+Disassembly of section .text:
+
+[a-f0-9]+ <_start>:
+[ 	]*[a-f0-9]+:	13 81 f8 ff ff ff    	adc    -0x8\(%ecx\),%eax
+[ 	]*[a-f0-9]+:	03 99 f8 ff ff ff    	add    -0x8\(%ecx\),%ebx
+[ 	]*[a-f0-9]+:	23 89 f8 ff ff ff    	and    -0x8\(%ecx\),%ecx
+[ 	]*[a-f0-9]+:	3b 91 f8 ff ff ff    	cmp    -0x8\(%ecx\),%edx
+[ 	]*[a-f0-9]+:	0b b9 f8 ff ff ff    	or     -0x8\(%ecx\),%edi
+[ 	]*[a-f0-9]+:	1b b1 f8 ff ff ff    	sbb    -0x8\(%ecx\),%esi
+[ 	]*[a-f0-9]+:	2b a9 f8 ff ff ff    	sub    -0x8\(%ecx\),%ebp
+[ 	]*[a-f0-9]+:	33 a1 f8 ff ff ff    	xor    -0x8\(%ecx\),%esp
+[ 	]*[a-f0-9]+:	85 89 f8 ff ff ff    	test   %ecx,-0x8\(%ecx\)
+[ 	]*[a-f0-9]+:	13 81 fc ff ff ff    	adc    -0x4\(%ecx\),%eax
+[ 	]*[a-f0-9]+:	03 99 fc ff ff ff    	add    -0x4\(%ecx\),%ebx
+[ 	]*[a-f0-9]+:	23 89 fc ff ff ff    	and    -0x4\(%ecx\),%ecx
+[ 	]*[a-f0-9]+:	3b 91 fc ff ff ff    	cmp    -0x4\(%ecx\),%edx
+[ 	]*[a-f0-9]+:	0b b9 fc ff ff ff    	or     -0x4\(%ecx\),%edi
+[ 	]*[a-f0-9]+:	1b b1 fc ff ff ff    	sbb    -0x4\(%ecx\),%esi
+[ 	]*[a-f0-9]+:	2b a9 fc ff ff ff    	sub    -0x4\(%ecx\),%ebp
+[ 	]*[a-f0-9]+:	33 a1 fc ff ff ff    	xor    -0x4\(%ecx\),%esp
+[ 	]*[a-f0-9]+:	85 89 fc ff ff ff    	test   %ecx,-0x4\(%ecx\)
+#pass
diff --git a/ld/testsuite/ld-i386/load6.s b/ld/testsuite/ld-i386/load6.s
new file mode 100644
index 0000000..eac3137
--- /dev/null
+++ b/ld/testsuite/ld-i386/load6.s
@@ -0,0 +1,33 @@
+	.data
+	.type	bar, @object
+bar:
+	.byte	1
+	.size	bar, .-bar
+	.globl	foo
+	.type	foo, @object
+foo:
+	.byte	1
+	.size	foo, .-foo
+	.text
+	.globl	_start
+	.type	_start, @function
+_start:
+	adcl	bar@GOT(%ecx), %eax
+	addl	bar@GOT(%ecx), %ebx
+	andl	bar@GOT(%ecx), %ecx
+	cmpl	bar@GOT(%ecx), %edx
+	orl	bar@GOT(%ecx), %edi
+	sbbl	bar@GOT(%ecx), %esi
+	subl	bar@GOT(%ecx), %ebp
+	xorl	bar@GOT(%ecx), %esp
+	testl	%ecx, bar@GOT(%ecx)
+	adcl	foo@GOT(%ecx), %eax
+	addl	foo@GOT(%ecx), %ebx
+	andl	foo@GOT(%ecx), %ecx
+	cmpl	foo@GOT(%ecx), %edx
+	orl	foo@GOT(%ecx), %edi
+	sbbl	foo@GOT(%ecx), %esi
+	subl	foo@GOT(%ecx), %ebp
+	xorl	foo@GOT(%ecx), %esp
+	testl	%ecx, foo@GOT(%ecx)
+	.size	_start, .-_start
diff --git a/ld/testsuite/ld-i386/plt-main1.rd b/ld/testsuite/ld-i386/plt-main1.rd
index d27589e..53c49d9 100644
--- a/ld/testsuite/ld-i386/plt-main1.rd
+++ b/ld/testsuite/ld-i386/plt-main1.rd
@@ -1,3 +1,3 @@
 #...
-[0-9a-f ]+R_386_GOT32 +0+ +bar
+[0-9a-f ]+R_386_GOT32X +0+ +bar
 #pass
diff --git a/ld/testsuite/ld-i386/plt-main3.rd b/ld/testsuite/ld-i386/plt-main3.rd
index 7b78818..417fb20 100644
--- a/ld/testsuite/ld-i386/plt-main3.rd
+++ b/ld/testsuite/ld-i386/plt-main3.rd
@@ -1,5 +1,5 @@
 #...
-[0-9a-f ]+R_386_GOT32 +0+ +bar
+[0-9a-f ]+R_386_GOT32X +0+ +bar
 #...
 [0-9a-f ]+R_386_PLT32 +0+ +bar
 #pass
diff --git a/ld/testsuite/ld-i386/plt-main4.rd b/ld/testsuite/ld-i386/plt-main4.rd
index 882a3ad..393fe29 100644
--- a/ld/testsuite/ld-i386/plt-main4.rd
+++ b/ld/testsuite/ld-i386/plt-main4.rd
@@ -1,5 +1,5 @@
 #...
-[0-9a-f ]+R_386_GOT32 +0+ +foo
+[0-9a-f ]+R_386_GOT32X +0+ +foo
 #...
 [0-9a-f ]+R_386_PLT32 +0+ +foo
 #pass
diff --git a/ld/testsuite/ld-ifunc/ifunc-5r-local-x86-64.d b/ld/testsuite/ld-ifunc/ifunc-5r-local-x86-64.d
index e9ad214c..18021e7 100644
--- a/ld/testsuite/ld-ifunc/ifunc-5r-local-x86-64.d
+++ b/ld/testsuite/ld-ifunc/ifunc-5r-local-x86-64.d
@@ -7,4 +7,4 @@
 Relocation section '.rela.text' at .*
 [ ]+Offset[ ]+Info[ ]+Type[ ]+.*
 [0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_PLT32[ ]+foo\(\)[ ]+foo - 4
-[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_GOTPCREL[ ]+foo\(\)[ ]+foo - 4
+[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_REX_GOTPCRELX[ ]+foo\(\)[ ]+foo - 4
diff --git a/ld/testsuite/ld-x86-64/call1.s b/ld/testsuite/ld-x86-64/call1.s
new file mode 100644
index 0000000..92c9f05
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1.s
@@ -0,0 +1,9 @@
+	.text
+	.globl	foo
+	.type	foo, @function
+foo:
+	ret
+	.globl	_start
+	.type	_start, @function
+_start:
+	call   *foo@GOTPCREL(%rip)
diff --git a/ld/testsuite/ld-x86-64/call1a.d b/ld/testsuite/ld-x86-64/call1a.d
new file mode 100644
index 0000000..2a63b1c
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1a.d
@@ -0,0 +1,13 @@
+#source: call1.s
+#as: --64
+#ld: -melf_x86_64
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	67 e8 ([0-9a-f]{2} ){4} *	addr32 callq +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-x86-64/call1b.d b/ld/testsuite/ld-x86-64/call1b.d
new file mode 100644
index 0000000..e782fa2
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1b.d
@@ -0,0 +1,13 @@
+#source: call1.s
+#as: --64
+#ld: -melf_x86_64 -z call-nop=prefix-addr
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	67 e8 ([0-9a-f]{2} ){4} *	addr32 callq +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-x86-64/call1c.d b/ld/testsuite/ld-x86-64/call1c.d
new file mode 100644
index 0000000..d058fc7
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1c.d
@@ -0,0 +1,14 @@
+#source: call1.s
+#as: --64
+#ld: -melf_x86_64 -z call-nop=prefix-nop
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	90                   	nop
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	callq +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-x86-64/call1d.d b/ld/testsuite/ld-x86-64/call1d.d
new file mode 100644
index 0000000..8871cc6
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1d.d
@@ -0,0 +1,14 @@
+#source: call1.s
+#as: --64
+#ld: -melf_x86_64 -z call-nop=suffix-nop
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	callq +[a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-x86-64/call1e.d b/ld/testsuite/ld-x86-64/call1e.d
new file mode 100644
index 0000000..7127f1a
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1e.d
@@ -0,0 +1,13 @@
+#source: call1.s
+#as: --64
+#ld: -melf_x86_64 -z call-nop=prefix-0x67
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	67 e8 ([0-9a-f]{2} ){4} *	addr32 callq +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-x86-64/call1f.d b/ld/testsuite/ld-x86-64/call1f.d
new file mode 100644
index 0000000..587bade
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1f.d
@@ -0,0 +1,14 @@
+#source: call1.s
+#as: --64
+#ld: -melf_x86_64 -z call-nop=prefix-0x90
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	90                   	nop
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	callq +[a-f0-9]+ <foo>
+#pass
diff --git a/ld/testsuite/ld-x86-64/call1g.d b/ld/testsuite/ld-x86-64/call1g.d
new file mode 100644
index 0000000..3bb512e
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1g.d
@@ -0,0 +1,14 @@
+#source: call1.s
+#as: --64
+#ld: -melf_x86_64 -z call-nop=suffix-0x90
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	callq +[a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-x86-64/call1h.d b/ld/testsuite/ld-x86-64/call1h.d
new file mode 100644
index 0000000..c7c8dde
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1h.d
@@ -0,0 +1,14 @@
+#source: call1.s
+#as: --64
+#ld: -melf_x86_64 -z call-nop=suffix-144
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	callq +[a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-x86-64/call1i.d b/ld/testsuite/ld-x86-64/call1i.d
new file mode 100644
index 0000000..b3684ad
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/call1i.d
@@ -0,0 +1,14 @@
+#source: call1.s
+#as: --x32
+#ld: -melf32_x86_64 -z call-nop=suffix-0x90
+#objdump: -dw
+
+.*: +file format .*
+
+
+Disassembly of section .text:
+
+#...
+[ 	]*[a-f0-9]+:	e8 ([0-9a-f]{2} ){4} *	callq +[a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-x86-64/gotpcrel1.dd b/ld/testsuite/ld-x86-64/gotpcrel1.dd
new file mode 100644
index 0000000..187a1a5
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/gotpcrel1.dd
@@ -0,0 +1,17 @@
+#...
+[a-f0-9]+ <main>:
+[ 	]*[a-f0-9]+:	48 83 ec 08          	sub    \$0x8,%rsp
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	addr32 callq [a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	callq  \*0x[a-f0-9]+\(%rip\)        # [a-f0-9]+ <_DYNAMIC\+0x[a-f0-9]+>
+[ 	]*[a-f0-9]+:	[ a-f0-9]+    	callq  \*0x[a-f0-9]+\(%rip\)        # [a-f0-9]+ <_DYNAMIC\+0x[a-f0-9]+>
+[ 	]*[a-f0-9]+:	[ a-f0-9]+	lea    0x[a-f0-9]+\(%rip\),%rax        # [a-f0-9]+ <foo>
+[ 	]*[a-f0-9]+:	ff d0                	callq  \*%rax
+[ 	]*[a-f0-9]+:	[ a-f0-9]+	mov    0x[a-f0-9]+\(%rip\),%rcx        # [a-f0-9]+ <_DYNAMIC\+0x[a-f0-9]+>
+[ 	]*[a-f0-9]+:	ff d1                	callq  \*%rcx
+[ 	]*[a-f0-9]+:	[ a-f0-9]+	mov    0x[a-f0-9]+\(%rip\),%rdx        # [a-f0-9]+ <_DYNAMIC\+0x[a-f0-9]+>
+[ 	]*[a-f0-9]+:	ff d2                	callq  \*%rdx
+[ 	]*[a-f0-9]+:	31 ff                	xor    %edi,%edi
+[ 	]*[a-f0-9]+:	48 83 c4 08          	add    \$0x8,%rsp
+[ 	]*[a-f0-9]+:	[ a-f0-9]+       	jmpq   [a-f0-9]+ <myexit>
+[ 	]*[a-f0-9]+:	90                   	nop
+#pass
diff --git a/ld/testsuite/ld-x86-64/gotpcrel1.out b/ld/testsuite/ld-x86-64/gotpcrel1.out
new file mode 100644
index 0000000..4d35632
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/gotpcrel1.out
@@ -0,0 +1,8 @@
+foo
+bar
+plt
+plt
+foo
+bar
+plt
+plt
diff --git a/ld/testsuite/ld-x86-64/gotpcrel1a.S b/ld/testsuite/ld-x86-64/gotpcrel1a.S
new file mode 100644
index 0000000..58dfbb1
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/gotpcrel1a.S
@@ -0,0 +1,18 @@
+	.text
+	.globl	main
+	.type	main, @function
+main:
+	subq	$8, %rsp
+	call   *foo@GOTPCREL(%rip)
+	call   *bar@GOTPCREL(%rip)
+	call   *plt@GOTPCREL(%rip)
+	movq   foo@GOTPCREL(%rip), %rax
+	call   *%rax
+	movq   bar@GOTPCREL(%rip), %rcx
+	call   *%rcx
+	movq   plt@GOTPCREL(%rip), %rdx
+	call   *%rdx
+	xorl	%edi, %edi
+	addq	$8, %rsp
+	jmp	*myexit@GOTPCREL(%rip)
+	.size	main, .-main
diff --git a/ld/testsuite/ld-x86-64/gotpcrel1b.c b/ld/testsuite/ld-x86-64/gotpcrel1b.c
new file mode 100644
index 0000000..cf0c78e
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/gotpcrel1b.c
@@ -0,0 +1,7 @@
+#include <stdio.h>
+
+void
+foo (void)
+{
+  printf ("%s\n", __FUNCTION__);
+}
diff --git a/ld/testsuite/ld-x86-64/gotpcrel1c.c b/ld/testsuite/ld-x86-64/gotpcrel1c.c
new file mode 100644
index 0000000..05f5fc2
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/gotpcrel1c.c
@@ -0,0 +1,7 @@
+#include <stdlib.h>
+
+void
+myexit (int status)
+{
+  exit (status);
+}
diff --git a/ld/testsuite/ld-x86-64/gotpcrel1d.S b/ld/testsuite/ld-x86-64/gotpcrel1d.S
new file mode 100644
index 0000000..4b01499
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/gotpcrel1d.S
@@ -0,0 +1,26 @@
+	.text
+	.globl	bar
+	.type	bar, @function
+bar:
+	leaq	__FUNCTION__.2215(%rip), %rdi
+	jmp   *puts@GOTPCREL(%rip)
+	.size	bar, .-bar
+	.globl	plt
+	.type	plt, @function
+plt:
+	leaq	__FUNCTION__.2219(%rip), %rdi
+	subq	$8, %rsp
+	call   *puts@GOTPCREL(%rip)
+	leaq	__FUNCTION__.2219(%rip), %rdi
+	addq	$8, %rsp
+	jmp	*puts@GOTPCREL(%rip)
+	.size	plt, .-plt
+	.section	.rodata
+	.type	__FUNCTION__.2219, @object
+	.size	__FUNCTION__.2219, 4
+__FUNCTION__.2219:
+	.string	"plt"
+	.type	__FUNCTION__.2215, @object
+	.size	__FUNCTION__.2215, 4
+__FUNCTION__.2215:
+	.string	"bar"
diff --git a/ld/testsuite/ld-x86-64/load1.s b/ld/testsuite/ld-x86-64/load1.s
new file mode 100644
index 0000000..f35b48f
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/load1.s
@@ -0,0 +1,51 @@
+	.data
+	.type	bar, @object
+bar:
+	.byte	1
+	.size	bar, .-bar
+	.globl	foo
+	.type	foo, @object
+foo:
+	.byte	1
+	.size	foo, .-foo
+	.text
+	.globl	_start
+	.type	_start, @function
+_start:
+	adcl	bar@GOTPCREL(%rip), %eax
+	addl	bar@GOTPCREL(%rip), %ebx
+	andl	bar@GOTPCREL(%rip), %ecx
+	cmpl	bar@GOTPCREL(%rip), %edx
+	orl	bar@GOTPCREL(%rip), %esi
+	sbbl	bar@GOTPCREL(%rip), %edi
+	subl	bar@GOTPCREL(%rip), %ebp
+	xorl	bar@GOTPCREL(%rip), %r8d
+	testl	%r15d, bar@GOTPCREL(%rip)
+	adcq	bar@GOTPCREL(%rip), %rax
+	addq	bar@GOTPCREL(%rip), %rbx
+	andq	bar@GOTPCREL(%rip), %rcx
+	cmpq	bar@GOTPCREL(%rip), %rdx
+	orq	bar@GOTPCREL(%rip), %rdi
+	sbbq	bar@GOTPCREL(%rip), %rsi
+	subq	bar@GOTPCREL(%rip), %rbp
+	xorq	bar@GOTPCREL(%rip), %r8
+	testq	%r15, bar@GOTPCREL(%rip)
+	adcl	foo@GOTPCREL(%rip), %eax
+	addl	foo@GOTPCREL(%rip), %ebx
+	andl	foo@GOTPCREL(%rip), %ecx
+	cmpl	foo@GOTPCREL(%rip), %edx
+	orl	foo@GOTPCREL(%rip), %esi
+	sbbl	foo@GOTPCREL(%rip), %edi
+	subl	foo@GOTPCREL(%rip), %ebp
+	xorl	foo@GOTPCREL(%rip), %r8d
+	testl	%r15d, foo@GOTPCREL(%rip)
+	adcq	foo@GOTPCREL(%rip), %rax
+	addq	foo@GOTPCREL(%rip), %rbx
+	andq	foo@GOTPCREL(%rip), %rcx
+	cmpq	foo@GOTPCREL(%rip), %rdx
+	orq	foo@GOTPCREL(%rip), %rdi
+	sbbq	foo@GOTPCREL(%rip), %rsi
+	subq	foo@GOTPCREL(%rip), %rbp
+	xorq	foo@GOTPCREL(%rip), %r8
+	testq	%r15, foo@GOTPCREL(%rip)
+	.size	_start, .-_start
diff --git a/ld/testsuite/ld-x86-64/load1a-nacl.d b/ld/testsuite/ld-x86-64/load1a-nacl.d
new file mode 100644
index 0000000..aba9db9
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/load1a-nacl.d
@@ -0,0 +1,55 @@
+#source: load1.s
+#as: --64
+#ld: -melf_x86_64
+#objdump: -dw --sym
+#target: x86_64-*-nacl*
+
+.*: +file format .*
+
+SYMBOL TABLE:
+#...
+0+100300c8 l     O .data	0+1 bar
+#...
+0+100300c9 g     O .data	0+1 foo
+#...
+
+Disassembly of section .text:
+
+0+20000 <_start>:
+[ 	]*[a-f0-9]+:	81 d0 c8 00 03 10    	adc    \$0x100300c8,%eax
+[ 	]*[a-f0-9]+:	81 c3 c8 00 03 10    	add    \$0x100300c8,%ebx
+[ 	]*[a-f0-9]+:	81 e1 c8 00 03 10    	and    \$0x100300c8,%ecx
+[ 	]*[a-f0-9]+:	81 fa c8 00 03 10    	cmp    \$0x100300c8,%edx
+[ 	]*[a-f0-9]+:	81 ce c8 00 03 10    	or     \$0x100300c8,%esi
+[ 	]*[a-f0-9]+:	81 df c8 00 03 10    	sbb    \$0x100300c8,%edi
+[ 	]*[a-f0-9]+:	81 ed c8 00 03 10    	sub    \$0x100300c8,%ebp
+[ 	]*[a-f0-9]+:	41 81 f0 c8 00 03 10 	xor    \$0x100300c8,%r8d
+[ 	]*[a-f0-9]+:	41 f7 c7 c8 00 03 10 	test   \$0x100300c8,%r15d
+[ 	]*[a-f0-9]+:	48 81 d0 c8 00 03 10 	adc    \$0x100300c8,%rax
+[ 	]*[a-f0-9]+:	48 81 c3 c8 00 03 10 	add    \$0x100300c8,%rbx
+[ 	]*[a-f0-9]+:	48 81 e1 c8 00 03 10 	and    \$0x100300c8,%rcx
+[ 	]*[a-f0-9]+:	48 81 fa c8 00 03 10 	cmp    \$0x100300c8,%rdx
+[ 	]*[a-f0-9]+:	48 81 cf c8 00 03 10 	or     \$0x100300c8,%rdi
+[ 	]*[a-f0-9]+:	48 81 de c8 00 03 10 	sbb    \$0x100300c8,%rsi
+[ 	]*[a-f0-9]+:	48 81 ed c8 00 03 10 	sub    \$0x100300c8,%rbp
+[ 	]*[a-f0-9]+:	49 81 f0 c8 00 03 10 	xor    \$0x100300c8,%r8
+[ 	]*[a-f0-9]+:	49 f7 c7 c8 00 03 10 	test   \$0x100300c8,%r15
+[ 	]*[a-f0-9]+:	81 d0 c9 00 03 10    	adc    \$0x100300c9,%eax
+[ 	]*[a-f0-9]+:	81 c3 c9 00 03 10    	add    \$0x100300c9,%ebx
+[ 	]*[a-f0-9]+:	81 e1 c9 00 03 10    	and    \$0x100300c9,%ecx
+[ 	]*[a-f0-9]+:	81 fa c9 00 03 10    	cmp    \$0x100300c9,%edx
+[ 	]*[a-f0-9]+:	81 ce c9 00 03 10    	or     \$0x100300c9,%esi
+[ 	]*[a-f0-9]+:	81 df c9 00 03 10    	sbb    \$0x100300c9,%edi
+[ 	]*[a-f0-9]+:	81 ed c9 00 03 10    	sub    \$0x100300c9,%ebp
+[ 	]*[a-f0-9]+:	41 81 f0 c9 00 03 10 	xor    \$0x100300c9,%r8d
+[ 	]*[a-f0-9]+:	41 f7 c7 c9 00 03 10 	test   \$0x100300c9,%r15d
+[ 	]*[a-f0-9]+:	48 81 d0 c9 00 03 10 	adc    \$0x100300c9,%rax
+[ 	]*[a-f0-9]+:	48 81 c3 c9 00 03 10 	add    \$0x100300c9,%rbx
+[ 	]*[a-f0-9]+:	48 81 e1 c9 00 03 10 	and    \$0x100300c9,%rcx
+[ 	]*[a-f0-9]+:	48 81 fa c9 00 03 10 	cmp    \$0x100300c9,%rdx
+[ 	]*[a-f0-9]+:	48 81 cf c9 00 03 10 	or     \$0x100300c9,%rdi
+[ 	]*[a-f0-9]+:	48 81 de c9 00 03 10 	sbb    \$0x100300c9,%rsi
+[ 	]*[a-f0-9]+:	48 81 ed c9 00 03 10 	sub    \$0x100300c9,%rbp
+[ 	]*[a-f0-9]+:	49 81 f0 c9 00 03 10 	xor    \$0x100300c9,%r8
+[ 	]*[a-f0-9]+:	49 f7 c7 c9 00 03 10 	test   \$0x100300c9,%r15
+#pass
diff --git a/ld/testsuite/ld-x86-64/load1a.d b/ld/testsuite/ld-x86-64/load1a.d
new file mode 100644
index 0000000..5c9349e
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/load1a.d
@@ -0,0 +1,55 @@
+#source: load1.s
+#as: --64
+#ld: -melf_x86_64
+#objdump: -dw --sym
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+SYMBOL TABLE:
+#...
+0+6001b8 l     O .data	0+1 bar
+#...
+0+6001b9 g     O .data	0+1 foo
+#...
+
+Disassembly of section .text:
+
+0+4000b0 <_start>:
+[ 	]*[a-f0-9]+:	81 d0 b8 01 60 00    	adc    \$0x6001b8,%eax
+[ 	]*[a-f0-9]+:	81 c3 b8 01 60 00    	add    \$0x6001b8,%ebx
+[ 	]*[a-f0-9]+:	81 e1 b8 01 60 00    	and    \$0x6001b8,%ecx
+[ 	]*[a-f0-9]+:	81 fa b8 01 60 00    	cmp    \$0x6001b8,%edx
+[ 	]*[a-f0-9]+:	81 ce b8 01 60 00    	or     \$0x6001b8,%esi
+[ 	]*[a-f0-9]+:	81 df b8 01 60 00    	sbb    \$0x6001b8,%edi
+[ 	]*[a-f0-9]+:	81 ed b8 01 60 00    	sub    \$0x6001b8,%ebp
+[ 	]*[a-f0-9]+:	41 81 f0 b8 01 60 00 	xor    \$0x6001b8,%r8d
+[ 	]*[a-f0-9]+:	41 f7 c7 b8 01 60 00 	test   \$0x6001b8,%r15d
+[ 	]*[a-f0-9]+:	48 81 d0 b8 01 60 00 	adc    \$0x6001b8,%rax
+[ 	]*[a-f0-9]+:	48 81 c3 b8 01 60 00 	add    \$0x6001b8,%rbx
+[ 	]*[a-f0-9]+:	48 81 e1 b8 01 60 00 	and    \$0x6001b8,%rcx
+[ 	]*[a-f0-9]+:	48 81 fa b8 01 60 00 	cmp    \$0x6001b8,%rdx
+[ 	]*[a-f0-9]+:	48 81 cf b8 01 60 00 	or     \$0x6001b8,%rdi
+[ 	]*[a-f0-9]+:	48 81 de b8 01 60 00 	sbb    \$0x6001b8,%rsi
+[ 	]*[a-f0-9]+:	48 81 ed b8 01 60 00 	sub    \$0x6001b8,%rbp
+[ 	]*[a-f0-9]+:	49 81 f0 b8 01 60 00 	xor    \$0x6001b8,%r8
+[ 	]*[a-f0-9]+:	49 f7 c7 b8 01 60 00 	test   \$0x6001b8,%r15
+[ 	]*[a-f0-9]+:	81 d0 b9 01 60 00    	adc    \$0x6001b9,%eax
+[ 	]*[a-f0-9]+:	81 c3 b9 01 60 00    	add    \$0x6001b9,%ebx
+[ 	]*[a-f0-9]+:	81 e1 b9 01 60 00    	and    \$0x6001b9,%ecx
+[ 	]*[a-f0-9]+:	81 fa b9 01 60 00    	cmp    \$0x6001b9,%edx
+[ 	]*[a-f0-9]+:	81 ce b9 01 60 00    	or     \$0x6001b9,%esi
+[ 	]*[a-f0-9]+:	81 df b9 01 60 00    	sbb    \$0x6001b9,%edi
+[ 	]*[a-f0-9]+:	81 ed b9 01 60 00    	sub    \$0x6001b9,%ebp
+[ 	]*[a-f0-9]+:	41 81 f0 b9 01 60 00 	xor    \$0x6001b9,%r8d
+[ 	]*[a-f0-9]+:	41 f7 c7 b9 01 60 00 	test   \$0x6001b9,%r15d
+[ 	]*[a-f0-9]+:	48 81 d0 b9 01 60 00 	adc    \$0x6001b9,%rax
+[ 	]*[a-f0-9]+:	48 81 c3 b9 01 60 00 	add    \$0x6001b9,%rbx
+[ 	]*[a-f0-9]+:	48 81 e1 b9 01 60 00 	and    \$0x6001b9,%rcx
+[ 	]*[a-f0-9]+:	48 81 fa b9 01 60 00 	cmp    \$0x6001b9,%rdx
+[ 	]*[a-f0-9]+:	48 81 cf b9 01 60 00 	or     \$0x6001b9,%rdi
+[ 	]*[a-f0-9]+:	48 81 de b9 01 60 00 	sbb    \$0x6001b9,%rsi
+[ 	]*[a-f0-9]+:	48 81 ed b9 01 60 00 	sub    \$0x6001b9,%rbp
+[ 	]*[a-f0-9]+:	49 81 f0 b9 01 60 00 	xor    \$0x6001b9,%r8
+[ 	]*[a-f0-9]+:	49 f7 c7 b9 01 60 00 	test   \$0x6001b9,%r15
+#pass
diff --git a/ld/testsuite/ld-x86-64/load1b-nacl.d b/ld/testsuite/ld-x86-64/load1b-nacl.d
new file mode 100644
index 0000000..b6fa43d
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/load1b-nacl.d
@@ -0,0 +1,55 @@
+#source: load1.s
+#as: --x32
+#ld: -melf32_x86_64
+#objdump: -dw --sym
+#target: x86_64-*-nacl*
+
+.*: +file format .*
+
+SYMBOL TABLE:
+#...
+1003008c l     O .data	0+1 bar
+#...
+1003008d g     O .data	0+1 foo
+#...
+
+Disassembly of section .text:
+
+0+20000 <_start>:
+[ 	]*[a-f0-9]+:	81 d0 8c 00 03 10    	adc    \$0x1003008c,%eax
+[ 	]*[a-f0-9]+:	81 c3 8c 00 03 10    	add    \$0x1003008c,%ebx
+[ 	]*[a-f0-9]+:	81 e1 8c 00 03 10    	and    \$0x1003008c,%ecx
+[ 	]*[a-f0-9]+:	81 fa 8c 00 03 10    	cmp    \$0x1003008c,%edx
+[ 	]*[a-f0-9]+:	81 ce 8c 00 03 10    	or     \$0x1003008c,%esi
+[ 	]*[a-f0-9]+:	81 df 8c 00 03 10    	sbb    \$0x1003008c,%edi
+[ 	]*[a-f0-9]+:	81 ed 8c 00 03 10    	sub    \$0x1003008c,%ebp
+[ 	]*[a-f0-9]+:	41 81 f0 8c 00 03 10 	xor    \$0x1003008c,%r8d
+[ 	]*[a-f0-9]+:	41 f7 c7 8c 00 03 10 	test   \$0x1003008c,%r15d
+[ 	]*[a-f0-9]+:	48 81 d0 8c 00 03 10 	adc    \$0x1003008c,%rax
+[ 	]*[a-f0-9]+:	48 81 c3 8c 00 03 10 	add    \$0x1003008c,%rbx
+[ 	]*[a-f0-9]+:	48 81 e1 8c 00 03 10 	and    \$0x1003008c,%rcx
+[ 	]*[a-f0-9]+:	48 81 fa 8c 00 03 10 	cmp    \$0x1003008c,%rdx
+[ 	]*[a-f0-9]+:	48 81 cf 8c 00 03 10 	or     \$0x1003008c,%rdi
+[ 	]*[a-f0-9]+:	48 81 de 8c 00 03 10 	sbb    \$0x1003008c,%rsi
+[ 	]*[a-f0-9]+:	48 81 ed 8c 00 03 10 	sub    \$0x1003008c,%rbp
+[ 	]*[a-f0-9]+:	49 81 f0 8c 00 03 10 	xor    \$0x1003008c,%r8
+[ 	]*[a-f0-9]+:	49 f7 c7 8c 00 03 10 	test   \$0x1003008c,%r15
+[ 	]*[a-f0-9]+:	81 d0 8d 00 03 10    	adc    \$0x1003008d,%eax
+[ 	]*[a-f0-9]+:	81 c3 8d 00 03 10    	add    \$0x1003008d,%ebx
+[ 	]*[a-f0-9]+:	81 e1 8d 00 03 10    	and    \$0x1003008d,%ecx
+[ 	]*[a-f0-9]+:	81 fa 8d 00 03 10    	cmp    \$0x1003008d,%edx
+[ 	]*[a-f0-9]+:	81 ce 8d 00 03 10    	or     \$0x1003008d,%esi
+[ 	]*[a-f0-9]+:	81 df 8d 00 03 10    	sbb    \$0x1003008d,%edi
+[ 	]*[a-f0-9]+:	81 ed 8d 00 03 10    	sub    \$0x1003008d,%ebp
+[ 	]*[a-f0-9]+:	41 81 f0 8d 00 03 10 	xor    \$0x1003008d,%r8d
+[ 	]*[a-f0-9]+:	41 f7 c7 8d 00 03 10 	test   \$0x1003008d,%r15d
+[ 	]*[a-f0-9]+:	48 81 d0 8d 00 03 10 	adc    \$0x1003008d,%rax
+[ 	]*[a-f0-9]+:	48 81 c3 8d 00 03 10 	add    \$0x1003008d,%rbx
+[ 	]*[a-f0-9]+:	48 81 e1 8d 00 03 10 	and    \$0x1003008d,%rcx
+[ 	]*[a-f0-9]+:	48 81 fa 8d 00 03 10 	cmp    \$0x1003008d,%rdx
+[ 	]*[a-f0-9]+:	48 81 cf 8d 00 03 10 	or     \$0x1003008d,%rdi
+[ 	]*[a-f0-9]+:	48 81 de 8d 00 03 10 	sbb    \$0x1003008d,%rsi
+[ 	]*[a-f0-9]+:	48 81 ed 8d 00 03 10 	sub    \$0x1003008d,%rbp
+[ 	]*[a-f0-9]+:	49 81 f0 8d 00 03 10 	xor    \$0x1003008d,%r8
+[ 	]*[a-f0-9]+:	49 f7 c7 8d 00 03 10 	test   \$0x1003008d,%r15
+#pass
diff --git a/ld/testsuite/ld-x86-64/load1b.d b/ld/testsuite/ld-x86-64/load1b.d
new file mode 100644
index 0000000..70ef274
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/load1b.d
@@ -0,0 +1,56 @@
+#source: load1.s
+#as: --x32
+#ld: -melf32_x86_64
+#objdump: -dw --sym
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+SYMBOL TABLE:
+#...
+0+60017c l     O .data	0+1 bar
+#...
+0+60017d g     O .data	0+1 foo
+#...
+
+
+Disassembly of section .text:
+
+0+400074 <_start>:
+[ 	]*[a-f0-9]+:	81 d0 7c 01 60 00    	adc    \$0x60017c,%eax
+[ 	]*[a-f0-9]+:	81 c3 7c 01 60 00    	add    \$0x60017c,%ebx
+[ 	]*[a-f0-9]+:	81 e1 7c 01 60 00    	and    \$0x60017c,%ecx
+[ 	]*[a-f0-9]+:	81 fa 7c 01 60 00    	cmp    \$0x60017c,%edx
+[ 	]*[a-f0-9]+:	81 ce 7c 01 60 00    	or     \$0x60017c,%esi
+[ 	]*[a-f0-9]+:	81 df 7c 01 60 00    	sbb    \$0x60017c,%edi
+[ 	]*[a-f0-9]+:	81 ed 7c 01 60 00    	sub    \$0x60017c,%ebp
+[ 	]*[a-f0-9]+:	41 81 f0 7c 01 60 00 	xor    \$0x60017c,%r8d
+[ 	]*[a-f0-9]+:	41 f7 c7 7c 01 60 00 	test   \$0x60017c,%r15d
+[ 	]*[a-f0-9]+:	48 81 d0 7c 01 60 00 	adc    \$0x60017c,%rax
+[ 	]*[a-f0-9]+:	48 81 c3 7c 01 60 00 	add    \$0x60017c,%rbx
+[ 	]*[a-f0-9]+:	48 81 e1 7c 01 60 00 	and    \$0x60017c,%rcx
+[ 	]*[a-f0-9]+:	48 81 fa 7c 01 60 00 	cmp    \$0x60017c,%rdx
+[ 	]*[a-f0-9]+:	48 81 cf 7c 01 60 00 	or     \$0x60017c,%rdi
+[ 	]*[a-f0-9]+:	48 81 de 7c 01 60 00 	sbb    \$0x60017c,%rsi
+[ 	]*[a-f0-9]+:	48 81 ed 7c 01 60 00 	sub    \$0x60017c,%rbp
+[ 	]*[a-f0-9]+:	49 81 f0 7c 01 60 00 	xor    \$0x60017c,%r8
+[ 	]*[a-f0-9]+:	49 f7 c7 7c 01 60 00 	test   \$0x60017c,%r15
+[ 	]*[a-f0-9]+:	81 d0 7d 01 60 00    	adc    \$0x60017d,%eax
+[ 	]*[a-f0-9]+:	81 c3 7d 01 60 00    	add    \$0x60017d,%ebx
+[ 	]*[a-f0-9]+:	81 e1 7d 01 60 00    	and    \$0x60017d,%ecx
+[ 	]*[a-f0-9]+:	81 fa 7d 01 60 00    	cmp    \$0x60017d,%edx
+[ 	]*[a-f0-9]+:	81 ce 7d 01 60 00    	or     \$0x60017d,%esi
+[ 	]*[a-f0-9]+:	81 df 7d 01 60 00    	sbb    \$0x60017d,%edi
+[ 	]*[a-f0-9]+:	81 ed 7d 01 60 00    	sub    \$0x60017d,%ebp
+[ 	]*[a-f0-9]+:	41 81 f0 7d 01 60 00 	xor    \$0x60017d,%r8d
+[ 	]*[a-f0-9]+:	41 f7 c7 7d 01 60 00 	test   \$0x60017d,%r15d
+[ 	]*[a-f0-9]+:	48 81 d0 7d 01 60 00 	adc    \$0x60017d,%rax
+[ 	]*[a-f0-9]+:	48 81 c3 7d 01 60 00 	add    \$0x60017d,%rbx
+[ 	]*[a-f0-9]+:	48 81 e1 7d 01 60 00 	and    \$0x60017d,%rcx
+[ 	]*[a-f0-9]+:	48 81 fa 7d 01 60 00 	cmp    \$0x60017d,%rdx
+[ 	]*[a-f0-9]+:	48 81 cf 7d 01 60 00 	or     \$0x60017d,%rdi
+[ 	]*[a-f0-9]+:	48 81 de 7d 01 60 00 	sbb    \$0x60017d,%rsi
+[ 	]*[a-f0-9]+:	48 81 ed 7d 01 60 00 	sub    \$0x60017d,%rbp
+[ 	]*[a-f0-9]+:	49 81 f0 7d 01 60 00 	xor    \$0x60017d,%r8
+[ 	]*[a-f0-9]+:	49 f7 c7 7d 01 60 00 	test   \$0x60017d,%r15
+#pass
diff --git a/ld/testsuite/ld-x86-64/load1c-nacl.d b/ld/testsuite/ld-x86-64/load1c-nacl.d
new file mode 100644
index 0000000..497006a
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/load1c-nacl.d
@@ -0,0 +1,48 @@
+#source: load1.s
+#as: --64
+#ld: -shared -melf_x86_64
+#objdump: -dw
+#target: x86_64-*-nacl*
+
+.*: +file format .*
+
+Disassembly of section .text:
+
+0+ <_start>:
+[ 	]*[a-f0-9]+:	13 05 22 03 01 10    	adc    0x10010322\(%rip\),%eax        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	03 1d 1c 03 01 10    	add    0x1001031c\(%rip\),%ebx        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	23 0d 16 03 01 10    	and    0x10010316\(%rip\),%ecx        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	3b 15 10 03 01 10    	cmp    0x10010310\(%rip\),%edx        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	0b 35 0a 03 01 10    	or     0x1001030a\(%rip\),%esi        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	1b 3d 04 03 01 10    	sbb    0x10010304\(%rip\),%edi        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	2b 2d fe 02 01 10    	sub    0x100102fe\(%rip\),%ebp        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	44 33 05 f7 02 01 10 	xor    0x100102f7\(%rip\),%r8d        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	44 85 3d f0 02 01 10 	test   %r15d,0x100102f0\(%rip\)        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 13 05 e9 02 01 10 	adc    0x100102e9\(%rip\),%rax        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 03 1d e2 02 01 10 	add    0x100102e2\(%rip\),%rbx        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 23 0d db 02 01 10 	and    0x100102db\(%rip\),%rcx        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 3b 15 d4 02 01 10 	cmp    0x100102d4\(%rip\),%rdx        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 0b 3d cd 02 01 10 	or     0x100102cd\(%rip\),%rdi        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 1b 35 c6 02 01 10 	sbb    0x100102c6\(%rip\),%rsi        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 2b 2d bf 02 01 10 	sub    0x100102bf\(%rip\),%rbp        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	4c 33 05 b8 02 01 10 	xor    0x100102b8\(%rip\),%r8        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	4c 85 3d b1 02 01 10 	test   %r15,0x100102b1\(%rip\)        # 10010328 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	13 05 b3 02 01 10    	adc    0x100102b3\(%rip\),%eax        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	03 1d ad 02 01 10    	add    0x100102ad\(%rip\),%ebx        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	23 0d a7 02 01 10    	and    0x100102a7\(%rip\),%ecx        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	3b 15 a1 02 01 10    	cmp    0x100102a1\(%rip\),%edx        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	0b 35 9b 02 01 10    	or     0x1001029b\(%rip\),%esi        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	1b 3d 95 02 01 10    	sbb    0x10010295\(%rip\),%edi        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	2b 2d 8f 02 01 10    	sub    0x1001028f\(%rip\),%ebp        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	44 33 05 88 02 01 10 	xor    0x10010288\(%rip\),%r8d        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	44 85 3d 81 02 01 10 	test   %r15d,0x10010281\(%rip\)        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 13 05 7a 02 01 10 	adc    0x1001027a\(%rip\),%rax        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 03 1d 73 02 01 10 	add    0x10010273\(%rip\),%rbx        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 23 0d 6c 02 01 10 	and    0x1001026c\(%rip\),%rcx        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 3b 15 65 02 01 10 	cmp    0x10010265\(%rip\),%rdx        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 0b 3d 5e 02 01 10 	or     0x1001025e\(%rip\),%rdi        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 1b 35 57 02 01 10 	sbb    0x10010257\(%rip\),%rsi        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 2b 2d 50 02 01 10 	sub    0x10010250\(%rip\),%rbp        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	4c 33 05 49 02 01 10 	xor    0x10010249\(%rip\),%r8        # 10010330 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	4c 85 3d 42 02 01 10 	test   %r15,0x10010242\(%rip\)        # 10010330 <_DYNAMIC\+0xe8>
+#pass
diff --git a/ld/testsuite/ld-x86-64/load1c.d b/ld/testsuite/ld-x86-64/load1c.d
new file mode 100644
index 0000000..b589d97
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/load1c.d
@@ -0,0 +1,48 @@
+#source: load1.s
+#as: --64
+#ld: -shared -melf_x86_64
+#objdump: -dw
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+Disassembly of section .text:
+
+[a-f0-9]+ <_start>:
+[ 	]*[a-f0-9]+:	13 05 ca 01 20 00    	adc    0x2001ca\(%rip\),%eax        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	03 1d c4 01 20 00    	add    0x2001c4\(%rip\),%ebx        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	23 0d be 01 20 00    	and    0x2001be\(%rip\),%ecx        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	3b 15 b8 01 20 00    	cmp    0x2001b8\(%rip\),%edx        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	0b 35 b2 01 20 00    	or     0x2001b2\(%rip\),%esi        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	1b 3d ac 01 20 00    	sbb    0x2001ac\(%rip\),%edi        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	2b 2d a6 01 20 00    	sub    0x2001a6\(%rip\),%ebp        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	44 33 05 9f 01 20 00 	xor    0x20019f\(%rip\),%r8d        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	44 85 3d 98 01 20 00 	test   %r15d,0x200198\(%rip\)        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 13 05 91 01 20 00 	adc    0x200191\(%rip\),%rax        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 03 1d 8a 01 20 00 	add    0x20018a\(%rip\),%rbx        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 23 0d 83 01 20 00 	and    0x200183\(%rip\),%rcx        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 3b 15 7c 01 20 00 	cmp    0x20017c\(%rip\),%rdx        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 0b 3d 75 01 20 00 	or     0x200175\(%rip\),%rdi        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 1b 35 6e 01 20 00 	sbb    0x20016e\(%rip\),%rsi        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	48 2b 2d 67 01 20 00 	sub    0x200167\(%rip\),%rbp        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	4c 33 05 60 01 20 00 	xor    0x200160\(%rip\),%r8        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	4c 85 3d 59 01 20 00 	test   %r15,0x200159\(%rip\)        # 2003e0 <_DYNAMIC\+0xe0>
+[ 	]*[a-f0-9]+:	13 05 5b 01 20 00    	adc    0x20015b\(%rip\),%eax        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	03 1d 55 01 20 00    	add    0x200155\(%rip\),%ebx        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	23 0d 4f 01 20 00    	and    0x20014f\(%rip\),%ecx        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	3b 15 49 01 20 00    	cmp    0x200149\(%rip\),%edx        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	0b 35 43 01 20 00    	or     0x200143\(%rip\),%esi        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	1b 3d 3d 01 20 00    	sbb    0x20013d\(%rip\),%edi        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	2b 2d 37 01 20 00    	sub    0x200137\(%rip\),%ebp        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	44 33 05 30 01 20 00 	xor    0x200130\(%rip\),%r8d        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	44 85 3d 29 01 20 00 	test   %r15d,0x200129\(%rip\)        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 13 05 22 01 20 00 	adc    0x200122\(%rip\),%rax        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 03 1d 1b 01 20 00 	add    0x20011b\(%rip\),%rbx        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 23 0d 14 01 20 00 	and    0x200114\(%rip\),%rcx        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 3b 15 0d 01 20 00 	cmp    0x20010d\(%rip\),%rdx        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 0b 3d 06 01 20 00 	or     0x200106\(%rip\),%rdi        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 1b 35 ff 00 20 00 	sbb    0x2000ff\(%rip\),%rsi        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	48 2b 2d f8 00 20 00 	sub    0x2000f8\(%rip\),%rbp        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	4c 33 05 f1 00 20 00 	xor    0x2000f1\(%rip\),%r8        # 2003e8 <_DYNAMIC\+0xe8>
+[ 	]*[a-f0-9]+:	4c 85 3d ea 00 20 00 	test   %r15,0x2000ea\(%rip\)        # 2003e8 <_DYNAMIC\+0xe8>
+#pass
diff --git a/ld/testsuite/ld-x86-64/load1d-nacl.d b/ld/testsuite/ld-x86-64/load1d-nacl.d
new file mode 100644
index 0000000..97fd749
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/load1d-nacl.d
@@ -0,0 +1,48 @@
+#source: load1.s
+#as: --x32
+#ld: -shared -melf32_x86_64
+#objdump: -dw
+#target: x86_64-*-nacl*
+
+.*: +file format .*
+
+Disassembly of section .text:
+
+0+ <_start>:
+[ 	]*[a-f0-9]+:	13 05 fa 01 01 10    	adc    0x100101fa\(%rip\),%eax        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	03 1d f4 01 01 10    	add    0x100101f4\(%rip\),%ebx        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	23 0d ee 01 01 10    	and    0x100101ee\(%rip\),%ecx        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	3b 15 e8 01 01 10    	cmp    0x100101e8\(%rip\),%edx        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	0b 35 e2 01 01 10    	or     0x100101e2\(%rip\),%esi        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	1b 3d dc 01 01 10    	sbb    0x100101dc\(%rip\),%edi        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	2b 2d d6 01 01 10    	sub    0x100101d6\(%rip\),%ebp        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	44 33 05 cf 01 01 10 	xor    0x100101cf\(%rip\),%r8d        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	44 85 3d c8 01 01 10 	test   %r15d,0x100101c8\(%rip\)        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 13 05 c1 01 01 10 	adc    0x100101c1\(%rip\),%rax        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 03 1d ba 01 01 10 	add    0x100101ba\(%rip\),%rbx        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 23 0d b3 01 01 10 	and    0x100101b3\(%rip\),%rcx        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 3b 15 ac 01 01 10 	cmp    0x100101ac\(%rip\),%rdx        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 0b 3d a5 01 01 10 	or     0x100101a5\(%rip\),%rdi        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 1b 35 9e 01 01 10 	sbb    0x1001019e\(%rip\),%rsi        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 2b 2d 97 01 01 10 	sub    0x10010197\(%rip\),%rbp        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	4c 33 05 90 01 01 10 	xor    0x10010190\(%rip\),%r8        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	4c 85 3d 89 01 01 10 	test   %r15,0x10010189\(%rip\)        # 10010200 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	13 05 8b 01 01 10    	adc    0x1001018b\(%rip\),%eax        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	03 1d 85 01 01 10    	add    0x10010185\(%rip\),%ebx        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	23 0d 7f 01 01 10    	and    0x1001017f\(%rip\),%ecx        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	3b 15 79 01 01 10    	cmp    0x10010179\(%rip\),%edx        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	0b 35 73 01 01 10    	or     0x10010173\(%rip\),%esi        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	1b 3d 6d 01 01 10    	sbb    0x1001016d\(%rip\),%edi        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	2b 2d 67 01 01 10    	sub    0x10010167\(%rip\),%ebp        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	44 33 05 60 01 01 10 	xor    0x10010160\(%rip\),%r8d        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	44 85 3d 59 01 01 10 	test   %r15d,0x10010159\(%rip\)        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 13 05 52 01 01 10 	adc    0x10010152\(%rip\),%rax        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 03 1d 4b 01 01 10 	add    0x1001014b\(%rip\),%rbx        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 23 0d 44 01 01 10 	and    0x10010144\(%rip\),%rcx        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 3b 15 3d 01 01 10 	cmp    0x1001013d\(%rip\),%rdx        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 0b 3d 36 01 01 10 	or     0x10010136\(%rip\),%rdi        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 1b 35 2f 01 01 10 	sbb    0x1001012f\(%rip\),%rsi        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 2b 2d 28 01 01 10 	sub    0x10010128\(%rip\),%rbp        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	4c 33 05 21 01 01 10 	xor    0x10010121\(%rip\),%r8        # 10010208 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	4c 85 3d 1a 01 01 10 	test   %r15,0x1001011a\(%rip\)        # 10010208 <_DYNAMIC\+0x78>
+#pass
diff --git a/ld/testsuite/ld-x86-64/load1d.d b/ld/testsuite/ld-x86-64/load1d.d
new file mode 100644
index 0000000..ec07c4f
--- /dev/null
+++ b/ld/testsuite/ld-x86-64/load1d.d
@@ -0,0 +1,48 @@
+#source: load1.s
+#as: --x32
+#ld: -shared -melf32_x86_64
+#objdump: -dw
+#notarget: x86_64-*-nacl*
+
+.*: +file format .*
+
+Disassembly of section .text:
+
+0+[a-f0-9]+ <_start>:
+[ 	]*[a-f0-9]+:	13 05 5e 01 20 00    	adc    0x20015e\(%rip\),%eax        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	03 1d 58 01 20 00    	add    0x200158\(%rip\),%ebx        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	23 0d 52 01 20 00    	and    0x200152\(%rip\),%ecx        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	3b 15 4c 01 20 00    	cmp    0x20014c\(%rip\),%edx        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	0b 35 46 01 20 00    	or     0x200146\(%rip\),%esi        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	1b 3d 40 01 20 00    	sbb    0x200140\(%rip\),%edi        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	2b 2d 3a 01 20 00    	sub    0x20013a\(%rip\),%ebp        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	44 33 05 33 01 20 00 	xor    0x200133\(%rip\),%r8d        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	44 85 3d 2c 01 20 00 	test   %r15d,0x20012c\(%rip\)        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 13 05 25 01 20 00 	adc    0x200125\(%rip\),%rax        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 03 1d 1e 01 20 00 	add    0x20011e\(%rip\),%rbx        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 23 0d 17 01 20 00 	and    0x200117\(%rip\),%rcx        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 3b 15 10 01 20 00 	cmp    0x200110\(%rip\),%rdx        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 0b 3d 09 01 20 00 	or     0x200109\(%rip\),%rdi        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 1b 35 02 01 20 00 	sbb    0x200102\(%rip\),%rsi        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	48 2b 2d fb 00 20 00 	sub    0x2000fb\(%rip\),%rbp        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	4c 33 05 f4 00 20 00 	xor    0x2000f4\(%rip\),%r8        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	4c 85 3d ed 00 20 00 	test   %r15,0x2000ed\(%rip\)        # 2002d0 <_DYNAMIC\+0x70>
+[ 	]*[a-f0-9]+:	13 05 ef 00 20 00    	adc    0x2000ef\(%rip\),%eax        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	03 1d e9 00 20 00    	add    0x2000e9\(%rip\),%ebx        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	23 0d e3 00 20 00    	and    0x2000e3\(%rip\),%ecx        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	3b 15 dd 00 20 00    	cmp    0x2000dd\(%rip\),%edx        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	0b 35 d7 00 20 00    	or     0x2000d7\(%rip\),%esi        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	1b 3d d1 00 20 00    	sbb    0x2000d1\(%rip\),%edi        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	2b 2d cb 00 20 00    	sub    0x2000cb\(%rip\),%ebp        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	44 33 05 c4 00 20 00 	xor    0x2000c4\(%rip\),%r8d        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	44 85 3d bd 00 20 00 	test   %r15d,0x2000bd\(%rip\)        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 13 05 b6 00 20 00 	adc    0x2000b6\(%rip\),%rax        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 03 1d af 00 20 00 	add    0x2000af\(%rip\),%rbx        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 23 0d a8 00 20 00 	and    0x2000a8\(%rip\),%rcx        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 3b 15 a1 00 20 00 	cmp    0x2000a1\(%rip\),%rdx        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 0b 3d 9a 00 20 00 	or     0x20009a\(%rip\),%rdi        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 1b 35 93 00 20 00 	sbb    0x200093\(%rip\),%rsi        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	48 2b 2d 8c 00 20 00 	sub    0x20008c\(%rip\),%rbp        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	4c 33 05 85 00 20 00 	xor    0x200085\(%rip\),%r8        # 2002d8 <_DYNAMIC\+0x78>
+[ 	]*[a-f0-9]+:	4c 85 3d 7e 00 20 00 	test   %r15,0x20007e\(%rip\)        # 2002d8 <_DYNAMIC\+0x78>
+#pass
diff --git a/ld/testsuite/ld-x86-64/plt-main1.rd b/ld/testsuite/ld-x86-64/plt-main1.rd
index 421d911..36fa8ef 100644
--- a/ld/testsuite/ld-x86-64/plt-main1.rd
+++ b/ld/testsuite/ld-x86-64/plt-main1.rd
@@ -1,3 +1,3 @@
 #...
-[0-9a-f ]+R_X86_64_GOTPCREL +0+ +bar - 4
+[0-9a-f ]+R_X86_64_(REX_|)GOTPCRELX +0+ +bar - 4
 #pass
diff --git a/ld/testsuite/ld-x86-64/plt-main3.rd b/ld/testsuite/ld-x86-64/plt-main3.rd
index f3d294e..0a0d402 100644
--- a/ld/testsuite/ld-x86-64/plt-main3.rd
+++ b/ld/testsuite/ld-x86-64/plt-main3.rd
@@ -1,5 +1,5 @@
 #...
-[0-9a-f ]+R_X86_64_GOTPCREL +0+ +bar - 4
+[0-9a-f ]+R_X86_64_(REX_GOTPCRELX|GOTPCREL) +0+ +bar - 4
 #...
 [0-9a-f ]+R_X86_64_PLT32 +0+ +bar - 4
 #pass
diff --git a/ld/testsuite/ld-x86-64/plt-main4.rd b/ld/testsuite/ld-x86-64/plt-main4.rd
index 7f33f3a..d391fc0 100644
--- a/ld/testsuite/ld-x86-64/plt-main4.rd
+++ b/ld/testsuite/ld-x86-64/plt-main4.rd
@@ -1,5 +1,5 @@
 #...
-[0-9a-f ]+R_X86_64_GOTPCREL +0+ +foo - 4
+[0-9a-f ]+R_X86_64_(REX_|)GOTPCRELX +0+ +foo - 4
 #...
 [0-9a-f ]+R_X86_64_PLT32 +0+ +foo - 4
 #pass
diff --git a/ld/testsuite/ld-x86-64/x86-64.exp b/ld/testsuite/ld-x86-64/x86-64.exp
index 69728c2..6caea5f 100644
--- a/ld/testsuite/ld-x86-64/x86-64.exp
+++ b/ld/testsuite/ld-x86-64/x86-64.exp
@@ -321,6 +321,23 @@ run_dump_test "mov1a"
 run_dump_test "mov1b"
 run_dump_test "mov1c"
 run_dump_test "mov1d"
+run_dump_test "load1a"
+run_dump_test "load1b"
+run_dump_test "load1c"
+run_dump_test "load1d"
+run_dump_test "load1a-nacl"
+run_dump_test "load1b-nacl"
+run_dump_test "load1c-nacl"
+run_dump_test "load1d-nacl"
+run_dump_test "call1a"
+run_dump_test "call1b"
+run_dump_test "call1c"
+run_dump_test "call1d"
+run_dump_test "call1e"
+run_dump_test "call1f"
+run_dump_test "call1g"
+run_dump_test "call1h"
+run_dump_test "call1i"
 run_dump_test "pr17935-1"
 run_dump_test "pr17935-2"
 run_dump_test "pr18160"
@@ -511,6 +528,22 @@ if { [isnative] && [which $CC] != 0 } {
 	    "" \
 	    "pr19031.so" \
 	] \
+	[list \
+	    "Build gotpcrel1d.so" \
+	    "-shared" \
+	    "" \
+	    { gotpcrel1d.S } \
+	    "" \
+	    "gotpcrel1d.so" \
+	] \
+	[list \
+	    "Build gotpcrel1" \
+	    "tmpdir/gotpcrel1d.so" \
+	    "" \
+	    { gotpcrel1a.S gotpcrel1b.c gotpcrel1c.c } \
+	    {{objdump {-dw} gotpcrel1.dd}} \
+	    "gotpcrel1" \
+	] \
     ]
 
     run_ld_link_exec_tests [] [list \
@@ -573,6 +606,14 @@ if { [isnative] && [which $CC] != 0 } {
 	    "pr19031" \
 	    "pr19031.out" \
 	] \
+	[list \
+	    "Run gotpcrel1" \
+	    "tmpdir/gotpcrel1d.so" \
+	    "" \
+	    { gotpcrel1a.S gotpcrel1b.c gotpcrel1c.c } \
+	    "gotpcrel1" \
+	    "gotpcrel1.out" \
+	] \
     ]
 
     if { [istarget "x86_64-*-linux*"] \
