From e2129ff5d41290bfedbe106e914e855ff98b1692 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Wed, 28 Oct 2015 04:28:33 -0700
Subject: [PATCH] Check R_386_GOT32/R_386_GOT32X without base register

The R_386_GOT32 and R_386_GOT32X relocations may be used without base
register:

	movl	bar@GOT, %eax

Its calculation is G + A, instead of G + A - GOT, and it can only used
to generate non-PIC executable.  Include the .got.plt section address
for R_386_GOT32 and R_386_GOT32X relocations without base register.
Don't allow R_386_GOT32 and R_386_GOT32X relocations without base
register when making a PIC output.

	PR gold/19177
	* i386.cc (Target_i386::Relocate::relocate): Check R_386_GOT32
	and R_386_GOT32X relocations without base register.
---
 gold/i386.cc | 28 ++++++++++++++++++++++++++--
 1 file changed, 26 insertions(+), 2 deletions(-)

diff --git a/gold/i386.cc b/gold/i386.cc
index 36c5724..5081662 100644
--- a/gold/i386.cc
+++ b/gold/i386.cc
@@ -2790,6 +2790,8 @@ Target_i386::Relocate::relocate(const Relocate_info<32, false>* relinfo,
 	}
     }
 
+  bool baseless;
+
   switch (r_type)
     {
     case elfcpp::R_386_NONE:
@@ -2839,6 +2841,22 @@ Target_i386::Relocate::relocate(const Relocate_info<32, false>* relinfo,
 
     case elfcpp::R_386_GOT32:
     case elfcpp::R_386_GOT32X:
+      baseless = (view[-1] & 0xc7) == 0x5;
+      // R_386_GOT32 and R_386_GOT32X don't work without base register
+      // when making a PIC output.
+      if (baseless
+	  && parameters->options().output_is_position_independent())
+	{
+	  if(gsym)
+	    gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
+				   _("unexpected reloc %u against global symbol %s without base register in object file when making a PIC output"),
+				   r_type, gsym->demangled_name().c_str());
+	  else
+	    gold_error_at_location(relinfo, relnum, rel.get_r_offset(),
+				   _("unexpected reloc %u against local symbol without base register in object file when making a PIC output"),
+				   r_type);
+	}
+
       // Convert
       // mov foo@GOT(%reg), %reg
       // to
@@ -2852,8 +2870,11 @@ Target_i386::Relocate::relocate(const Relocate_info<32, false>* relinfo,
 	{
 	  view[-2] = 0x8d;
 	  elfcpp::Elf_types<32>::Elf_Addr value;
-	  value = (psymval->value(object, 0)
-	           - target->got_plt_section()->address());
+	  value = psymval->value(object, 0);
+	  // Don't subtract the .got.plt section address for baseless
+	  // adressing.
+	  if (!baseless)
+	    value -= target->got_plt_section()->address();
 	  Relocate_functions<32, false>::rel32(view, value);
 	}
       else
@@ -2875,6 +2896,9 @@ Target_i386::Relocate::relocate(const Relocate_info<32, false>* relinfo,
 	      got_offset = (object->local_got_offset(r_sym, GOT_TYPE_STANDARD)
 			    - target->got_size());
 	    }
+	  // Add the .got.plt section address for baseless adressing.
+	  if (baseless)
+	    got_offset += target->got_plt_section()->address();
 	  Relocate_functions<32, false>::rel32(view, got_offset);
 	}
       break;
-- 
2.4.3

