From f52fce2f3a1449c4081d3c4a06446ad2c5d2d539 Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Wed, 13 Sep 2017 12:27:59 -0700
Subject: [PATCH 2/2] x86: Add elf_x86_backend_data

Add plt0_pad_byte and target_os fields to elf_x86_link_hash_table.
Replace elf_i386_backend_data and elf_x86_64_backend_data with
elf_x86_backend_data.

	* elf32-i386.c (elf_i386_backend_data): Removed.
	(get_elf_i386_backend_data): Likewise.
	(elf_i386_arch_bed): Replace elf_i386_backend_data with
	elf_x86_backend_data.
	(elf_i386_get_synthetic_symtab): Likewise.
	(elf_i386_nacl_arch_bed): Likewise.
	(elf_i386_vxworks_arch_bed): Likewise.
	(elf_i386_relocate_section): Check target_os instead of
	is_vxworks.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(elf_i386_finish_dynamic_sections): Use htab->plt0_pad_byte.
	Check target_os instead of is_vxworks.
	(elf_i386_link_setup_gnu_properties): Remove normal_target and
	is_vxworks.  Initialize plt0_pad_byte.
	* elf64-x86-64.c (elf_x86_64_backend_data); Removed.
	(get_elf_x86_64_arch_data): Likewise.
	(get_elf_x86_64_backend_data): Likewise.
	(elf_x86_64_arch_bed): Replace elf_x86_64_backend_data with
	elf_x86_backend_data.
	(elf_x86_64_get_synthetic_symtab): Likewise.
	(elf_x86_64_nacl_arch_bed): Likewise.
	(elf_x86_64_link_setup_gnu_properties): Remove is_vxworks and
	normal_target.  Initialize plt0_pad_byte.
	* elfxx-x86.c (elf_x86_allocate_dynrelocs): Check target_os
	instead of is_vxworks.
	(_bfd_x86_elf_size_dynamic_sections): Likewise.
	(_bfd_x86_elf_finish_dynamic_sections): Likewise.
	(_bfd_x86_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_x86_elf_link_hash_table_create): Initialize target_os.
	(_bfd_x86_elf_link_setup_gnu_properties): Remove is_vxworks.
	Update normal_target.  Set up plt0_pad_byte.  Check target_os
	instead of is_vxworks.
	* elfxx-x86.h (elf_x86_target_os): New.
	(elf_x86_backend_data): Likewise.
	(get_elf_x86_backend_data): Likewise.
	(elf_x86_link_hash_table): Remove is_vxworks.  Add plt0_pad_byte
	and target_os.
	(elf_x86_init_table): Remove normal_target and is_vxworks.  Add
	plt0_pad_byte.
---
 bfd/elf32-i386.c   | 53 +++++++++++++----------------------------------------
 bfd/elf64-x86-64.c | 35 +++++++++--------------------------
 bfd/elfxx-x86.c    | 28 +++++++++++++++-------------
 bfd/elfxx-x86.h    | 34 +++++++++++++++++++++++++---------
 4 files changed, 62 insertions(+), 88 deletions(-)

diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
index 2daa163cbf..f11db44f0d 100644
--- a/bfd/elf32-i386.c
+++ b/bfd/elf32-i386.c
@@ -820,30 +820,9 @@ static const struct elf_x86_non_lazy_plt_layout elf_i386_non_lazy_ibt_plt =
 #define PLTRESOLVE_RELOCS 2
 #define PLT_NON_JUMP_SLOT_RELOCS 2
 
-/* Architecture-specific backend data for i386.  */
-
-struct elf_i386_backend_data
-{
-  /* Value used to fill the unused bytes of the first PLT entry.  */
-  bfd_byte plt0_pad_byte;
-
-  /* Target system.  */
-  enum
-    {
-      is_normal,
-      is_vxworks,
-      is_nacl
-    } os;
-};
-
-#define get_elf_i386_backend_data(abfd) \
-  ((const struct elf_i386_backend_data *) \
-   get_elf_backend_data (abfd)->arch_data)
-
 /* These are the standard parameters.  */
-static const struct elf_i386_backend_data elf_i386_arch_bed =
+static const struct elf_x86_backend_data elf_i386_arch_bed =
   {
-    0,                                  /* plt0_pad_byte */
     is_normal                           /* os */
   };
 
@@ -2047,7 +2026,7 @@ elf_i386_relocate_section (bfd *output_bfd,
   local_tlsdesc_gotents = elf_x86_local_tlsdesc_gotent (input_bfd);
   /* We have to handle relocations in vxworks .tls_vars sections
      specially, because the dynamic loader is 'weird'.  */
-  is_vxworks_tls = (htab->is_vxworks
+  is_vxworks_tls = (htab->target_os == is_vxworks
                     && bfd_link_pic (info)
 		    && !strcmp (input_section->output_section->name,
 				".tls_vars"));
@@ -3714,7 +3693,7 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,
 		      resolved_plt->contents + plt_offset
                       + htab->plt.plt_got_offset);
 
-	  if (htab->is_vxworks)
+	  if (htab->target_os == is_vxworks)
 	    {
 	      int s, k, reloc_index;
 
@@ -4120,13 +4099,10 @@ elf_i386_finish_dynamic_sections (bfd *output_bfd,
 	{
 	  /* Fill in the special first entry in the procedure linkage
 	     table.  */
-	  const struct elf_i386_backend_data *abed
-	    = get_elf_i386_backend_data (output_bfd);
-
 	  memcpy (htab->elf.splt->contents, htab->plt.plt0_entry,
 		  htab->lazy_plt->plt0_entry_size);
 	  memset (htab->elf.splt->contents + htab->lazy_plt->plt0_entry_size,
-		  abed->plt0_pad_byte,
+		  htab->plt0_pad_byte,
 		  htab->plt.plt_entry_size - htab->lazy_plt->plt0_entry_size);
 	  if (!bfd_link_pic (info))
 	    {
@@ -4143,7 +4119,7 @@ elf_i386_finish_dynamic_sections (bfd *output_bfd,
 			  htab->elf.splt->contents
 			  + htab->lazy_plt->plt0_got2_offset);
 
-	      if (htab->is_vxworks)
+	      if (htab->target_os == is_vxworks)
 		{
 		  Elf_Internal_Rela rel;
 		  int num_plts = (htab->elf.splt->size
@@ -4284,7 +4260,7 @@ elf_i386_get_synthetic_symtab (bfd *abfd,
   lazy_plt = NULL;
   non_lazy_ibt_plt = NULL;
   lazy_ibt_plt = NULL;
-  switch (get_elf_i386_backend_data (abfd)->os)
+  switch (get_elf_x86_backend_data (abfd)->target_os)
     {
     case is_normal:
       non_lazy_plt = &elf_i386_non_lazy_plt;
@@ -4443,25 +4419,24 @@ elf_i386_link_setup_gnu_properties (struct bfd_link_info *info)
 {
   struct elf_x86_init_table init_table;
 
-  init_table.normal_target = FALSE;
-  init_table.is_vxworks = FALSE;
-  switch (get_elf_i386_backend_data (info->output_bfd)->os)
+  switch (get_elf_x86_backend_data (info->output_bfd)->target_os)
     {
     case is_normal:
+      init_table.plt0_pad_byte = 0x0;
       init_table.lazy_plt = &elf_i386_lazy_plt;
       init_table.non_lazy_plt = &elf_i386_non_lazy_plt;
       init_table.lazy_ibt_plt = &elf_i386_lazy_ibt_plt;
       init_table.non_lazy_ibt_plt = &elf_i386_non_lazy_ibt_plt;
-      init_table.normal_target = TRUE;
       break;
     case is_vxworks:
+      init_table.plt0_pad_byte = 0x90;
       init_table.lazy_plt = &elf_i386_lazy_plt;
       init_table.non_lazy_plt = NULL;
       init_table.lazy_ibt_plt = NULL;
       init_table.non_lazy_ibt_plt = NULL;
-      init_table.is_vxworks = TRUE;
       break;
     case is_nacl:
+      init_table.plt0_pad_byte = 0x90;
       init_table.lazy_plt = &elf_i386_nacl_plt;
       init_table.non_lazy_plt = NULL;
       init_table.lazy_ibt_plt = NULL;
@@ -4814,7 +4789,7 @@ static const bfd_byte elf_i386_nacl_eh_frame_plt[] =
      || PLT_FDE_LENGTH != 36                            \
      || PLT_FDE_START_OFFSET != 4 + PLT_CIE_LENGTH + 8  \
      || PLT_FDE_LEN_OFFSET != 4 + PLT_CIE_LENGTH + 12)
-# error "Need elf_i386_backend_data parameters for eh_frame_plt offsets!"
+# error "Need elf_x86_backend_data parameters for eh_frame_plt offsets!"
 #endif
     PLT_CIE_LENGTH, 0, 0, 0,		/* CIE length */
     0, 0, 0, 0,                         /* CIE ID */
@@ -4868,9 +4843,8 @@ static const struct elf_x86_lazy_plt_layout elf_i386_nacl_plt =
     sizeof (elf_i386_nacl_eh_frame_plt) /* eh_frame_plt_size */
   };
 
-static const struct elf_i386_backend_data elf_i386_nacl_arch_bed =
+static const struct elf_x86_backend_data elf_i386_nacl_arch_bed =
   {
-    0x90,                               /* plt0_pad_byte: nop insn */
     is_nacl                             /* os */
   };
 
@@ -4914,9 +4888,8 @@ elf32_i386_nacl_elf_object_p (bfd *abfd)
 #undef	elf_backend_plt_alignment
 #define elf_backend_plt_alignment	4
 
-static const struct elf_i386_backend_data elf_i386_vxworks_arch_bed =
+static const struct elf_x86_backend_data elf_i386_vxworks_arch_bed =
   {
-    0x90,                               /* plt0_pad_byte */
     is_vxworks                          /* os */
   };
 
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index fd58bd7139..188a24265a 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -816,24 +816,6 @@ static const bfd_byte elf_x86_64_eh_frame_non_lazy_plt[] =
   DW_CFA_nop, DW_CFA_nop, DW_CFA_nop
 };
 
-/* Architecture-specific backend data for x86-64.  */
-
-struct elf_x86_64_backend_data
-{
-  /* Target system.  */
-  enum
-    {
-      is_normal,
-      is_nacl
-    } os;
-};
-
-#define get_elf_x86_64_arch_data(bed) \
-  ((const struct elf_x86_64_backend_data *) (bed)->arch_data)
-
-#define get_elf_x86_64_backend_data(abfd) \
-  get_elf_x86_64_arch_data (get_elf_backend_data (abfd))
-
 /* These are the standard parameters.  */
 static const struct elf_x86_lazy_plt_layout elf_x86_64_lazy_plt =
   {
@@ -963,7 +945,7 @@ static const struct elf_x86_non_lazy_plt_layout elf_x32_non_lazy_ibt_plt =
     sizeof (elf_x86_64_eh_frame_non_lazy_plt) /* eh_frame_plt_size */
   };
 
-static const struct elf_x86_64_backend_data elf_x86_64_arch_bed =
+static const struct elf_x86_backend_data elf_x86_64_arch_bed =
   {
     is_normal                            /* os */
   };
@@ -4620,7 +4602,7 @@ elf_x86_64_get_synthetic_symtab (bfd *abfd,
   if (relsize <= 0)
     return -1;
 
-  if (get_elf_x86_64_backend_data (abfd)->os == is_normal)
+  if (get_elf_x86_backend_data (abfd)->target_os == is_normal)
     {
       lazy_plt = &elf_x86_64_lazy_plt;
       non_lazy_plt = &elf_x86_64_non_lazy_plt;
@@ -4968,8 +4950,11 @@ elf_x86_64_link_setup_gnu_properties (struct bfd_link_info *info)
 	  != (int) R_X86_64_GNU_VTENTRY))
     abort ();
 
-  init_table.is_vxworks = FALSE;
-  if (get_elf_x86_64_backend_data (info->output_bfd)->os == is_normal)
+  /* This is unused for x86-64.  */
+  init_table.plt0_pad_byte = 0x90;
+
+  if (get_elf_x86_backend_data (info->output_bfd)->target_os
+      == is_normal)
     {
       if (info->bndplt)
 	{
@@ -4992,7 +4977,6 @@ elf_x86_64_link_setup_gnu_properties (struct bfd_link_info *info)
 	  init_table.lazy_ibt_plt = &elf_x32_lazy_ibt_plt;
 	  init_table.non_lazy_ibt_plt = &elf_x32_non_lazy_ibt_plt;
 	}
-      init_table.normal_target = TRUE;
     }
   else
     {
@@ -5000,7 +4984,6 @@ elf_x86_64_link_setup_gnu_properties (struct bfd_link_info *info)
       init_table.non_lazy_plt = NULL;
       init_table.lazy_ibt_plt = NULL;
       init_table.non_lazy_ibt_plt = NULL;
-      init_table.normal_target = FALSE;
     }
 
   if (ABI_64_P (info->output_bfd))
@@ -5265,7 +5248,7 @@ static const bfd_byte elf_x86_64_nacl_eh_frame_plt[] =
      || PLT_FDE_LENGTH != 36                            \
      || PLT_FDE_START_OFFSET != 4 + PLT_CIE_LENGTH + 8  \
      || PLT_FDE_LEN_OFFSET != 4 + PLT_CIE_LENGTH + 12)
-# error "Need elf_x86_64_backend_data parameters for eh_frame_plt offsets!"
+# error "Need elf_x86_backend_data parameters for eh_frame_plt offsets!"
 #endif
     PLT_CIE_LENGTH, 0, 0, 0,	/* CIE length */
     0, 0, 0, 0,			/* CIE ID */
@@ -5319,7 +5302,7 @@ static const struct elf_x86_lazy_plt_layout elf_x86_64_nacl_plt =
     sizeof (elf_x86_64_nacl_eh_frame_plt)    /* eh_frame_plt_size */
   };
 
-static const struct elf_x86_64_backend_data elf_x86_64_nacl_arch_bed =
+static const struct elf_x86_backend_data elf_x86_64_nacl_arch_bed =
   {
     is_nacl                                  /* os */
   };
diff --git a/bfd/elfxx-x86.c b/bfd/elfxx-x86.c
index a0fe9d19ff..d78c1e485f 100644
--- a/bfd/elfxx-x86.c
+++ b/bfd/elfxx-x86.c
@@ -262,7 +262,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h,
 		}
 	    }
 
-	  if (htab->is_vxworks && !bfd_link_pic (info))
+	  if (htab->target_os == is_vxworks && !bfd_link_pic (info))
 	    {
 	      /* VxWorks has a second set of relocations for each PLT entry
 		 in executables.  They go in a separate relocation section,
@@ -406,7 +406,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h,
 	    }
 	}
 
-      if (htab->is_vxworks)
+      if (htab->target_os == is_vxworks)
 	{
 	  struct elf_dyn_relocs **pp;
 	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
@@ -799,6 +799,7 @@ _bfd_x86_elf_link_hash_table_create (bfd *abfd)
 	}
     }
   ret->target_id = bed->target_id;
+  ret->target_os = get_elf_x86_backend_data (abfd)->target_os;
 
   ret->loc_hash_table = htab_try_create (1024,
 					 _bfd_x86_elf_local_htab_hash,
@@ -924,7 +925,7 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,
 		     linker script /DISCARD/, so we'll be discarding
 		     the relocs too.  */
 		}
-	      else if (htab->is_vxworks
+	      else if (htab->target_os == is_vxworks
 		       && strcmp (p->sec->output_section->name,
 				  ".tls_vars") == 0)
 		{
@@ -1285,7 +1286,7 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,
 		return FALSE;
 	    }
 	}
-      if (htab->is_vxworks
+      if (htab->target_os == is_vxworks
 	  && !elf_vxworks_add_dynamic_entries (output_bfd, info))
 	return FALSE;
     }
@@ -1377,7 +1378,7 @@ _bfd_x86_elf_finish_dynamic_sections (bfd *output_bfd,
       switch (dyn.d_tag)
 	{
 	default:
-	  if (htab->is_vxworks
+	  if (htab->target_os == is_vxworks
 	      && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))
 	    break;
 	  continue;
@@ -1836,7 +1837,7 @@ _bfd_x86_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
   if (ELIMINATE_COPY_RELOCS
       && (bed->target_id == X86_64_ELF_DATA
 	  || (!eh->gotoff_ref
-	      && !htab->is_vxworks)))
+	      && htab->target_os != is_vxworks)))
     {
       for (p = eh->dyn_relocs; p != NULL; p = p->next)
 	{
@@ -2414,13 +2415,14 @@ error_alignment:
   if (htab == NULL)
     return pbfd;
 
-  htab->is_vxworks = init_table->is_vxworks;
   htab->r_info = init_table->r_info;
   htab->r_sym = init_table->r_sym;
 
   if (bfd_link_relocatable (info))
     return pbfd;
 
+  htab->plt0_pad_byte = init_table->plt0_pad_byte;
+
   use_ibt_plt = info->ibtplt || info->ibt;
   if (!use_ibt_plt && pbfd != NULL)
     {
@@ -2472,11 +2474,15 @@ error_alignment:
 	}
     }
 
+  /* Return if there are no normal input files.  */
+  if (dynobj == NULL)
+    return pbfd;
+
   /* Even when lazy binding is disabled by "-z now", the PLT0 entry may
      still be used with LD_AUDIT or LD_PROFILE if PLT entry is used for
      canonical function address.  */
   htab->plt.has_plt0 = 1;
-  normal_target = init_table->normal_target;
+  normal_target = htab->target_os == is_normal;
 
   if (normal_target)
     {
@@ -2539,11 +2545,7 @@ error_alignment:
       htab->plt.eh_frame_plt = htab->lazy_plt->eh_frame_plt;
     }
 
-  /* Return if there are no normal input files.  */
-  if (dynobj == NULL)
-    return pbfd;
-
-  if (htab->is_vxworks
+  if (htab->target_os == is_vxworks
       && !elf_vxworks_create_dynamic_sections (dynobj, info,
 					       &htab->srelplt2))
     {
diff --git a/bfd/elfxx-x86.h b/bfd/elfxx-x86.h
index 3d6366f16b..5e33cdd1ba 100644
--- a/bfd/elfxx-x86.h
+++ b/bfd/elfxx-x86.h
@@ -256,6 +256,13 @@ struct elf_x86_plt_layout
 #define elf_x86_hash_entry(ent) \
   ((struct elf_x86_link_hash_entry *)(ent))
 
+enum elf_x86_target_os
+{
+  is_normal,
+  is_vxworks,
+  is_nacl
+};
+
 /* x86 ELF linker hash table.  */
 
 struct elf_x86_link_hash_table
@@ -311,10 +318,6 @@ struct elf_x86_link_hash_table
      to read-only sections.  */
   bfd_boolean readonly_dynrelocs_against_ifunc;
 
-  /* TRUE if this is a VxWorks x86 target.  This is only used for
-     i386.  */
-  bfd_boolean is_vxworks;
-
   /* The (unloaded but important) .rel.plt.unloaded section on VxWorks.
      This is used for i386 only.  */
   asection *srelplt2;
@@ -329,10 +332,15 @@ struct elf_x86_link_hash_table
      yet.  This is only used for x86-64.  */
   bfd_vma tlsdesc_plt;
 
+   /* Value used to fill the unused bytes of the first PLT entry.  This
+      is only used for i386.  */
+  bfd_byte plt0_pad_byte;
+
   bfd_vma (*r_info) (bfd_vma, bfd_vma);
   bfd_vma (*r_sym) (bfd_vma);
   bfd_boolean (*is_reloc_section) (const char *);
   enum elf_target_id target_id;
+  enum elf_x86_target_os target_os;
   unsigned int sizeof_reloc;
   unsigned int dt_reloc;
   unsigned int dt_reloc_sz;
@@ -344,6 +352,18 @@ struct elf_x86_link_hash_table
   const char *tls_get_addr;
 };
 
+/* Architecture-specific backend data for x86.  */
+
+struct elf_x86_backend_data
+{
+  /* Target system.  */
+  enum elf_x86_target_os target_os;
+};
+
+#define get_elf_x86_backend_data(abfd) \
+  ((const struct elf_x86_backend_data *) \
+   get_elf_backend_data (abfd)->arch_data)
+
 struct elf_x86_init_table
 {
   /* The lazy PLT layout.  */
@@ -358,11 +378,7 @@ struct elf_x86_init_table
   /* The non-lazy PLT layout for IBT.  */
   const struct elf_x86_non_lazy_plt_layout *non_lazy_ibt_plt;
 
-  /* TRUE if this is a normal x86 target.  */
-  bfd_boolean normal_target;
-
-  /* TRUE if this is a VxWorks x86 target.  */
-  bfd_boolean is_vxworks;
+  bfd_byte plt0_pad_byte;
 
   bfd_vma (*r_info) (bfd_vma, bfd_vma);
   bfd_vma (*r_sym) (bfd_vma);
-- 
2.13.5

