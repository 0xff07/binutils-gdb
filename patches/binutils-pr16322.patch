From ce1d18f804ad98c07ad10f29e25d00e9e74e670b Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Thu, 12 Dec 2013 10:35:47 -0800
Subject: [PATCH] Adjust LOAD segment to generate GNU_RELRO segment

---
 ChangeLog.pr16322                | 32 +++++++++++++++++++++++++++++++
 bfd/elf.c                        | 41 +++++++++++++++++++++++++++++++++++-----
 ld/ldlang.c                      |  3 ++-
 ld/testsuite/ld-elf/pr16322.d    |  7 +++++++
 ld/testsuite/ld-elf/pr16322.s    |  6 ++++++
 ld/testsuite/ld-x86-64/pr14207.d | 23 ++++++++++++++++++----
 6 files changed, 102 insertions(+), 10 deletions(-)
 create mode 100644 ChangeLog.pr16322
 create mode 100644 ld/testsuite/ld-elf/pr16322.d
 create mode 100644 ld/testsuite/ld-elf/pr16322.s

diff --git a/ChangeLog.pr16322 b/ChangeLog.pr16322
new file mode 100644
index 0000000..176f263
--- /dev/null
+++ b/ChangeLog.pr16322
@@ -0,0 +1,32 @@
+bfd/
+
+2013-12-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/14207
+	PR ld/16322
+	PR binutils/16323
+	* elf.c (_bfd_elf_map_sections_to_segments): Don't check section
+	size for PT_GNU_RELRO segment.
+	(assign_file_positions_for_load_sections): If PT_LOAD segment
+	doesn't fit PT_GNU_RELRO segment, adjust its p_filesz and p_memsz.
+
+ld/
+
+2013-12-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/14207
+	PR ld/16322
+	PR binutils/16323
+	* ldlang.c (lang_size_sections): Properly align RELRO base.
+
+ld/testsuite/
+
+2013-12-12  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/14207
+	PR ld/16322
+	PR binutils/16323
+	* ld-elf/pr16322.d: New file.
+	* ld-elf/pr16322.s: Likewise.
+
+	* ld-x86-64/pr14207.d: Expect PT_GNU_RELRO segment.
diff --git a/bfd/elf.c b/bfd/elf.c
index 66d9644..65d579b 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -4176,11 +4176,7 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)
 			== (SEC_LOAD | SEC_HAS_CONTENTS))
 		      break;
 
-		  if (i == (unsigned) -1)
-		    continue;
-
-		  if (m->sections[i]->vma + m->sections[i]->size
-		      >= info->relro_end)
+		  if (i != (unsigned) -1)
 		    break;
 		}
 	    }
@@ -4369,6 +4365,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
   unsigned int alloc;
   unsigned int i, j;
   bfd_vma header_pad = 0;
+  bfd_vma relro_start = 0, relro_end = 0;
 
   if (link_info == NULL
       && !_bfd_elf_map_sections_to_segments (abfd, link_info))
@@ -4439,6 +4436,23 @@ assign_file_positions_for_load_sections (bfd *abfd,
     header_pad -= off;
   off += header_pad;
 
+  /* Get start and end of PT_GNU_RELRO segment.  */
+  if (link_info != NULL)
+    {
+      relro_start = link_info->relro_start;
+      relro_end = link_info->relro_end;
+    }
+  else
+    {
+      for (m = elf_seg_map (abfd); m != NULL; m = m->next)
+	if (m->p_type == PT_GNU_RELRO)
+	  {
+	    relro_start = m->p_paddr;
+	    relro_end = relro_start + m->p_size;
+	    break;
+	  }
+    }
+
   for (m = elf_seg_map (abfd), p = phdrs, j = 0;
        m != NULL;
        m = m->next, p++, j++)
@@ -4781,6 +4795,23 @@ assign_file_positions_for_load_sections (bfd *abfd,
 		p->p_flags |= PF_W;
 	    }
 	}
+
+      if (relro_start != 0
+	  && p->p_type == PT_LOAD
+	  && p->p_vaddr >= relro_start)
+	{
+	  /* If PT_LOAD segment doesn't fit PT_GNU_RELRO segment,
+	     adjust its p_filesz and p_memsz.  */
+	  if (p->p_vaddr + p->p_filesz < relro_end)
+	    {
+	      bfd_vma adjust = relro_end - (p->p_vaddr + p->p_filesz);
+	      p->p_filesz += adjust;
+	      off += adjust;
+	    }
+	  if (p->p_vaddr + p->p_memsz < relro_end)
+	    p->p_memsz += relro_end - (p->p_vaddr + p->p_memsz);
+	}
+
       off -= off_adjust;
 
       /* Check that all sections are in a PT_LOAD segment.
diff --git a/ld/ldlang.c b/ld/ldlang.c
index ba7f493..7851615 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -5407,7 +5407,8 @@ lang_size_sections (bfd_boolean *relax, bfd_boolean check_regions)
 	    {
 	      if (expld.dataseg.base - (1 << max_alignment_power) < old_base)
 		expld.dataseg.base += expld.dataseg.pagesize;
-	      expld.dataseg.base -= (1 << max_alignment_power);
+	      /* Properly align base to max_alignment_power.  */
+	      expld.dataseg.base &= ~((1 << max_alignment_power) - 1);
 	      lang_reset_memory_regions ();
 	      one_lang_size_sections_pass (relax, check_regions);
 	    }
diff --git a/ld/testsuite/ld-elf/pr16322.d b/ld/testsuite/ld-elf/pr16322.d
new file mode 100644
index 0000000..40a7975
--- /dev/null
+++ b/ld/testsuite/ld-elf/pr16322.d
@@ -0,0 +1,7 @@
+#ld: -shared -z relro
+#readelf: -l --wide
+#target: *-*-linux-gnu *-*-gnu* *-*-nacl*
+
+#...
+  GNU_RELRO .*
+#pass
diff --git a/ld/testsuite/ld-elf/pr16322.s b/ld/testsuite/ld-elf/pr16322.s
new file mode 100644
index 0000000..c95817a
--- /dev/null
+++ b/ld/testsuite/ld-elf/pr16322.s
@@ -0,0 +1,6 @@
+	.globl	p1
+	.section	.data.rel.ro,"aw",%progbits
+	.p2align 5
+	.type	p1, %object
+p1:
+	.dc.a	f1
diff --git a/ld/testsuite/ld-x86-64/pr14207.d b/ld/testsuite/ld-x86-64/pr14207.d
index 2362e88..b1e2d5a 100644
--- a/ld/testsuite/ld-x86-64/pr14207.d
+++ b/ld/testsuite/ld-x86-64/pr14207.d
@@ -2,8 +2,23 @@
 #as: --64
 #ld: -melf_x86_64 -shared -z relro -z now
 #readelf: -l --wide
+#target: x86_64-*-linux*
 
-#failif
-#...
-  NULL +.*
-#...
+Elf file type is DYN \(Shared object file\)
+Entry point 0x1d9
+There are 4 program headers, starting at offset 64
+
+Program Headers:
+  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
+  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x0001e0 0x0001e0 R   0x200000
+  LOAD           0x000b48 0x0000000000200b48 0x0000000000200b48 0x0004b8 0x000cf8 RW  0x200000
+  DYNAMIC        0x000b90 0x0000000000200b90 0x0000000000200b90 0x0001c0 0x0001c0 RW  0x8
+  GNU_RELRO      0x000b48 0x0000000000200b48 0x0000000000200b48 0x0004b8 0x0004b8 R   0x1
+
+ Section to Segment mapping:
+  Segment Sections...
+   00     .hash .dynsym .dynstr 
+   01     .init_array .fini_array .jcr .data.rel.ro .dynamic .got .bss 
+   02     .dynamic 
+   03     .init_array .fini_array .jcr .data.rel.ro .dynamic .got 
+#pass
-- 
1.8.3.1

